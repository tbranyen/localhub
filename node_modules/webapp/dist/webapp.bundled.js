(function(window, factory) {
  "use strict";

  // AMD. Register as an anonymous module.  Wrap in function so we have access
  // to root via `this`.
  if (typeof define === "function" && define.amd) {
    return define([undefined], function() {
      return factory.apply(window, arguments);
    });
  }
  
  // Node. Does not work with strict CommonJS, but only CommonJS-like
  // enviroments that support module.exports, like Node.
  else if (typeof exports === "object") {
    module.exports = factory.call(window, undefined);
  }

  // Browser globals.
  else {
    
    var retVal = factory.call(window, undefined);

    
    define.modules["WebApp"] = retVal;
    
  }
}(typeof global === "object" ? global : this, function() {
  "use strict";

  // Set window to always equal the global object.
  var window = typeof global === "object" ? global : this;

  // Repurpose the `define` function, as it is the only identifier we can
  // safely shadow.  Ensure that any missing `define` transforms still
  // register.
  var define = function(name, deps, callback) {
    define.modules[name] = callback();
  };

  // Save references to the original define and a boolean for whether or not
  // it was pre-existing.
  define.originalDefine = window.define;
  define.hadDefine = "define" in window;

  // The module namespace.
  define.modules = {};

  // Link dependencies.
  

  // Ensure AMD checks are satisfied in third-party code.
  define.amd = {};

  /**
   * @license
   * lodash 3.5.0 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern -d -o ./index.js`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */
  ;(function() {

    /** Used as a safe reference for `undefined` in pre-ES5 environments. */
    var undefined;

    /** Used as the semantic version number. */
    var VERSION = '3.5.0';

    /** Used to compose bitmasks for wrapper metadata. */
    var BIND_FLAG = 1,
        BIND_KEY_FLAG = 2,
        CURRY_BOUND_FLAG = 4,
        CURRY_FLAG = 8,
        CURRY_RIGHT_FLAG = 16,
        PARTIAL_FLAG = 32,
        PARTIAL_RIGHT_FLAG = 64,
        REARG_FLAG = 128,
        ARY_FLAG = 256;

    /** Used as default options for `_.trunc`. */
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';

    /** Used to detect when a function becomes hot. */
    var HOT_COUNT = 150,
        HOT_SPAN = 16;

    /** Used to indicate the type of lazy iteratees. */
    var LAZY_DROP_WHILE_FLAG = 0,
        LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2;

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to match empty string literals in compiled template source. */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

    /** Used to match HTML entities and HTML characters. */
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
        reUnescapedHtml = /[&<>"'`]/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

    /** Used to match template delimiters. */
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;

    /**
     * Used to match ES template delimiters.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
     * for more details.
     */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /** Used to detect named functions. */
    var reFuncName = /^\s*function[ \n\r\t]+\w/;

    /** Used to detect hexadecimal string values. */
    var reHexPrefix = /^0[xX]/;

    /** Used to detect host constructors (Safari > 5). */
    var reHostCtor = /^\[object .+?Constructor\]$/;

    /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

    /** Used to ensure capturing order of template delimiters. */
    var reNoMatch = /($^)/;

    /**
     * Used to match `RegExp` special characters.
     * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
     * for more details.
     */
    var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
        reHasRegExpChars = RegExp(reRegExpChars.source);

    /** Used to detect functions containing a `this` reference. */
    var reThis = /\bthis\b/;

    /** Used to match unescaped characters in compiled string literals. */
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

    /** Used to match words to create compound words. */
    var reWords = (function() {
      var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
          lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

      return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
    }());

    /** Used to detect and test for whitespace. */
    var whitespace = (
      // Basic whitespace characters.
      ' \t\x0b\f\xa0\ufeff' +

      // Line terminators.
      '\n\r\u2028\u2029' +

      // Unicode category "Zs" space separators.
      '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
    );

    /** Used to assign default `context` object properties. */
    var contextProps = [
      'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
      'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
      'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
      'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
      'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
      'window', 'WinRTError'
    ];

    /** Used to make template sourceURLs easier to identify. */
    var templateCounter = -1;

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dateTag] = typedArrayTags[errorTag] =
    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
    typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
    cloneableTags[dateTag] = cloneableTags[float32Tag] =
    cloneableTags[float64Tag] = cloneableTags[int8Tag] =
    cloneableTags[int16Tag] = cloneableTags[int32Tag] =
    cloneableTags[numberTag] = cloneableTags[objectTag] =
    cloneableTags[regexpTag] = cloneableTags[stringTag] =
    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] =
    cloneableTags[mapTag] = cloneableTags[setTag] =
    cloneableTags[weakMapTag] = false;

    /** Used as an internal `_.debounce` options object by `_.throttle`. */
    var debounceOptions = {
      'leading': false,
      'maxWait': 0,
      'trailing': false
    };

    /** Used to map latin-1 supplementary letters to basic latin letters. */
    var deburredLetters = {
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss'
    };

    /** Used to map characters to HTML entities. */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '`': '&#96;'
    };

    /** Used to map HTML entities to characters. */
    var htmlUnescapes = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'",
      '&#96;': '`'
    };

    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };

    /** Used to escape characters for inclusion in compiled string literals. */
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    /** Detect free variable `exports`. */
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;

    /** Detect free variable `window`. */
    var freeWindow = objectTypes[typeof window] && window;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it is the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `compareAscending` which compares values and
     * sorts them in ascending order without guaranteeing a stable sort.
     *
     * @private
     * @param {*} value The value to compare to `other`.
     * @param {*} other The value to compare to `value`.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function baseCompareAscending(value, other) {
      if (value !== other) {
        var valIsReflexive = value === value,
            othIsReflexive = other === other;

        if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
          return 1;
        }
        if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * The base implementation of `_.indexOf` without support for binary searches.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return indexOfNaN(array, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.isFunction` without support for environments
     * with incorrect `typeof` results.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     */
    function baseIsFunction(value) {
      // Avoid a Chakra JIT bug in compatibility modes of IE 11.
      // See https://github.com/jashkenas/underscore/issues/1621 for more details.
      return typeof value == 'function' || false;
    }

    /**
     * Converts `value` to a string if it is not one. An empty string is returned
     * for `null` or `undefined` values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      if (typeof value == 'string') {
        return value;
      }
      return value == null ? '' : (value + '');
    }

    /**
     * Used by `_.max` and `_.min` as the default callback for string values.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the code unit of the first character of the string.
     */
    function charAtCallback(string) {
      return string.charCodeAt(0);
    }

    /**
     * Used by `_.trim` and `_.trimLeft` to get the index of the first character
     * of `string` that is not found in `chars`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @param {string} chars The characters to find.
     * @returns {number} Returns the index of the first character not found in `chars`.
     */
    function charsLeftIndex(string, chars) {
      var index = -1,
          length = string.length;

      while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
      return index;
    }

    /**
     * Used by `_.trim` and `_.trimRight` to get the index of the last character
     * of `string` that is not found in `chars`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @param {string} chars The characters to find.
     * @returns {number} Returns the index of the last character not found in `chars`.
     */
    function charsRightIndex(string, chars) {
      var index = string.length;

      while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
      return index;
    }

    /**
     * Used by `_.sortBy` to compare transformed elements of a collection and stable
     * sort them in ascending order.
     *
     * @private
     * @param {Object} object The object to compare to `other`.
     * @param {Object} other The object to compare to `object`.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareAscending(object, other) {
      return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
    }

    /**
     * Used by `_.sortByOrder` to compare multiple properties of each element
     * in a collection and stable sort them in the following order:
     *
     * If orders is unspecified, sort in ascending order for all properties.
     * Otherwise, for each property, sort in ascending order if its corresponding value in
     * orders is true, and descending order if false.
     *
     * @private
     * @param {Object} object The object to compare to `other`.
     * @param {Object} other The object to compare to `object`.
     * @param {boolean[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          return result * (orders[index] ? 1 : -1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    function deburrLetter(letter) {
      return deburredLetters[letter];
    }

    /**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(chr) {
      return htmlEscapes[chr];
    }

    /**
     * Used by `_.template` to escape characters for inclusion in compiled
     * string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr];
    }

    /**
     * Gets the index at which the first occurrence of `NaN` is found in `array`.
     * If `fromRight` is provided elements of `array` are iterated from right to left.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched `NaN`, else `-1`.
     */
    function indexOfNaN(array, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 0 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        var other = array[index];
        if (other !== other) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Checks if `value` is object-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     */
    function isObjectLike(value) {
      return (value && typeof value == 'object') || false;
    }

    /**
     * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
     * character code is whitespace.
     *
     * @private
     * @param {number} charCode The character code to inspect.
     * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
     */
    function isSpace(charCode) {
      return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
        (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
    }

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        if (array[index] === placeholder) {
          array[index] = PLACEHOLDER;
          result[++resIndex] = index;
        }
      }
      return result;
    }

    /**
     * An implementation of `_.uniq` optimized for sorted arrays without support
     * for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function sortedUniq(array, iteratee) {
      var seen,
          index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (!index || seen !== computed) {
          seen = computed;
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the first non-whitespace character.
     */
    function trimmedLeftIndex(string) {
      var index = -1,
          length = string.length;

      while (++index < length && isSpace(string.charCodeAt(index))) {}
      return index;
    }

    /**
     * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedRightIndex(string) {
      var index = string.length;

      while (index-- && isSpace(string.charCodeAt(index))) {}
      return index;
    }

    /**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(chr) {
      return htmlUnescapes[chr];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Create a new pristine `lodash` function using the given `context` object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'add': function(a, b) { return a + b; } });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
     *
     * _.isFunction(_.add);
     * // => true
     * _.isFunction(_.sub);
     * // => false
     *
     * lodash.isFunction(lodash.add);
     * // => false
     * lodash.isFunction(lodash.sub);
     * // => true
     *
     * // using `context` to mock `Date#getTime` use in `_.now`
     * var mock = _.runInContext({
     *   'Date': function() {
     *     return { 'getTime': getTimeMock };
     *   }
     * });
     *
     * // or creating a suped-up `defer` in Node.js
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */
    function runInContext(context) {
      // Avoid issues with some ES3 environments that attempt to use values, named
      // after built-in constructors like `Object`, for the creation of literals.
      // ES5 clears this up by stating that literals must use built-in constructors.
      // See https://es5.github.io/#x11.1.5 for more details.
      context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

      /** Native constructor references. */
      var Array = context.Array,
          Date = context.Date,
          Error = context.Error,
          Function = context.Function,
          Math = context.Math,
          Number = context.Number,
          Object = context.Object,
          RegExp = context.RegExp,
          String = context.String,
          TypeError = context.TypeError;

      /** Used for native method references. */
      var arrayProto = Array.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype;

      /** Used to detect DOM support. */
      var document = (document = context.window) && document.document;

      /** Used to resolve the decompiled source of functions. */
      var fnToString = Function.prototype.toString;

      /** Used to the length of n-tuples for `_.unzip`. */
      var getLength = baseProperty('length');

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Used to generate unique IDs. */
      var idCounter = 0;

      /**
       * Used to resolve the `toStringTag` of values.
       * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
       * for more details.
       */
      var objToString = objectProto.toString;

      /** Used to restore the original `_` reference in `_.noConflict`. */
      var oldDash = context._;

      /** Used to detect if a method is native. */
      var reNative = RegExp('^' +
        escapeRegExp(objToString)
        .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
      );

      /** Native method references. */
      var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
          bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
          ceil = Math.ceil,
          clearTimeout = context.clearTimeout,
          floor = Math.floor,
          getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
          push = arrayProto.push,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          Set = isNative(Set = context.Set) && Set,
          setTimeout = context.setTimeout,
          splice = arrayProto.splice,
          Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
          WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

      /** Used to clone array buffers. */
      var Float64Array = (function() {
        // Safari 5 errors when using an array buffer to initialize a typed array
        // where the array buffer's `byteLength` is not a multiple of the typed
        // array's `BYTES_PER_ELEMENT`.
        try {
          var func = isNative(func = context.Float64Array) && func,
              result = new func(new ArrayBuffer(10), 0, 1) && func;
        } catch(e) {}
        return result;
      }());

      /* Native method references for those with the same name as other `lodash` methods. */
      var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
          nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
          nativeIsFinite = context.isFinite,
          nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeNow = isNative(nativeNow = Date.now) && nativeNow,
          nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random;

      /** Used as references for `-Infinity` and `Infinity`. */
      var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
          POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
          MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used as the size, in bytes, of each `Float64Array` element. */
      var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

      /**
       * Used as the maximum length of an array-like value.
       * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
       * for more details.
       */
      var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

      /** Used to store function metadata. */
      var metaMap = WeakMap && new WeakMap;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a `lodash` object which wraps `value` to enable implicit chaining.
       * Methods that operate on and return arrays, collections, and functions can
       * be chained together. Methods that return a boolean or single value will
       * automatically end the chain returning the unwrapped value. Explicit chaining
       * may be enabled using `_.chain`. The execution of chained methods is lazy,
       * that is, execution is deferred until `_#value` is implicitly or explicitly
       * called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
       * fusion is an optimization that merges iteratees to avoid creating intermediate
       * arrays and reduce the number of iteratee executions.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
       * `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
       * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
       * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
       * and `where`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
       * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
       * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
       * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
       * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
       * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
       * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
       * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
       * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
       * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
       * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
       * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,
       * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,
       * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,
       * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,
       * `without`, `wrap`, `xor`, `zip`, and `zipObject`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
       * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
       * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
       * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,
       * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
       * `isFinite`,`isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
       * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
       * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
       * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
       * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
       * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
       * `startCase`, `startsWith`, `sum`, `template`, `trim`, `trimLeft`,
       * `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
       *
       * The wrapper method `sample` will return a wrapped value when `n` is provided,
       * otherwise an unwrapped value is returned.
       *
       * @name _
       * @constructor
       * @category Chain
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // returns an unwrapped value
       * wrapped.reduce(function(sum, n) {
       *   return sum + n;
       * });
       * // => 6
       *
       * // returns a wrapped value
       * var squares = wrapped.map(function(n) {
       *   return n * n;
       * });
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }

      /**
       * The function whose prototype all chaining wrappers inherit from.
       *
       * @private
       */
      function baseLodash() {
        // No operation performed.
      }

      /**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
       * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
       */
      function LodashWrapper(value, chainAll, actions) {
        this.__wrapped__ = value;
        this.__actions__ = actions || [];
        this.__chain__ = !!chainAll;
      }

      /**
       * An object environment feature flags.
       *
       * @static
       * @memberOf _
       * @type Object
       */
      var support = lodash.support = {};

      (function(x) {

        /**
         * Detect if functions can be decompiled by `Function#toString`
         * (all but Firefox OS certified apps, older Opera mobile browsers, and
         * the PlayStation 3; forced `false` for Windows 8 apps).
         *
         * @memberOf _.support
         * @type boolean
         */
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

        /**
         * Detect if `Function#name` is supported (all but IE).
         *
         * @memberOf _.support
         * @type boolean
         */
        support.funcNames = typeof Function.name == 'string';

        /**
         * Detect if the DOM is supported.
         *
         * @memberOf _.support
         * @type boolean
         */
        try {
          support.dom = document.createDocumentFragment().nodeType === 11;
        } catch(e) {
          support.dom = false;
        }

        /**
         * Detect if `arguments` object indexes are non-enumerable.
         *
         * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
         * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
         * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
         * checks for indexes that exceed their function's formal parameters with
         * associated values of `0`.
         *
         * @memberOf _.support
         * @type boolean
         */
        try {
          support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
        } catch(e) {
          support.nonEnumArgs = true;
        }
      }(0, 0));

      /**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB). Change the following template settings to use
       * alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type Object
       */
      lodash.templateSettings = {

        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'escape': reEscape,

        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'evaluate': reEvaluate,

        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'interpolate': reInterpolate,

        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type string
         */
        'variable': '',

        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type Object
         */
        'imports': {

          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type Function
           */
          '_': lodash
        }
      };

      /*------------------------------------------------------------------------*/

      /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @param {*} value The value to wrap.
       */
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = null;
        this.__dir__ = 1;
        this.__dropCount__ = 0;
        this.__filtered__ = false;
        this.__iteratees__ = null;
        this.__takeCount__ = POSITIVE_INFINITY;
        this.__views__ = null;
      }

      /**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */
      function lazyClone() {
        var actions = this.__actions__,
            iteratees = this.__iteratees__,
            views = this.__views__,
            result = new LazyWrapper(this.__wrapped__);

        result.__actions__ = actions ? arrayCopy(actions) : null;
        result.__dir__ = this.__dir__;
        result.__filtered__ = this.__filtered__;
        result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
        result.__takeCount__ = this.__takeCount__;
        result.__views__ = views ? arrayCopy(views) : null;
        return result;
      }

      /**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */
      function lazyReverse() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1;
          result.__filtered__ = true;
        } else {
          result = this.clone();
          result.__dir__ *= -1;
        }
        return result;
      }

      /**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */
      function lazyValue() {
        var array = this.__wrapped__.value();
        if (!isArray(array)) {
          return baseWrapperValue(array, this.__actions__);
        }
        var dir = this.__dir__,
            isRight = dir < 0,
            view = getView(0, array.length, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : (start - 1),
            takeCount = nativeMin(length, this.__takeCount__),
            iteratees = this.__iteratees__,
            iterLength = iteratees ? iteratees.length : 0,
            resIndex = 0,
            result = [];

        outer:
        while (length-- && resIndex < takeCount) {
          index += dir;

          var iterIndex = -1,
              value = array[index];

          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type;

            if (type == LAZY_DROP_WHILE_FLAG) {
              if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
                data.count = 0;
                data.done = false;
              }
              data.index = index;
              if (!data.done) {
                var limit = data.limit;
                if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                  continue outer;
                }
              }
            } else {
              var computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
          }
          result[resIndex++] = value;
        }
        return result;
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates a cache object to store key/value pairs.
       *
       * @private
       * @static
       * @name Cache
       * @memberOf _.memoize
       */
      function MapCache() {
        this.__data__ = {};
      }

      /**
       * Removes `key` and its value from the cache.
       *
       * @private
       * @name delete
       * @memberOf _.memoize.Cache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
       */
      function mapDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }

      /**
       * Gets the cached value for `key`.
       *
       * @private
       * @name get
       * @memberOf _.memoize.Cache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the cached value.
       */
      function mapGet(key) {
        return key == '__proto__' ? undefined : this.__data__[key];
      }

      /**
       * Checks if a cached value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf _.memoize.Cache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function mapHas(key) {
        return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
      }

      /**
       * Adds `value` to `key` of the cache.
       *
       * @private
       * @name set
       * @memberOf _.memoize.Cache
       * @param {string} key The key of the value to cache.
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache object.
       */
      function mapSet(key, value) {
        if (key != '__proto__') {
          this.__data__[key] = value;
        }
        return this;
      }

      /*------------------------------------------------------------------------*/

      /**
       *
       * Creates a cache object to store unique values.
       *
       * @private
       * @param {Array} [values] The values to cache.
       */
      function SetCache(values) {
        var length = values ? values.length : 0;

        this.data = { 'hash': nativeCreate(null), 'set': new Set };
        while (length--) {
          this.push(values[length]);
        }
      }

      /**
       * Checks if `value` is in `cache` mimicking the return signature of
       * `_.indexOf` by returning `0` if the value is found, else `-1`.
       *
       * @private
       * @param {Object} cache The cache to search.
       * @param {*} value The value to search for.
       * @returns {number} Returns `0` if `value` is found, else `-1`.
       */
      function cacheIndexOf(cache, value) {
        var data = cache.data,
            result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

        return result ? 0 : -1;
      }

      /**
       * Adds `value` to the cache.
       *
       * @private
       * @name push
       * @memberOf SetCache
       * @param {*} value The value to cache.
       */
      function cachePush(value) {
        var data = this.data;
        if (typeof value == 'string' || isObject(value)) {
          data.set.add(value);
        } else {
          data.hash[value] = true;
        }
      }

      /*------------------------------------------------------------------------*/

      /**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */
      function arrayCopy(source, array) {
        var index = -1,
            length = source.length;

        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * callback shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[++resIndex] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.map` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * A specialized version of `_.max` for arrays without support for iteratees.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       */
      function arrayMax(array) {
        var index = -1,
            length = array.length,
            result = NEGATIVE_INFINITY;

        while (++index < length) {
          var value = array[index];
          if (value > result) {
            result = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.min` for arrays without support for iteratees.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       */
      function arrayMin(array) {
        var index = -1,
            length = array.length,
            result = POSITIVE_INFINITY;

        while (++index < length) {
          var value = array[index];
          if (value < result) {
            result = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initFromArray] Specify using the first element of `array`
       *  as the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initFromArray) {
        var index = -1,
            length = array.length;

        if (initFromArray && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * callback shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initFromArray] Specify using the last element of `array`
       *  as the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
        var length = array.length;
        if (initFromArray && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Used by `_.defaults` to customize its `_.assign` use.
       *
       * @private
       * @param {*} objectValue The destination object property value.
       * @param {*} sourceValue The source object property value.
       * @returns {*} Returns the value to assign to the destination object.
       */
      function assignDefaults(objectValue, sourceValue) {
        return typeof objectValue == 'undefined' ? sourceValue : objectValue;
      }

      /**
       * Used by `_.template` to customize its `_.assign` use.
       *
       * **Note:** This method is like `assignDefaults` except that it ignores
       * inherited property values when checking if a property is `undefined`.
       *
       * @private
       * @param {*} objectValue The destination object property value.
       * @param {*} sourceValue The source object property value.
       * @param {string} key The key associated with the object and source values.
       * @param {Object} object The destination object.
       * @returns {*} Returns the value to assign to the destination object.
       */
      function assignOwnDefaults(objectValue, sourceValue, key, object) {
        return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
          ? sourceValue
          : objectValue;
      }

      /**
       * The base implementation of `_.assign` without support for argument juggling,
       * multiple sources, and `this` binding `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {Function} [customizer] The function to customize assigning values.
       * @returns {Object} Returns the destination object.
       */
      function baseAssign(object, source, customizer) {
        var props = keys(source);
        if (!customizer) {
          return baseCopy(source, object, props);
        }
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index],
              value = object[key],
              result = customizer(value, source[key], key, object, source);

          if ((result === result ? (result !== value) : (value === value)) ||
              (typeof value == 'undefined' && !(key in object))) {
            object[key] = result;
          }
        }
        return object;
      }

      /**
       * The base implementation of `_.at` without support for strings and individual
       * key arguments.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
       * @returns {Array} Returns the new array of picked elements.
       */
      function baseAt(collection, props) {
        var index = -1,
            length = collection.length,
            isArr = isLength(length),
            propsLength = props.length,
            result = Array(propsLength);

        while(++index < propsLength) {
          var key = props[index];
          if (isArr) {
            key = parseFloat(key);
            result[index] = isIndex(key, length) ? collection[key] : undefined;
          } else {
            result[index] = collection[key];
          }
        }
        return result;
      }

      /**
       * Copies the properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Array} props The property names to copy.
       * @returns {Object} Returns `object`.
       */
      function baseCopy(source, object, props) {
        if (!props) {
          props = object;
          object = {};
        }
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          object[key] = source[key];
        }
        return object;
      }

      /**
       * The base implementation of `_.bindAll` without support for individual
       * method name arguments.
       *
       * @private
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {string[]} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       */
      function baseBindAll(object, methodNames) {
        var index = -1,
            length = methodNames.length;

        while (++index < length) {
          var key = methodNames[index];
          object[key] = createWrapper(object[key], BIND_FLAG, object);
        }
        return object;
      }

      /**
       * The base implementation of `_.callback` which supports specifying the
       * number of arguments to provide to `func`.
       *
       * @private
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {number} [argCount] The number of arguments to provide to `func`.
       * @returns {Function} Returns the callback.
       */
      function baseCallback(func, thisArg, argCount) {
        var type = typeof func;
        if (type == 'function') {
          return (typeof thisArg != 'undefined' && isBindable(func))
            ? bindCallback(func, thisArg, argCount)
            : func;
        }
        if (func == null) {
          return identity;
        }
        if (type == 'object') {
          return baseMatches(func);
        }
        return typeof thisArg == 'undefined'
          ? baseProperty(func + '')
          : baseMatchesProperty(func + '', thisArg);
      }

      /**
       * The base implementation of `_.clone` without support for argument juggling
       * and `this` binding `customizer` functions.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @param {Function} [customizer] The function to customize cloning values.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The object `value` belongs to.
       * @param {Array} [stackA=[]] Tracks traversed source objects.
       * @param {Array} [stackB=[]] Associates clones with source counterparts.
       * @returns {*} Returns the cloned value.
       */
      function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object) : customizer(value);
        }
        if (typeof result != 'undefined') {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return arrayCopy(value, result);
          }
        } else {
          var tag = objToString.call(value),
              isFunc = tag == funcTag;

          if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) {
              return baseCopy(value, result, keys(value));
            }
          } else {
            return cloneableTags[tag]
              ? initCloneByTag(value, tag, isDeep)
              : (object ? value : {});
          }
        }
        // Check for circular references and return corresponding clone.
        stackA || (stackA = []);
        stackB || (stackB = []);

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        // Add the source value to the stack of traversed objects and associate it with its clone.
        stackA.push(value);
        stackB.push(result);

        // Recursively populate clone (susceptible to call stack limits).
        (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
          result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
        });
        return result;
      }

      /**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} prototype The object to inherit from.
       * @returns {Object} Returns the new object.
       */
      var baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());

      /**
       * The base implementation of `_.delay` and `_.defer` which accepts an index
       * of where to slice the arguments to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Object} args The `arguments` object to slice and provide to `func`.
       * @returns {number} Returns the timer id.
       */
      function baseDelay(func, wait, args, fromIndex) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
      }

      /**
       * The base implementation of `_.difference` which accepts a single array
       * of values to exclude.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       */
      function baseDifference(array, values) {
        var length = array ? array.length : 0,
            result = [];

        if (!length) {
          return result;
        }
        var index = -1,
            indexOf = getIndexOf(),
            isCommon = indexOf == baseIndexOf,
            cache = (isCommon && values.length >= 200) ? createCache(values) : null,
            valuesLength = values.length;

        if (cache) {
          indexOf = cacheIndexOf;
          isCommon = false;
          values = cache;
        }
        outer:
        while (++index < length) {
          var value = array[index];

          if (isCommon && value === value) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === value) {
                continue outer;
              }
            }
            result.push(value);
          }
          else if (indexOf(values, value, 0) < 0) {
            result.push(value);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.forEach` without support for callback
       * shorthands and `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object|string} Returns `collection`.
       */
      function baseEach(collection, iteratee) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
          return baseForOwn(collection, iteratee);
        }
        var index = -1,
            iterable = toObject(collection);

        while (++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      }

      /**
       * The base implementation of `_.forEachRight` without support for callback
       * shorthands and `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object|string} Returns `collection`.
       */
      function baseEachRight(collection, iteratee) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
          return baseForOwnRight(collection, iteratee);
        }
        var iterable = toObject(collection);
        while (length--) {
          if (iteratee(iterable[length], length, iterable) === false) {
            break;
          }
        }
        return collection;
      }

      /**
       * The base implementation of `_.every` without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function(value, index, collection) {
          result = !!predicate(value, index, collection);
          return result;
        });
        return result;
      }

      /**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */
      function baseFill(array, value, start, end) {
        var length = array.length;

        start = start == null ? 0 : (+start || 0);
        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : (end >>> 0);
        start >>>= 0;

        while (start < length) {
          array[start++] = value;
        }
        return array;
      }

      /**
       * The base implementation of `_.filter` without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection) {
          if (predicate(value, index, collection)) {
            result.push(value);
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
       * without support for callback shorthands and `this` binding, which iterates
       * over `collection` using the provided `eachFunc`.
       *
       * @private
       * @param {Array|Object|string} collection The collection to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @param {boolean} [retKey] Specify returning the key of the found element
       *  instead of the element itself.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = retKey ? key : value;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.flatten` with added support for restricting
       * flattening and specifying the start index.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {boolean} isDeep Specify a deep flatten.
       * @param {boolean} isStrict Restrict flattening to arrays and `arguments` objects.
       * @param {number} fromIndex The index to start from.
       * @returns {Array} Returns the new flattened array.
       */
      function baseFlatten(array, isDeep, isStrict, fromIndex) {
        var index = fromIndex - 1,
            length = array.length,
            resIndex = -1,
            result = [];

        while (++index < length) {
          var value = array[index];

          if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
            if (isDeep) {
              // Recursively flatten arrays (susceptible to call stack limits).
              value = baseFlatten(value, isDeep, isStrict, 0);
            }
            var valIndex = -1,
                valLength = value.length;

            result.length += valLength;
            while (++valIndex < valLength) {
              result[++resIndex] = value[valIndex];
            }
          } else if (!isStrict) {
            result[++resIndex] = value;
          }
        }
        return result;
      }

      /**
       * The base implementation of `baseForIn` and `baseForOwn` which iterates
       * over `object` properties returned by `keysFunc` invoking `iteratee` for
       * each property. Iterator functions may exit iteration early by explicitly
       * returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */
      function baseFor(object, iteratee, keysFunc) {
        var index = -1,
            iterable = toObject(object),
            props = keysFunc(object),
            length = props.length;

        while (++index < length) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      }

      /**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */
      function baseForRight(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[length];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      }

      /**
       * The base implementation of `_.forIn` without support for callback
       * shorthands and `this` binding.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForIn(object, iteratee) {
        return baseFor(object, iteratee, keysIn);
      }

      /**
       * The base implementation of `_.forOwn` without support for callback
       * shorthands and `this` binding.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForOwn(object, iteratee) {
        return baseFor(object, iteratee, keys);
      }

      /**
       * The base implementation of `_.forOwnRight` without support for callback
       * shorthands and `this` binding.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForOwnRight(object, iteratee) {
        return baseForRight(object, iteratee, keys);
      }

      /**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from those provided.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the new array of filtered property names.
       */
      function baseFunctions(object, props) {
        var index = -1,
            length = props.length,
            resIndex = -1,
            result = [];

        while (++index < length) {
          var key = props[index];
          if (isFunction(object[key])) {
            result[++resIndex] = key;
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.invoke` which requires additional arguments
       * to be provided as an array of arguments rather than individually.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|string} methodName The name of the method to invoke or
       *  the function invoked per iteration.
       * @param {Array} [args] The arguments to invoke the method with.
       * @returns {Array} Returns the array of results.
       */
      function baseInvoke(collection, methodName, args) {
        var index = -1,
            isFunc = typeof methodName == 'function',
            length = collection ? collection.length : 0,
            result = isLength(length) ? Array(length) : [];

        baseEach(collection, function(value) {
          var func = isFunc ? methodName : (value != null && value[methodName]);
          result[++index] = func ? func.apply(value, args) : undefined;
        });
        return result;
      }

      /**
       * The base implementation of `_.isEqual` without support for `this` binding
       * `customizer` functions.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparing values.
       * @param {boolean} [isWhere] Specify performing partial comparisons.
       * @param {Array} [stackA] Tracks traversed `value` objects.
       * @param {Array} [stackB] Tracks traversed `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */
      function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
        // Exit early for identical values.
        if (value === other) {
          // Treat `+0` vs. `-0` as not equal.
          return value !== 0 || (1 / value == 1 / other);
        }
        var valType = typeof value,
            othType = typeof other;

        // Exit early for unlike primitive values.
        if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
            value == null || other == null) {
          // Return `false` unless both values are `NaN`.
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
      }

      /**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Function} [customizer] The function to customize comparing objects.
       * @param {boolean} [isWhere] Specify performing partial comparisons.
       * @param {Array} [stackA=[]] Tracks traversed `value` objects.
       * @param {Array} [stackB=[]] Tracks traversed `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = arrayTag,
            othTag = arrayTag;

        if (!objIsArr) {
          objTag = objToString.call(object);
          if (objTag == argsTag) {
            objTag = objectTag;
          } else if (objTag != objectTag) {
            objIsArr = isTypedArray(object);
          }
        }
        if (!othIsArr) {
          othTag = objToString.call(other);
          if (othTag == argsTag) {
            othTag = objectTag;
          } else if (othTag != objectTag) {
            othIsArr = isTypedArray(other);
          }
        }
        var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

        if (isSameTag && !(objIsArr || objIsObj)) {
          return equalByTag(object, other, objTag);
        }
        var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (valWrapped || othWrapped) {
          return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
        }
        if (!isSameTag) {
          return false;
        }
        // Assume cyclic values are equal.
        // For more information on detecting circular references see https://es5.github.io/#JO.
        stackA || (stackA = []);
        stackB || (stackB = []);

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == object) {
            return stackB[length] == other;
          }
        }
        // Add `object` and `other` to the stack of traversed objects.
        stackA.push(object);
        stackB.push(other);

        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

        stackA.pop();
        stackB.pop();

        return result;
      }

      /**
       * The base implementation of `_.isMatch` without support for callback
       * shorthands or `this` binding.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The source property names to match.
       * @param {Array} values The source values to match.
       * @param {Array} strictCompareFlags Strict comparison flags for source values.
       * @param {Function} [customizer] The function to customize comparing objects.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */
      function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        var index = -1,
            noCustomizer = !customizer;

        while (++index < length) {
          if ((noCustomizer && strictCompareFlags[index])
                ? values[index] !== object[props[index]]
                : !hasOwnProperty.call(object, props[index])
              ) {
            return false;
          }
        }
        index = -1;
        while (++index < length) {
          var key = props[index];
          if (noCustomizer && strictCompareFlags[index]) {
            var result = hasOwnProperty.call(object, key);
          } else {
            var objValue = object[key],
                srcValue = values[index];

            result = customizer ? customizer(objValue, srcValue, key) : undefined;
            if (typeof result == 'undefined') {
              result = baseIsEqual(srcValue, objValue, customizer, true);
            }
          }
          if (!result) {
            return false;
          }
        }
        return true;
      }

      /**
       * The base implementation of `_.map` without support for callback shorthands
       * or `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function baseMap(collection, iteratee) {
        var result = [];
        baseEach(collection, function(value, key, collection) {
          result.push(iteratee(value, key, collection));
        });
        return result;
      }

      /**
       * The base implementation of `_.matches` which does not clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new function.
       */
      function baseMatches(source) {
        var props = keys(source),
            length = props.length;

        if (length == 1) {
          var key = props[0],
              value = source[key];

          if (isStrictComparable(value)) {
            return function(object) {
              return object != null && object[key] === value && hasOwnProperty.call(object, key);
            };
          }
        }
        var values = Array(length),
            strictCompareFlags = Array(length);

        while (length--) {
          value = source[props[length]];
          values[length] = value;
          strictCompareFlags[length] = isStrictComparable(value);
        }
        return function(object) {
          return baseIsMatch(object, props, values, strictCompareFlags);
        };
      }

      /**
       * The base implementation of `_.matchesProperty` which does not coerce `key`
       * to a string.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} value The value to compare.
       * @returns {Function} Returns the new function.
       */
      function baseMatchesProperty(key, value) {
        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value;
          };
        }
        return function(object) {
          return object != null && baseIsEqual(value, object[key], null, true);
        };
      }

      /**
       * The base implementation of `_.merge` without support for argument juggling,
       * multiple sources, and `this` binding `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {Function} [customizer] The function to customize merging properties.
       * @param {Array} [stackA=[]] Tracks traversed source objects.
       * @param {Array} [stackB=[]] Associates values with source counterparts.
       * @returns {Object} Returns the destination object.
       */
      function baseMerge(object, source, customizer, stackA, stackB) {
        if (!isObject(object)) {
          return object;
        }
        var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
        (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
          if (isObjectLike(srcValue)) {
            stackA || (stackA = []);
            stackB || (stackB = []);
            return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = typeof result == 'undefined';

          if (isCommon) {
            result = srcValue;
          }
          if ((isSrcArr || typeof result != 'undefined') &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        });
        return object;
      }

      /**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize merging properties.
       * @param {Array} [stackA=[]] Tracks traversed source objects.
       * @param {Array} [stackB=[]] Associates values with source counterparts.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
        var length = stackA.length,
            srcValue = source[key];

        while (length--) {
          if (stackA[length] == srcValue) {
            object[key] = stackB[length];
            return;
          }
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
          if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
            result = isArray(value)
              ? value
              : (value ? arrayCopy(value) : []);
          }
          else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            result = isArguments(value)
              ? toPlainObject(value)
              : (isPlainObject(value) ? value : {});
          }
          else {
            isCommon = false;
          }
        }
        // Add the source value to the stack of traversed objects and associate
        // it with its merged value.
        stackA.push(srcValue);
        stackB.push(result);

        if (isCommon) {
          // Recursively merge objects and arrays (susceptible to call stack limits).
          object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
        } else if (result === result ? (result !== value) : (value === value)) {
          object[key] = result;
        }
      }

      /**
       * The base implementation of `_.property` which does not coerce `key` to a string.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * The base implementation of `_.pullAt` without support for individual
       * index arguments.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       */
      function basePullAt(array, indexes) {
        var length = indexes.length,
            result = baseAt(array, indexes);

        indexes.sort(baseCompareAscending);
        while (length--) {
          var index = parseFloat(indexes[length]);
          if (index != previous && isIndex(index)) {
            var previous = index;
            splice.call(array, index, 1);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.random` without support for argument juggling
       * and returning floating-point numbers.
       *
       * @private
       * @param {number} min The minimum possible value.
       * @param {number} max The maximum possible value.
       * @returns {number} Returns the random number.
       */
      function baseRandom(min, max) {
        return min + floor(nativeRandom() * (max - min + 1));
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight` without support
       * for callback shorthands or `this` binding, which iterates over `collection`
       * using the provided `eachFunc`.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initFromCollection Specify using the first or last element
       *  of `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initFromCollection
            ? (initFromCollection = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `setData` without support for hot loop detection.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };

      /**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */
      function baseSlice(array, start, end) {
        var index = -1,
            length = array.length;

        start = start == null ? 0 : (+start || 0);
        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : ((end - start) >>> 0);
        start >>>= 0;

        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }

      /**
       * The base implementation of `_.some` without support for callback shorthands
       * or `this` binding.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function baseSome(collection, predicate) {
        var result;

        baseEach(collection, function(value, index, collection) {
          result = predicate(value, index, collection);
          return !result;
        });
        return !!result;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define
       * the sort order of `array` and replaces criteria objects with their
       * corresponding values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sortByOrder` without param guards.
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {string[]} props The property names to sort by.
       * @param {boolean[]} orders The sort orders of `props`.
       * @returns {Array} Returns the new sorted array.
       */
      function baseSortByOrder(collection, props, orders) {
        var index = -1,
            length = collection.length,
            result = isLength(length) ? Array(length) : [];

        baseEach(collection, function(value) {
          var length = props.length,
              criteria = Array(length);

          while (length--) {
            criteria[length] = value == null ? undefined : value[props[length]];
          }
          result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
        });

        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }

      /**
       * The base implementation of `_.uniq` without support for callback shorthands
       * and `this` binding.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The function invoked per iteration.
       * @returns {Array} Returns the new duplicate-value-free array.
       */
      function baseUniq(array, iteratee) {
        var index = -1,
            indexOf = getIndexOf(),
            length = array.length,
            isCommon = indexOf == baseIndexOf,
            isLarge = isCommon && length >= 200,
            seen = isLarge ? createCache() : null,
            result = [];

        if (seen) {
          indexOf = cacheIndexOf;
          isCommon = false;
        } else {
          isLarge = false;
          seen = iteratee ? [] : result;
        }
        outer:
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;

          if (isCommon && value === value) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          }
          else if (indexOf(seen, computed, 0) < 0) {
            if (iteratee || isLarge) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * returned by `keysFunc`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        var index = -1,
            length = props.length,
            result = Array(length);

        while (++index < length) {
          result[index] = object[props[index]];
        }
        return result;
      }

      /**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to peform to resolve the unwrapped value.
       * @returns {*} Returns the resolved unwrapped value.
       */
      function baseWrapperValue(value, actions) {
        var result = value;
        if (result instanceof LazyWrapper) {
          result = result.value();
        }
        var index = -1,
            length = actions.length;

        while (++index < length) {
          var args = [result],
              action = actions[index];

          push.apply(args, action.args);
          result = action.func.apply(action.thisArg, args);
        }
        return result;
      }

      /**
       * Performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest, instead
       *  of the lowest, index at which a value should be inserted into `array`.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */
      function binaryIndex(array, value, retHighest) {
        var low = 0,
            high = array ? array.length : low;

        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = (low + high) >>> 1,
                computed = array[mid];

            if (retHighest ? (computed <= value) : (computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return binaryIndexBy(array, value, identity, retHighest);
      }

      /**
       * This function is like `binaryIndex` except that it invokes `iteratee` for
       * `value` and each element of `array` to compute their sort ranking. The
       * iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {boolean} [retHighest] Specify returning the highest, instead
       *  of the lowest, index at which a value should be inserted into `array`.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */
      function binaryIndexBy(array, value, iteratee, retHighest) {
        value = iteratee(value);

        var low = 0,
            high = array ? array.length : 0,
            valIsNaN = value !== value,
            valIsUndef = typeof value == 'undefined';

        while (low < high) {
          var mid = floor((low + high) / 2),
              computed = iteratee(array[mid]),
              isReflexive = computed === computed;

          if (valIsNaN) {
            var setLow = isReflexive || retHighest;
          } else if (valIsUndef) {
            setLow = isReflexive && (retHighest || typeof computed != 'undefined');
          } else {
            setLow = retHighest ? (computed <= value) : (computed < value);
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }

      /**
       * A specialized version of `baseCallback` which only supports `this` binding
       * and specifying the number of arguments to provide to `func`.
       *
       * @private
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {number} [argCount] The number of arguments to provide to `func`.
       * @returns {Function} Returns the callback.
       */
      function bindCallback(func, thisArg, argCount) {
        if (typeof func != 'function') {
          return identity;
        }
        if (typeof thisArg == 'undefined') {
          return func;
        }
        switch (argCount) {
          case 1: return function(value) {
            return func.call(thisArg, value);
          };
          case 3: return function(value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };
          case 4: return function(accumulator, value, index, collection) {
            return func.call(thisArg, accumulator, value, index, collection);
          };
          case 5: return function(value, other, key, object, source) {
            return func.call(thisArg, value, other, key, object, source);
          };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      }

      /**
       * Creates a clone of the given array buffer.
       *
       * @private
       * @param {ArrayBuffer} buffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */
      function bufferClone(buffer) {
        return bufferSlice.call(buffer, 0);
      }
      if (!bufferSlice) {
        // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
        bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
          var byteLength = buffer.byteLength,
              floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
              offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
              result = new ArrayBuffer(byteLength);

          if (floatLength) {
            var view = new Float64Array(result, 0, floatLength);
            view.set(new Float64Array(buffer, 0, floatLength));
          }
          if (byteLength != offset) {
            view = new Uint8Array(result, offset);
            view.set(new Uint8Array(buffer, offset));
          }
          return result;
        };
      }

      /**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array|Object} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @returns {Array} Returns the new array of composed arguments.
       */
      function composeArgs(args, partials, holders) {
        var holdersLength = holders.length,
            argsIndex = -1,
            argsLength = nativeMax(args.length - holdersLength, 0),
            leftIndex = -1,
            leftLength = partials.length,
            result = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          result[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
        while (argsLength--) {
          result[leftIndex++] = args[argsIndex++];
        }
        return result;
      }

      /**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array|Object} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @returns {Array} Returns the new array of composed arguments.
       */
      function composeArgsRight(args, partials, holders) {
        var holdersIndex = -1,
            holdersLength = holders.length,
            argsIndex = -1,
            argsLength = nativeMax(args.length - holdersLength, 0),
            rightIndex = -1,
            rightLength = partials.length,
            result = Array(argsLength + rightLength);

        while (++argsIndex < argsLength) {
          result[argsIndex] = args[argsIndex];
        }
        var pad = argsIndex;
        while (++rightIndex < rightLength) {
          result[pad + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          result[pad + holders[holdersIndex]] = args[argsIndex++];
        }
        return result;
      }

      /**
       * Creates a function that aggregates a collection, creating an accumulator
       * object composed from the results of running each element in the collection
       * through an iteratee.
       *
       * @private
       * @param {Function} setter The function to set keys and values of the accumulator object.
       * @param {Function} [initializer] The function to initialize the accumulator object.
       * @returns {Function} Returns the new aggregator function.
       */
      function createAggregator(setter, initializer) {
        return function(collection, iteratee, thisArg) {
          var result = initializer ? initializer() : {};
          iteratee = getCallback(iteratee, thisArg, 3);

          if (isArray(collection)) {
            var index = -1,
                length = collection.length;

            while (++index < length) {
              var value = collection[index];
              setter(result, value, iteratee(value, index, collection), collection);
            }
          } else {
            baseEach(collection, function(value, key, collection) {
              setter(result, value, iteratee(value, key, collection), collection);
            });
          }
          return result;
        };
      }

      /**
       * Creates a function that assigns properties of source object(s) to a given
       * destination object.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */
      function createAssigner(assigner) {
        return function() {
          var args = arguments,
              length = args.length,
              object = args[0];

          if (length < 2 || object == null) {
            return object;
          }
          var customizer = args[length - 2],
              thisArg = args[length - 1],
              guard = args[3];

          if (length > 3 && typeof customizer == 'function') {
            customizer = bindCallback(customizer, thisArg, 5);
            length -= 2;
          } else {
            customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
            length -= (customizer ? 1 : 0);
          }
          if (guard && isIterateeCall(args[1], args[2], guard)) {
            customizer = length == 3 ? null : customizer;
            length = 2;
          }
          var index = 0;
          while (++index < length) {
            var source = args[index];
            if (source) {
              assigner(object, source, customizer);
            }
          }
          return object;
        };
      }

      /**
       * Creates a function that wraps `func` and invokes it with the `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to bind.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new bound function.
       */
      function createBindWrapper(func, thisArg) {
        var Ctor = createCtorWrapper(func);

        function wrapper() {
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return fn.apply(thisArg, arguments);
        }
        return wrapper;
      }

      /**
       * Creates a `Set` cache object to optimize linear searches of large arrays.
       *
       * @private
       * @param {Array} [values] The values to cache.
       * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
       */
      var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
        return new SetCache(values);
      };

      /**
       * Creates a function to compose other functions into a single function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new composer function.
       */
      function createComposer(fromRight) {
        return function() {
          var length = arguments.length,
              index = length,
              fromIndex = fromRight ? (length - 1) : 0;

          if (!length) {
            return function() { return arguments[0]; };
          }
          var funcs = Array(length);
          while (index--) {
            funcs[index] = arguments[index];
            if (typeof funcs[index] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            var index = fromIndex,
                result = funcs[index].apply(this, arguments);

            while ((fromRight ? index-- : ++index < length)) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        };
      }

      /**
       * Creates a function that produces compound words out of the words in a
       * given string.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */
      function createCompounder(callback) {
        return function(string) {
          var index = -1,
              array = words(deburr(string)),
              length = array.length,
              result = '';

          while (++index < length) {
            result = callback(result, array[index], index);
          }
          return result;
        };
      }

      /**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */
      function createCtorWrapper(Ctor) {
        return function() {
          var thisBinding = baseCreate(Ctor.prototype),
              result = Ctor.apply(thisBinding, arguments);

          // Mimic the constructor's `return` behavior.
          // See https://es5.github.io/#x13.2.2 for more details.
          return isObject(result) ? result : thisBinding;
        };
      }

      /**
       * Creates a function that gets the extremum value of a collection.
       *
       * @private
       * @param {Function} arrayFunc The function to get the extremum value from an array.
       * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
       *  extremum value.
       * @returns {Function} Returns the new extremum function.
       */
      function createExtremum(arrayFunc, isMin) {
        return function(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          var func = getCallback(),
              noIteratee = iteratee == null;

          if (!(func === baseCallback && noIteratee)) {
            noIteratee = false;
            iteratee = func(iteratee, thisArg, 3);
          }
          if (noIteratee) {
            var isArr = isArray(collection);
            if (!isArr && isString(collection)) {
              iteratee = charAtCallback;
            } else {
              return arrayFunc(isArr ? collection : toIterable(collection));
            }
          }
          return extremumBy(collection, iteratee, isMin);
        };
      }

      /**
       * Creates a function that wraps `func` and invokes it with optional `this`
       * binding of, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to reference.
       * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
        var isAry = bitmask & ARY_FLAG,
            isBind = bitmask & BIND_FLAG,
            isBindKey = bitmask & BIND_KEY_FLAG,
            isCurry = bitmask & CURRY_FLAG,
            isCurryBound = bitmask & CURRY_BOUND_FLAG,
            isCurryRight = bitmask & CURRY_RIGHT_FLAG;

        var Ctor = !isBindKey && createCtorWrapper(func),
            key = func;

        function wrapper() {
          // Avoid `arguments` object use disqualifying optimizations by
          // converting it to an array before providing it to other functions.
          var length = arguments.length,
              index = length,
              args = Array(length);

          while (index--) {
            args[index] = arguments[index];
          }
          if (partials) {
            args = composeArgs(args, partials, holders);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight);
          }
          if (isCurry || isCurryRight) {
            var placeholder = wrapper.placeholder,
                argsHolders = replaceHolders(args, placeholder);

            length -= argsHolders.length;
            if (length < arity) {
              var newArgPos = argPos ? arrayCopy(argPos) : null,
                  newArity = nativeMax(arity - length, 0),
                  newsHolders = isCurry ? argsHolders : null,
                  newHoldersRight = isCurry ? null : argsHolders,
                  newPartials = isCurry ? args : null,
                  newPartialsRight = isCurry ? null : args;

              bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
              bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

              if (!isCurryBound) {
                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
              }
              var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
              result.placeholder = placeholder;
              return result;
            }
          }
          var thisBinding = isBind ? thisArg : this;
          if (isBindKey) {
            func = thisBinding[key];
          }
          if (argPos) {
            args = reorder(args, argPos);
          }
          if (isAry && ary < args.length) {
            args.length = ary;
          }
          var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }

      /**
       * Creates the pad required for `string` based on the given padding length.
       * The `chars` string may be truncated if the number of padding characters
       * exceeds the padding length.
       *
       * @private
       * @param {string} string The string to create padding for.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the pad for `string`.
       */
      function createPad(string, length, chars) {
        var strLength = string.length;
        length = +length;

        if (strLength >= length || !nativeIsFinite(length)) {
          return '';
        }
        var padLength = length - strLength;
        chars = chars == null ? ' ' : (chars + '');
        return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
      }

      /**
       * Creates a function that wraps `func` and invokes it with the optional `this`
       * binding of `thisArg` and the `partials` prepended to those provided to
       * the wrapper.
       *
       * @private
       * @param {Function} func The function to partially apply arguments to.
       * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to the new function.
       * @returns {Function} Returns the new bound function.
       */
      function createPartialWrapper(func, bitmask, thisArg, partials) {
        var isBind = bitmask & BIND_FLAG,
            Ctor = createCtorWrapper(func);

        function wrapper() {
          // Avoid `arguments` object use disqualifying optimizations by
          // converting it to an array before providing it `func`.
          var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array(argsLength + leftLength);

          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, args);
        }
        return wrapper;
      }

      /**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to reference.
       * @param {number} bitmask The bitmask of flags.
       *  The bitmask may be composed of the following flags:
       *     1 - `_.bind`
       *     2 - `_.bindKey`
       *     4 - `_.curry` or `_.curryRight` of a bound function
       *     8 - `_.curry`
       *    16 - `_.curryRight`
       *    32 - `_.partial`
       *    64 - `_.partialRight`
       *   128 - `_.rearg`
       *   256 - `_.ary`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & BIND_KEY_FLAG;
        if (!isBindKey && typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
          partials = holders = null;
        }
        length -= (holders ? holders.length : 0);
        if (bitmask & PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials,
              holdersRight = holders;

          partials = holders = null;
        }
        var data = !isBindKey && getData(func),
            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

        if (data && data !== true) {
          mergeData(newData, data);
          bitmask = newData[1];
          arity = newData[9];
        }
        newData[9] = arity == null
          ? (isBindKey ? 0 : func.length)
          : (nativeMax(arity - length, 0) || 0);

        if (bitmask == BIND_FLAG) {
          var result = createBindWrapper(newData[0], newData[2]);
        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
          result = createPartialWrapper.apply(undefined, newData);
        } else {
          result = createHybridWrapper.apply(undefined, newData);
        }
        var setter = data ? baseSetData : setData;
        return setter(result, newData);
      }

      /**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Function} [customizer] The function to customize comparing arrays.
       * @param {boolean} [isWhere] Specify performing partial comparisons.
       * @param {Array} [stackA] Tracks traversed `value` objects.
       * @param {Array} [stackB] Tracks traversed `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */
      function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var index = -1,
            arrLength = array.length,
            othLength = other.length,
            result = true;

        if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
          return false;
        }
        // Deep compare the contents, ignoring non-numeric properties.
        while (result && ++index < arrLength) {
          var arrValue = array[index],
              othValue = other[index];

          result = undefined;
          if (customizer) {
            result = isWhere
              ? customizer(othValue, arrValue, index)
              : customizer(arrValue, othValue, index);
          }
          if (typeof result == 'undefined') {
            // Recursively compare arrays (susceptible to call stack limits).
            if (isWhere) {
              var othIndex = othLength;
              while (othIndex--) {
                othValue = other[othIndex];
                result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                if (result) {
                  break;
                }
              }
            } else {
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
            }
          }
        }
        return !!result;
      }

      /**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} value The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalByTag(object, other, tag) {
        switch (tag) {
          case boolTag:
          case dateTag:
            // Coerce dates and booleans to numbers, dates to milliseconds and booleans
            // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
            return +object == +other;

          case errorTag:
            return object.name == other.name && object.message == other.message;

          case numberTag:
            // Treat `NaN` vs. `NaN` as equal.
            return (object != +object)
              ? other != +other
              // But, treat `-0` vs. `+0` as not equal.
              : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

          case regexpTag:
          case stringTag:
            // Coerce regexes to strings and treat strings primitives and string
            // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
            return object == (other + '');
        }
        return false;
      }

      /**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Function} [customizer] The function to customize comparing values.
       * @param {boolean} [isWhere] Specify performing partial comparisons.
       * @param {Array} [stackA] Tracks traversed `value` objects.
       * @param {Array} [stackB] Tracks traversed `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var objProps = keys(object),
            objLength = objProps.length,
            othProps = keys(other),
            othLength = othProps.length;

        if (objLength != othLength && !isWhere) {
          return false;
        }
        var hasCtor,
            index = -1;

        while (++index < objLength) {
          var key = objProps[index],
              result = hasOwnProperty.call(other, key);

          if (result) {
            var objValue = object[key],
                othValue = other[key];

            result = undefined;
            if (customizer) {
              result = isWhere
                ? customizer(othValue, objValue, key)
                : customizer(objValue, othValue, key);
            }
            if (typeof result == 'undefined') {
              // Recursively compare objects (susceptible to call stack limits).
              result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
            }
          }
          if (!result) {
            return false;
          }
          hasCtor || (hasCtor = key == 'constructor');
        }
        if (!hasCtor) {
          var objCtor = object.constructor,
              othCtor = other.constructor;

          // Non `Object` object instances with different constructors are not equal.
          if (objCtor != othCtor &&
              ('constructor' in object && 'constructor' in other) &&
              !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            return false;
          }
        }
        return true;
      }

      /**
       * Gets the extremum value of `collection` invoking `iteratee` for each value
       * in `collection` to generate the criterion by which the value is ranked.
       * The `iteratee` is invoked with three arguments; (value, index, collection).
       *
       * @private
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {boolean} [isMin] Specify returning the minimum, instead of the
       *  maximum, extremum value.
       * @returns {*} Returns the extremum value.
       */
      function extremumBy(collection, iteratee, isMin) {
        var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
            computed = exValue,
            result = computed;

        baseEach(collection, function(value, index, collection) {
          var current = iteratee(value, index, collection);
          if ((isMin ? (current < computed) : (current > computed)) ||
              (current === exValue && current === result)) {
            computed = current;
            result = value;
          }
        });
        return result;
      }

      /**
       * Gets the appropriate "callback" function. If the `_.callback` method is
       * customized this function returns the custom method, otherwise it returns
       * the `baseCallback` function. If arguments are provided the chosen function
       * is invoked with them and its result is returned.
       *
       * @private
       * @returns {Function} Returns the chosen function or its result.
       */
      function getCallback(func, thisArg, argCount) {
        var result = lodash.callback || callback;
        result = result === callback ? baseCallback : result;
        return argCount ? result(func, thisArg, argCount) : result;
      }

      /**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };

      /**
       * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
       * customized this function returns the custom method, otherwise it returns
       * the `baseIndexOf` function. If arguments are provided the chosen function
       * is invoked with them and its result is returned.
       *
       * @private
       * @returns {Function|number} Returns the chosen function or its result.
       */
      function getIndexOf(collection, target, fromIndex) {
        var result = lodash.indexOf || indexOf;
        result = result === indexOf ? baseIndexOf : result;
        return collection ? result(collection, target, fromIndex) : result;
      }

      /**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} [transforms] The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */
      function getView(start, end, transforms) {
        var index = -1,
            length = transforms ? transforms.length : 0;

        while (++index < length) {
          var data = transforms[index],
              size = data.size;

          switch (data.type) {
            case 'drop':      start += size; break;
            case 'dropRight': end -= size; break;
            case 'take':      end = nativeMin(end, start + size); break;
            case 'takeRight': start = nativeMax(start, end - size); break;
          }
        }
        return { 'start': start, 'end': end };
      }

      /**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */
      function initCloneArray(array) {
        var length = array.length,
            result = new array.constructor(length);

        // Add array properties assigned by `RegExp#exec`.
        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }

      /**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneObject(object) {
        var Ctor = object.constructor;
        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
          Ctor = Object;
        }
        return new Ctor;
      }

      /**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return bufferClone(object);

          case boolTag:
          case dateTag:
            return new Ctor(+object);

          case float32Tag: case float64Tag:
          case int8Tag: case int16Tag: case int32Tag:
          case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
            var buffer = object.buffer;
            return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

          case numberTag:
          case stringTag:
            return new Ctor(object);

          case regexpTag:
            var result = new Ctor(object.source, reFlags.exec(object));
            result.lastIndex = object.lastIndex;
        }
        return result;
      }

      /**
       * Checks if `func` is eligible for `this` binding.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
       */
      function isBindable(func) {
        var support = lodash.support,
            result = !(support.funcNames ? func.name : support.funcDecomp);

        if (!result) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            result = !reFuncName.test(source);
          }
          if (!result) {
            // Check if `func` references the `this` keyword and store the result.
            result = reThis.test(source) || isNative(func);
            baseSetData(func, result);
          }
        }
        return result;
      }

      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */
      function isIndex(value, length) {
        value = +value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
      }

      /**
       * Checks if the provided arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
       */
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == 'number') {
          var length = object.length,
              prereq = isLength(length) && isIndex(index, length);
        } else {
          prereq = type == 'string' && index in object;
        }
        if (prereq) {
          var other = object[index];
          return value === value ? (value === other) : (other !== other);
        }
        return false;
      }

      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This function is based on ES `ToLength`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
       * for more details.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       */
      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

      /**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */
      function isStrictComparable(value) {
        return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
      }

      /**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers required to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
       * augment function arguments, making the order in which they are executed important,
       * preventing the merging of metadata. However, we make an exception for a safe
       * common case where curried functions have `_.ary` and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */
      function mergeData(data, source) {
        var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask;

        var arityFlags = ARY_FLAG | REARG_FLAG,
            bindFlags = BIND_FLAG | BIND_KEY_FLAG,
            comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

        var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
            isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
            argPos = (isRearg ? data : source)[7],
            ary = (isAry ? data : source)[8];

        var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
          !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

        var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
          (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

        // Exit early if metadata can't be merged.
        if (!(isCommon || isCombo)) {
          return data;
        }
        // Use source `thisArg` if available.
        if (srcBitmask & BIND_FLAG) {
          data[2] = source[2];
          // Set when currying a bound function.
          newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
        }
        // Compose partial arguments.
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
        }
        // Compose partial right arguments.
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
        }
        // Use source `argPos` if available.
        value = source[7];
        if (value) {
          data[7] = arrayCopy(value);
        }
        // Use source `ary` if it's smaller.
        if (srcBitmask & ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        // Use source `arity` if one is not provided.
        if (data[9] == null) {
          data[9] = source[9];
        }
        // Use source `func` and merge bitmasks.
        data[0] = source[0];
        data[1] = newBitmask;

        return data;
      }

      /**
       * A specialized version of `_.pick` that picks `object` properties specified
       * by the `props` array.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} props The property names to pick.
       * @returns {Object} Returns the new object.
       */
      function pickByArray(object, props) {
        object = toObject(object);

        var index = -1,
            length = props.length,
            result = {};

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.pick` that picks `object` properties `predicate`
       * returns truthy for.
       *
       * @private
       * @param {Object} object The source object.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Object} Returns the new object.
       */
      function pickByCallback(object, predicate) {
        var result = {};
        baseForIn(object, function(value, key, object) {
          if (predicate(value, key, object)) {
            result[key] = value;
          }
        });
        return result;
      }

      /**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */
      function reorder(array, indexes) {
        var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = arrayCopy(array);

        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
        }
        return array;
      }

      /**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity function
       * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */
      var setData = (function() {
        var count = 0,
            lastCalled = 0;

        return function(key, value) {
          var stamp = now(),
              remaining = HOT_SPAN - (stamp - lastCalled);

          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return key;
            }
          } else {
            count = 0;
          }
          return baseSetData(key, value);
        };
      }());

      /**
       * A fallback implementation of `_.isPlainObject` which checks if `value`
       * is an object created by the `Object` constructor or has a `[[Prototype]]`
       * of `null`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       */
      function shimIsPlainObject(value) {
        var Ctor,
            support = lodash.support;

        // Exit early for non `Object` objects.
        if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
            (!hasOwnProperty.call(value, 'constructor') &&
              (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
          return false;
        }
        // IE < 9 iterates inherited properties before own properties. If the first
        // iterated property is an object's own property then there are no inherited
        // enumerable properties.
        var result;
        // In most environments an object's own properties are iterated before
        // its inherited properties. If the last iterated property is an object's
        // own property then there are no inherited enumerable properties.
        baseForIn(value, function(subValue, key) {
          result = key;
        });
        return typeof result == 'undefined' || hasOwnProperty.call(value, result);
      }

      /**
       * A fallback implementation of `Object.keys` which creates an array of the
       * own enumerable property names of `object`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the array of property names.
       */
      function shimKeys(object) {
        var props = keysIn(object),
            propsLength = props.length,
            length = propsLength && object.length,
            support = lodash.support;

        var allowIndexes = length && isLength(length) &&
          (isArray(object) || (support.nonEnumArgs && isArguments(object)));

        var index = -1,
            result = [];

        while (++index < propsLength) {
          var key = props[index];
          if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * Converts `value` to an array-like object if it is not one.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {Array|Object} Returns the array-like object.
       */
      function toIterable(value) {
        if (value == null) {
          return [];
        }
        if (!isLength(value.length)) {
          return values(value);
        }
        return isObject(value) ? value : Object(value);
      }

      /**
       * Converts `value` to an object if it is not one.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {Object} Returns the object.
       */
      function toObject(value) {
        return isObject(value) ? value : Object(value);
      }

      /**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */
      function wrapperClone(wrapper) {
        return wrapper instanceof LazyWrapper
          ? wrapper.clone()
          : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates an array of elements split into groups the length of `size`.
       * If `collection` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the new array containing chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */
      function chunk(array, size, guard) {
        if (guard ? isIterateeCall(array, size, guard) : size == null) {
          size = 1;
        } else {
          size = nativeMax(+size || 1, 1);
        }
        var index = 0,
            length = array ? array.length : 0,
            resIndex = -1,
            result = Array(ceil(length / size));

        while (index < length) {
          result[++resIndex] = baseSlice(array, index, (index += size));
        }
        return result;
      }

      /**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */
      function compact(array) {
        var index = -1,
            length = array ? array.length : 0,
            resIndex = -1,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value) {
            result[++resIndex] = value;
          }
        }
        return result;
      }

      /**
       * Creates an array excluding all values of the provided arrays using
       * `SameValueZero` for equality comparisons.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The arrays of values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.difference([1, 2, 3], [4, 2]);
       * // => [1, 3]
       */
      function difference() {
        var args = arguments,
            index = -1,
            length = args.length;

        while (++index < length) {
          var value = args[index];
          if (isArray(value) || isArguments(value)) {
            break;
          }
        }
        return baseDifference(value, baseFlatten(args, false, true, ++index));
      }

      /**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */
      function drop(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (guard ? isIterateeCall(array, n, guard) : n == null) {
          n = 1;
        }
        return baseSlice(array, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */
      function dropRight(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (guard ? isIterateeCall(array, n, guard) : n == null) {
          n = 1;
        }
        n = length - (+n || 0);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * bound to `thisArg` and invoked with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that match the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRightWhile([1, 2, 3], function(n) {
       *   return n > 1;
       * });
       * // => [1]
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
       * // => ['barney', 'fred']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
       * // => ['barney']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.dropRightWhile(users, 'active'), 'user');
       * // => ['barney', 'fred', 'pebbles']
       */
      function dropRightWhile(array, predicate, thisArg) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        predicate = getCallback(predicate, thisArg, 3);
        while (length-- && predicate(array[length], length, array)) {}
        return baseSlice(array, 0, length + 1);
      }

      /**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * bound to `thisArg` and invoked with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropWhile([1, 2, 3], function(n) {
       *   return n < 3;
       * });
       * // => [3]
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
       * // => ['fred', 'pebbles']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.dropWhile(users, 'active', false), 'user');
       * // => ['pebbles']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.dropWhile(users, 'active'), 'user');
       * // => ['barney', 'fred', 'pebbles']
       */
      function dropWhile(array, predicate, thisArg) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        var index = -1;
        predicate = getCallback(predicate, thisArg, 3);
        while (++index < length && predicate(array[index], index, array)) {}
        return baseSlice(array, index);
      }

      /**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */
      function fill(array, value, start, end) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }

      /**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for, instead of the element itself.
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(chr) {
       *   return chr.user == 'barney';
       * });
       * // => 0
       *
       * // using the `_.matches` callback shorthand
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.findIndex(users, 'active', false);
       * // => 0
       *
       * // using the `_.property` callback shorthand
       * _.findIndex(users, 'active');
       * // => 2
       */
      function findIndex(array, predicate, thisArg) {
        var index = -1,
            length = array ? array.length : 0;

        predicate = getCallback(predicate, thisArg, 3);
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(chr) {
       *   return chr.user == 'pebbles';
       * });
       * // => 2
       *
       * // using the `_.matches` callback shorthand
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.findLastIndex(users, 'active', false);
       * // => 2
       *
       * // using the `_.property` callback shorthand
       * _.findLastIndex(users, 'active');
       * // => 0
       */
      function findLastIndex(array, predicate, thisArg) {
        var length = array ? array.length : 0;
        predicate = getCallback(predicate, thisArg, 3);
        while (length--) {
          if (predicate(array[length], length, array)) {
            return length;
          }
        }
        return -1;
      }

      /**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @alias head
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.first([1, 2, 3]);
       * // => 1
       *
       * _.first([]);
       * // => undefined
       */
      function first(array) {
        return array ? array[0] : undefined;
      }

      /**
       * Flattens a nested array. If `isDeep` is `true` the array is recursively
       * flattened, otherwise it is only flattened a single level.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {boolean} [isDeep] Specify a deep flatten.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, 3, [4]]]);
       * // => [1, 2, 3, [4]];
       *
       * // using `isDeep`
       * _.flatten([1, [2, 3, [4]]], true);
       * // => [1, 2, 3, 4];
       */
      function flatten(array, isDeep, guard) {
        var length = array ? array.length : 0;
        if (guard && isIterateeCall(array, isDeep, guard)) {
          isDeep = false;
        }
        return length ? baseFlatten(array, isDeep, false, 0) : [];
      }

      /**
       * Recursively flattens a nested array.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to recursively flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, 3, [4]]]);
       * // => [1, 2, 3, 4];
       */
      function flattenDeep(array) {
        var length = array ? array.length : 0;
        return length ? baseFlatten(array, true, false, 0) : [];
      }

      /**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
       * it is used as the offset from the end of `array`. If `array` is sorted
       * providing `true` for `fromIndex` performs a faster binary search.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {boolean|number} [fromIndex=0] The index to search from or `true`
       *  to perform a binary search on a sorted array.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // using `fromIndex`
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       *
       * // performing a binary search
       * _.indexOf([1, 1, 2, 2], 2, true);
       * // => 2
       */
      function indexOf(array, value, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        if (typeof fromIndex == 'number') {
          fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
        } else if (fromIndex) {
          var index = binaryIndex(array, value),
              other = array[index];

          if (value === value ? (value === other) : (other !== other)) {
            return index;
          }
          return -1;
        }
        return baseIndexOf(array, value, fromIndex || 0);
      }

      /**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */
      function initial(array) {
        return dropRight(array, 1);
      }

      /**
       * Creates an array of unique values in all provided arrays using `SameValueZero`
       * for equality comparisons.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of shared values.
       * @example
       * _.intersection([1, 2], [4, 2], [2, 1]);
       * // => [2]
       */
      function intersection() {
        var args = [],
            argsIndex = -1,
            argsLength = arguments.length,
            caches = [],
            indexOf = getIndexOf(),
            isCommon = indexOf == baseIndexOf;

        while (++argsIndex < argsLength) {
          var value = arguments[argsIndex];
          if (isArray(value) || isArguments(value)) {
            args.push(value);
            caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
          }
        }
        argsLength = args.length;
        var array = args[0],
            index = -1,
            length = array ? array.length : 0,
            result = [],
            seen = caches[0];

        outer:
        while (++index < length) {
          value = array[index];
          if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
            argsIndex = argsLength;
            while (--argsIndex) {
              var cache = caches[argsIndex];
              if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(value);
            }
            result.push(value);
          }
        }
        return result;
      }

      /**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */
      function last(array) {
        var length = array ? array.length : 0;
        return length ? array[length - 1] : undefined;
      }

      /**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {boolean|number} [fromIndex=array.length-1] The index to search from
       *  or `true` to perform a binary search on a sorted array.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // using `fromIndex`
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       *
       * // performing a binary search
       * _.lastIndexOf([1, 1, 2, 2], 2, true);
       * // => 3
       */
      function lastIndexOf(array, value, fromIndex) {
        var length = array ? array.length : 0;
        if (!length) {
          return -1;
        }
        var index = length;
        if (typeof fromIndex == 'number') {
          index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
        } else if (fromIndex) {
          index = binaryIndex(array, value, true) - 1;
          var other = array[index];
          if (value === value ? (value === other) : (other !== other)) {
            return index;
          }
          return -1;
        }
        if (value !== value) {
          return indexOfNaN(array, index, true);
        }
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * Removes all provided values from `array` using `SameValueZero` for equality
       * comparisons.
       *
       * **Notes:**
       *  - Unlike `_.without`, this method mutates `array`.
       *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
       *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       *    for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3, 1, 2, 3];
       *
       * _.pull(array, 2, 3);
       * console.log(array);
       * // => [1, 1]
       */
      function pull() {
        var args = arguments,
            array = args[0];

        if (!(array && array.length)) {
          return array;
        }
        var index = 0,
            indexOf = getIndexOf(),
            length = args.length;

        while (++index < length) {
          var fromIndex = 0,
              value = args[index];

          while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }

      /**
       * Removes elements from `array` corresponding to the given indexes and returns
       * an array of the removed elements. Indexes may be specified as an array of
       * indexes or as individual arguments.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove,
       *  specified as individual indexes or arrays of indexes.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [5, 10, 15, 20];
       * var evens = _.pullAt(array, 1, 3);
       *
       * console.log(array);
       * // => [5, 15]
       *
       * console.log(evens);
       * // => [10, 20]
       */
      function pullAt(array) {
        return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
      }

      /**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is bound to
       * `thisArg` and invoked with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */
      function remove(array, predicate, thisArg) {
        var index = -1,
            length = array ? array.length : 0,
            result = [];

        predicate = getCallback(predicate, thisArg, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result.push(value);
            splice.call(array, index--, 1);
            length--;
          }
        }
        return result;
      }

      /**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @alias tail
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.rest([1, 2, 3]);
       * // => [2, 3]
       */
      function rest(array) {
        return drop(array, 1);
      }

      /**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This function is used instead of `Array#slice` to support node
       * lists in IE < 9 and to ensure dense arrays are returned.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */
      function slice(array, start, end) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        }
        return baseSlice(array, start, end);
      }

      /**
       * Uses a binary search to determine the lowest index at which `value` should
       * be inserted into `array` in order to maintain its sort order. If an iteratee
       * function is provided it is invoked for `value` and each element of `array`
       * to compute their sort ranking. The iteratee is bound to `thisArg` and
       * invoked with one argument; (value).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       *
       * _.sortedIndex([4, 4, 5, 5], 5);
       * // => 2
       *
       * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
       *
       * // using an iteratee function
       * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
       *   return this.data[word];
       * }, dict);
       * // => 1
       *
       * // using the `_.property` callback shorthand
       * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
       * // => 1
       */
      function sortedIndex(array, value, iteratee, thisArg) {
        var func = getCallback(iteratee);
        return (func === baseCallback && iteratee == null)
          ? binaryIndex(array, value)
          : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
      }

      /**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 4, 5, 5], 5);
       * // => 4
       */
      function sortedLastIndex(array, value, iteratee, thisArg) {
        var func = getCallback(iteratee);
        return (func === baseCallback && iteratee == null)
          ? binaryIndex(array, value, true)
          : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
      }

      /**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */
      function take(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (guard ? isIterateeCall(array, n, guard) : n == null) {
          n = 1;
        }
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */
      function takeRight(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (guard ? isIterateeCall(array, n, guard) : n == null) {
          n = 1;
        }
        n = length - (+n || 0);
        return baseSlice(array, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
       * and invoked with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRightWhile([1, 2, 3], function(n) {
       *   return n > 1;
       * });
       * // => [2, 3]
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
       * // => ['pebbles']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
       * // => ['fred', 'pebbles']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.takeRightWhile(users, 'active'), 'user');
       * // => []
       */
      function takeRightWhile(array, predicate, thisArg) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        predicate = getCallback(predicate, thisArg, 3);
        while (length-- && predicate(array[length], length, array)) {}
        return baseSlice(array, length + 1);
      }

      /**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is bound to
       * `thisArg` and invoked with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeWhile([1, 2, 3], function(n) {
       *   return n < 3;
       * });
       * // => [1, 2]
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false},
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
       * // => ['barney']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.takeWhile(users, 'active', false), 'user');
       * // => ['barney', 'fred']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.takeWhile(users, 'active'), 'user');
       * // => []
       */
      function takeWhile(array, predicate, thisArg) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        var index = -1;
        predicate = getCallback(predicate, thisArg, 3);
        while (++index < length && predicate(array[index], index, array)) {}
        return baseSlice(array, 0, index);
      }

      /**
       * Creates an array of unique values, in order, of the provided arrays using
       * `SameValueZero` for equality comparisons.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([1, 2], [4, 2], [2, 1]);
       * // => [1, 2, 4]
       */
      function union() {
        return baseUniq(baseFlatten(arguments, false, true, 0));
      }

      /**
       * Creates a duplicate-value-free version of an array using `SameValueZero`
       * for equality comparisons. Providing `true` for `isSorted` performs a faster
       * search algorithm for sorted arrays. If an iteratee function is provided it
       * is invoked for each value in the array to generate the criterion by which
       * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
       * with three arguments; (value, index, array).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @alias unique
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {boolean} [isSorted] Specify the array is sorted.
       * @param {Function|Object|string} [iteratee] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array} Returns the new duplicate-value-free array.
       * @example
       *
       * _.uniq([1, 2, 1]);
       * // => [1, 2]
       *
       * // using `isSorted`
       * _.uniq([1, 1, 2], true);
       * // => [1, 2]
       *
       * // using an iteratee function
       * _.uniq([1, 2.5, 1.5, 2], function(n) {
       *   return this.floor(n);
       * }, Math);
       * // => [1, 2.5]
       *
       * // using the `_.property` callback shorthand
       * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */
      function uniq(array, isSorted, iteratee, thisArg) {
        var length = array ? array.length : 0;
        if (!length) {
          return [];
        }
        if (isSorted != null && typeof isSorted != 'boolean') {
          thisArg = iteratee;
          iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
          isSorted = false;
        }
        var func = getCallback();
        if (!(func === baseCallback && iteratee == null)) {
          iteratee = func(iteratee, thisArg, 3);
        }
        return (isSorted && getIndexOf() == baseIndexOf)
          ? sortedUniq(array, iteratee)
          : baseUniq(array, iteratee);
      }

      /**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-`_.zip`
       * configuration.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
       * // => [['fred', 30, true], ['barney', 40, false]]
       *
       * _.unzip(zipped);
       * // => [['fred', 'barney'], [30, 40], [true, false]]
       */
      function unzip(array) {
        var index = -1,
            length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
            result = Array(length);

        while (++index < length) {
          result[index] = arrayMap(array, baseProperty(index));
        }
        return result;
      }

      /**
       * Creates an array excluding all provided values using `SameValueZero` for
       * equality comparisons.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {Array} array The array to filter.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.without([1, 2, 1, 3], 1, 2);
       * // => [3]
       */
      function without(array) {
        return baseDifference(array, baseSlice(arguments, 1));
      }

      /**
       * Creates an array that is the symmetric difference of the provided arrays.
       * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
       * more details.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of values.
       * @example
       *
       * _.xor([1, 2], [4, 2]);
       * // => [1, 4]
       */
      function xor() {
        var index = -1,
            length = arguments.length;

        while (++index < length) {
          var array = arguments[index];
          if (isArray(array) || isArguments(array)) {
            var result = result
              ? baseDifference(result, array).concat(baseDifference(array, result))
              : array;
          }
        }
        return result ? baseUniq(result) : [];
      }

      /**
       * Creates an array of grouped elements, the first of which contains the first
       * elements of the given arrays, the second of which contains the second elements
       * of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['fred', 'barney'], [30, 40], [true, false]);
       * // => [['fred', 30, true], ['barney', 40, false]]
       */
      function zip() {
        var length = arguments.length,
            array = Array(length);

        while (length--) {
          array[length] = arguments[length];
        }
        return unzip(array);
      }

      /**
       * Creates an object composed from arrays of property names and values. Provide
       * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
       * or two arrays, one of property names and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @alias object
       * @category Array
       * @param {Array} props The property names.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['fred', 'barney'], [30, 40]);
       * // => { 'fred': 30, 'barney': 40 }
       */
      function zipObject(props, values) {
        var index = -1,
            length = props ? props.length : 0,
            result = {};

        if (length && !values && !isArray(props[0])) {
          values = [];
        }
        while (++index < length) {
          var key = props[index];
          if (values) {
            result[key] = values[index];
          } else if (key) {
            result[key[0]] = key[1];
          }
        }
        return result;
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates a `lodash` object that wraps `value` with explicit method
       * chaining enabled.
       *
       * @static
       * @memberOf _
       * @category Chain
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _.chain(users)
       *   .sortBy('age')
       *   .map(function(chr) {
       *     return chr.user + ' is ' + chr.age;
       *   })
       *   .first()
       *   .value();
       * // => 'pebbles is 1'
       */
      function chain(value) {
        var result = lodash(value);
        result.__chain__ = true;
        return result;
      }

      /**
       * This method invokes `interceptor` and returns `value`. The interceptor is
       * bound to `thisArg` and invoked with one argument; (value). The purpose of
       * this method is to "tap into" a method chain in order to perform operations
       * on intermediate results within the chain.
       *
       * @static
       * @memberOf _
       * @category Chain
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @param {*} [thisArg] The `this` binding of `interceptor`.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */
      function tap(value, interceptor, thisArg) {
        interceptor.call(thisArg, value);
        return value;
      }

      /**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       *
       * @static
       * @memberOf _
       * @category Chain
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @param {*} [thisArg] The `this` binding of `interceptor`.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _([1, 2, 3])
       *  .last()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => [3]
       */
      function thru(value, interceptor, thisArg) {
        return interceptor.call(thisArg, value);
      }

      /**
       * Enables explicit method chaining on the wrapper object.
       *
       * @name chain
       * @memberOf _
       * @category Chain
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // without explicit chaining
       * _(users).first();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // with explicit chaining
       * _(users).chain()
       *   .first()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */
      function wrapperChain() {
        return chain(this);
      }

      /**
       * Executes the chained sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @category Chain
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapper = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapper = wrapper.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapper.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }

      /**
       * Creates a clone of the chained sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @category Chain
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapper = _(array).map(function(value) {
       *   return Math.pow(value, 2);
       * });
       *
       * var other = [3, 4];
       * var otherWrapper = wrapper.plant(other);
       *
       * otherWrapper.value();
       * // => [9, 16]
       *
       * wrapper.value();
       * // => [1, 4]
       */
      function wrapperPlant(value) {
        var result,
            parent = this;

        while (parent instanceof baseLodash) {
          var clone = wrapperClone(parent);
          if (result) {
            previous.__wrapped__ = clone;
          } else {
            result = clone;
          }
          var previous = clone;
          parent = parent.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result;
      }

      /**
       * Reverses the wrapped array so the first element becomes the last, the
       * second element becomes the second to last, and so on.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @category Chain
       * @returns {Object} Returns the new reversed `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          if (this.__actions__.length) {
            value = new LazyWrapper(this);
          }
          return new LodashWrapper(value.reverse(), this.__chain__);
        }
        return this.thru(function(value) {
          return value.reverse();
        });
      }

      /**
       * Produces the result of coercing the unwrapped value to a string.
       *
       * @name toString
       * @memberOf _
       * @category Chain
       * @returns {string} Returns the coerced string value.
       * @example
       *
       * _([1, 2, 3]).toString();
       * // => '1,2,3'
       */
      function wrapperToString() {
        return (this.value() + '');
      }

      /**
       * Executes the chained sequence to extract the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @alias run, toJSON, valueOf
       * @category Chain
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates an array of elements corresponding to the given keys, or indexes,
       * of `collection`. Keys may be specified as individual arguments or as arrays
       * of keys.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {...(number|number[]|string|string[])} [props] The property names
       *  or indexes of elements to pick, specified individually or in arrays.
       * @returns {Array} Returns the new array of picked elements.
       * @example
       *
       * _.at(['a', 'b', 'c'], [0, 2]);
       * // => ['a', 'c']
       *
       * _.at(['fred', 'barney', 'pebbles'], 0, 2);
       * // => ['fred', 'pebbles']
       */
      function at(collection) {
        var length = collection ? collection.length : 0;
        if (isLength(length)) {
          collection = toIterable(collection);
        }
        return baseAt(collection, baseFlatten(arguments, false, false, 1));
      }

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` through `iteratee`. The corresponding value
       * of each key is the number of times the key was returned by `iteratee`.
       * The `iteratee` is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([4.3, 6.1, 6.4], function(n) {
       *   return Math.floor(n);
       * });
       * // => { '4': 1, '6': 2 }
       *
       * _.countBy([4.3, 6.1, 6.4], function(n) {
       *   return this.floor(n);
       * }, Math);
       * // => { '4': 1, '6': 2 }
       *
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */
      var countBy = createAggregator(function(result, value, key) {
        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
      });

      /**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * The predicate is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @alias all
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'active': false },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.every(users, 'active', false);
       * // => true
       *
       * // using the `_.property` callback shorthand
       * _.every(users, 'active');
       * // => false
       */
      function every(collection, predicate, thisArg) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
          predicate = getCallback(predicate, thisArg, 3);
        }
        return func(collection, predicate);
      }

      /**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is bound to `thisArg` and
       * invoked with three arguments; (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @alias select
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * _.filter([4, 5, 6], function(n) {
       *   return n % 2 == 0;
       * });
       * // => [4, 6]
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
       * // => ['barney']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.filter(users, 'active', false), 'user');
       * // => ['fred']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.filter(users, 'active'), 'user');
       * // => ['barney']
       */
      function filter(collection, predicate, thisArg) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        predicate = getCallback(predicate, thisArg, 3);
        return func(collection, predicate);
      }

      /**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is bound to `thisArg` and
       * invoked with three arguments; (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @alias detect
       * @category Collection
       * @param {Array|Object|string} collection The collection to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.result(_.find(users, function(chr) {
       *   return chr.age < 40;
       * }), 'user');
       * // => 'barney'
       *
       * // using the `_.matches` callback shorthand
       * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
       * // => 'pebbles'
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.result(_.find(users, 'active', false), 'user');
       * // => 'fred'
       *
       * // using the `_.property` callback shorthand
       * _.result(_.find(users, 'active'), 'user');
       * // => 'barney'
       */
      function find(collection, predicate, thisArg) {
        if (isArray(collection)) {
          var index = findIndex(collection, predicate, thisArg);
          return index > -1 ? collection[index] : undefined;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(collection, predicate, baseEach);
      }

      /**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */
      function findLast(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(collection, predicate, baseEachRight);
      }

      /**
       * Performs a deep comparison between each element in `collection` and the
       * source object, returning the first element that has equivalent property
       * values.
       *
       * **Note:** This method supports comparing arrays, booleans, `Date` objects,
       * numbers, `Object` objects, regexes, and strings. Objects are compared by
       * their own, not inherited, enumerable properties. For comparing a single
       * own or inherited property value see `_.matchesProperty`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to search.
       * @param {Object} source The object of property values to match.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
       * // => 'barney'
       *
       * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
       * // => 'fred'
       */
      function findWhere(collection, source) {
        return find(collection, baseMatches(source));
      }

      /**
       * Iterates over elements of `collection` invoking `iteratee` for each element.
       * The `iteratee` is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection). Iterator functions may exit iteration early
       * by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a `length` property
       * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
       * may be used for object iteration.
       *
       * @static
       * @memberOf _
       * @alias each
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array|Object|string} Returns `collection`.
       * @example
       *
       * _([1, 2]).forEach(function(n) {
       *   console.log(n);
       * }).value();
       * // => logs each value from left to right and returns the array
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
       *   console.log(n, key);
       * });
       * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
       */
      function forEach(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayEach(collection, iteratee)
          : baseEach(collection, bindCallback(iteratee, thisArg, 3));
      }

      /**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @alias eachRight
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array|Object|string} Returns `collection`.
       * @example
       *
       * _([1, 2]).forEachRight(function(n) {
       *   console.log(n);
       * }).join(',');
       * // => logs each value from right to left and returns the array
       */
      function forEachRight(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayEachRight(collection, iteratee)
          : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
      }

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` through `iteratee`. The corresponding value
       * of each key is an array of the elements responsible for generating the key.
       * The `iteratee` is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([4.2, 6.1, 6.4], function(n) {
       *   return Math.floor(n);
       * });
       * // => { '4': [4.2], '6': [6.1, 6.4] }
       *
       * _.groupBy([4.2, 6.1, 6.4], function(n) {
       *   return this.floor(n);
       * }, Math);
       * // => { '4': [4.2], '6': [6.1, 6.4] }
       *
       * // using the `_.property` callback shorthand
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          result[key] = [value];
        }
      });

      /**
       * Checks if `value` is in `collection` using `SameValueZero` for equality
       * comparisons. If `fromIndex` is negative, it is used as the offset from
       * the end of `collection`.
       *
       * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
       * e.g. `===`, except that `NaN` matches `NaN`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
       * for more details.
       *
       * @static
       * @memberOf _
       * @alias contains, include
       * @category Collection
       * @param {Array|Object|string} collection The collection to search.
       * @param {*} target The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {boolean} Returns `true` if a matching element is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
       * // => true
       *
       * _.includes('pebbles', 'eb');
       * // => true
       */
      function includes(collection, target, fromIndex) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
          collection = values(collection);
          length = collection.length;
        }
        if (!length) {
          return false;
        }
        if (typeof fromIndex == 'number') {
          fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
        } else {
          fromIndex = 0;
        }
        return (typeof collection == 'string' || !isArray(collection) && isString(collection))
          ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
          : (getIndexOf(collection, target, fromIndex) > -1);
      }

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` through `iteratee`. The corresponding value
       * of each key is the last element responsible for generating the key. The
       * iteratee function is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var keyData = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.indexBy(keyData, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       *
       * _.indexBy(keyData, function(object) {
       *   return String.fromCharCode(object.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.indexBy(keyData, function(object) {
       *   return this.fromCharCode(object.code);
       * }, String);
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       */
      var indexBy = createAggregator(function(result, value, key) {
        result[key] = value;
      });

      /**
       * Invokes the method named by `methodName` on each element in `collection`,
       * returning an array of the results of each invoked method. Any additional
       * arguments are provided to each invoked method. If `methodName` is a function
       * it is invoked for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|string} methodName The name of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invoke([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */
      function invoke(collection, methodName) {
        return baseInvoke(collection, methodName, baseSlice(arguments, 2));
      }

      /**
       * Creates an array of values by running each element in `collection` through
       * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
       * arguments; (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * Many lodash methods are guarded to work as interatees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
       * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
       * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
       * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
       *
       * @static
       * @memberOf _
       * @alias collect
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       *  create a `_.property` or `_.matches` style callback respectively.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function timesThree(n) {
       *   return n * 3;
       * }
       *
       * _.map([1, 2], timesThree);
       * // => [3, 6]
       *
       * _.map({ 'a': 1, 'b': 2 }, timesThree);
       * // => [3, 6] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // using the `_.property` callback shorthand
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */
      function map(collection, iteratee, thisArg) {
        var func = isArray(collection) ? arrayMap : baseMap;
        iteratee = getCallback(iteratee, thisArg, 3);
        return func(collection, iteratee);
      }

      /**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, while the second of which
       * contains elements `predicate` returns falsey for. The predicate is bound
       * to `thisArg` and invoked with three arguments; (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * _.partition([1, 2, 3], function(n) {
       *   return n % 2;
       * });
       * // => [[1, 3], [2]]
       *
       * _.partition([1.2, 2.3, 3.4], function(n) {
       *   return this.floor(n) % 2;
       * }, Math);
       * // => [[1.2, 3.4], [2.3]]
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * var mapper = function(array) {
       *   return _.pluck(array, 'user');
       * };
       *
       * // using the `_.matches` callback shorthand
       * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
       * // => [['pebbles'], ['barney', 'fred']]
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.map(_.partition(users, 'active', false), mapper);
       * // => [['barney', 'pebbles'], ['fred']]
       *
       * // using the `_.property` callback shorthand
       * _.map(_.partition(users, 'active'), mapper);
       * // => [['fred'], ['barney', 'pebbles']]
       */
      var partition = createAggregator(function(result, value, key) {
        result[key ? 0 : 1].push(value);
      }, function() { return [[], []]; });

      /**
       * Gets the value of `key` from all elements in `collection`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {string} key The key of the property to pluck.
       * @returns {Array} Returns the property values.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * _.pluck(users, 'user');
       * // => ['barney', 'fred']
       *
       * var userIndex = _.indexBy(users, 'user');
       * _.pluck(userIndex, 'age');
       * // => [36, 40] (iteration order is not guaranteed)
       */
      function pluck(collection, key) {
        return map(collection, baseProperty(key));
      }

      /**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` through `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not provided the first element of `collection` is used as the initial
       * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as interatees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `merge`, and `sortAllBy`
       *
       * @static
       * @memberOf _
       * @alias foldl, inject
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * });
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
       *   result[key] = n * 3;
       *   return result;
       * }, {});
       * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
       */
      function reduce(collection, iteratee, accumulator, thisArg) {
        var func = isArray(collection) ? arrayReduce : baseReduce;
        return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
      }

      /**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @alias foldr
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */
      function reduceRight(collection, iteratee, accumulator, thisArg) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce;
        return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
      }

      /**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * _.reject([1, 2, 3, 4], function(n) {
       *   return n % 2 == 0;
       * });
       * // => [1, 3]
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
       * // => ['barney']
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.pluck(_.reject(users, 'active', false), 'user');
       * // => ['fred']
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.reject(users, 'active'), 'user');
       * // => ['barney']
       */
      function reject(collection, predicate, thisArg) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        predicate = getCallback(predicate, thisArg, 3);
        return func(collection, function(value, index, collection) {
          return !predicate(value, index, collection);
        });
      }

      /**
       * Gets a random element or `n` random elements from a collection.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to sample.
       * @param {number} [n] The number of elements to sample.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {*} Returns the random sample(s).
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       *
       * _.sample([1, 2, 3, 4], 2);
       * // => [3, 1]
       */
      function sample(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
          collection = toIterable(collection);
          var length = collection.length;
          return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
        }
        var result = shuffle(collection);
        result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
        return result;
      }

      /**
       * Creates an array of shuffled values, using a version of the Fisher-Yates
       * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */
      function shuffle(collection) {
        collection = toIterable(collection);

        var index = -1,
            length = collection.length,
            result = Array(length);

        while (++index < length) {
          var rand = baseRandom(0, index);
          if (index != rand) {
            result[index] = result[rand];
          }
          result[rand] = collection[index];
        }
        return result;
      }

      /**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable properties for objects.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the size of `collection`.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */
      function size(collection) {
        var length = collection ? collection.length : 0;
        return isLength(length) ? length : keys(collection).length;
      }

      /**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * The function returns as soon as it finds a passing value and does not iterate
       * over the entire collection. The predicate is bound to `thisArg` and invoked
       * with three arguments; (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @alias any
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // using the `_.matches` callback shorthand
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.some(users, 'active', false);
       * // => true
       *
       * // using the `_.property` callback shorthand
       * _.some(users, 'active');
       * // => true
       */
      function some(collection, predicate, thisArg) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
          predicate = getCallback(predicate, thisArg, 3);
        }
        return func(collection, predicate);
      }

      /**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection through `iteratee`. This method performs
       * a stable sort, that is, it preserves the original sort order of equal elements.
       * The `iteratee` is bound to `thisArg` and invoked with three arguments;
       * (value, index|key, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Array|Function|Object|string} [iteratee=_.identity] The function
       *  invoked per iteration. If a property name or an object is provided it is
       *  used to create a `_.property` or `_.matches` style callback respectively.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * _.sortBy([1, 2, 3], function(n) {
       *   return Math.sin(n);
       * });
       * // => [3, 1, 2]
       *
       * _.sortBy([1, 2, 3], function(n) {
       *   return this.sin(n);
       * }, Math);
       * // => [3, 1, 2]
       *
       * var users = [
       *   { 'user': 'fred' },
       *   { 'user': 'pebbles' },
       *   { 'user': 'barney' }
       * ];
       *
       * // using the `_.property` callback shorthand
       * _.pluck(_.sortBy(users, 'user'), 'user');
       * // => ['barney', 'fred', 'pebbles']
       */
      function sortBy(collection, iteratee, thisArg) {
        if (collection == null) {
          return [];
        }
        var index = -1,
            length = collection.length,
            result = isLength(length) ? Array(length) : [];

        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        baseEach(collection, function(value, key, collection) {
          result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
        });
        return baseSortBy(result, compareAscending);
      }

      /**
       * This method is like `_.sortBy` except that it sorts by property names
       * instead of an iteratee function.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {...(string|string[])} props The property names to sort by,
       *  specified as individual property names or arrays of property names.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 26 },
       *   { 'user': 'fred',   'age': 30 }
       * ];
       *
       * _.map(_.sortByAll(users, ['user', 'age']), _.values);
       * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
       */
      function sortByAll(collection) {
        if (collection == null) {
          return [];
        }
        var args = arguments,
            guard = args[3];

        if (guard && isIterateeCall(args[1], args[2], guard)) {
          args = [collection, args[1]];
        }
        return baseSortByOrder(collection, baseFlatten(args, false, false, 1), []);
      }

      /**
       * This method is like `_.sortByAll` except that it allows specifying the
       * sort orders of the property names to sort by. A truthy value in `orders`
       * will sort the corresponding property name in ascending order while a
       * falsey value will sort it in descending order.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {string[]} props The property names to sort by.
       * @param {boolean[]} orders The sort orders of `props`.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 26 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 }
       * ];
       *
       * // sort by `user` in ascending order and by `age` in descending order
       * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);
       * // => [['barney', 36], ['barney', 26], ['fred', 40], ['fred', 30]]
       */
      function sortByOrder(collection, props, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (guard && isIterateeCall(props, orders, guard)) {
          orders = null;
        }
        if (!isArray(props)) {
          props = props == null ? [] : [props];
        }
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseSortByOrder(collection, props, orders);
      }

      /**
       * Performs a deep comparison between each element in `collection` and the
       * source object, returning an array of all elements that have equivalent
       * property values.
       *
       * **Note:** This method supports comparing arrays, booleans, `Date` objects,
       * numbers, `Object` objects, regexes, and strings. Objects are compared by
       * their own, not inherited, enumerable properties. For comparing a single
       * own or inherited property value see `_.matchesProperty`.
       *
       * @static
       * @memberOf _
       * @category Collection
       * @param {Array|Object|string} collection The collection to search.
       * @param {Object} source The object of property values to match.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
       *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
       * ];
       *
       * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
       * // => ['barney']
       *
       * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
       * // => ['fred']
       */
      function where(collection, source) {
        return filter(collection, baseMatches(source));
      }

      /*------------------------------------------------------------------------*/

      /**
       * Gets the number of milliseconds that have elapsed since the Unix epoch
       * (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @category Date
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => logs the number of milliseconds it took for the deferred function to be invoked
       */
      var now = nativeNow || function() {
        return new Date().getTime();
      };

      /*------------------------------------------------------------------------*/

      /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it is called `n` or more times.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => logs 'done saving!' after the two async saves have completed
       */
      function after(n, func) {
        if (typeof func != 'function') {
          if (typeof n == 'function') {
            var temp = n;
            n = func;
            func = temp;
          } else {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
        }
        n = nativeIsFinite(n = +n) ? n : 0;
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }

      /**
       * Creates a function that accepts up to `n` arguments ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Function} Returns the new function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */
      function ary(func, n, guard) {
        if (guard && isIterateeCall(func, n, guard)) {
          n = null;
        }
        n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
        return createWrapper(func, ARY_FLAG, null, null, null, null, n);
      }

      /**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it is called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery('#add').on('click', _.before(5, addContactToList));
       * // => allows adding up to 4 contacts to the list
       */
      function before(n, func) {
        var result;
        if (typeof func != 'function') {
          if (typeof n == 'function') {
            var temp = n;
            n = func;
            func = temp;
          } else {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
        }
        return function() {
          if (--n > 0) {
            result = func.apply(this, arguments);
          } else {
            func = null;
          }
          return result;
        };
      }

      /**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and prepends any additional `_.bind` arguments to those provided to the
       * bound function.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind` this method does not set the `length`
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [args] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var greet = function(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * };
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // using placeholders
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */
      function bind(func, thisArg) {
        var bitmask = BIND_FLAG;
        if (arguments.length > 2) {
          var partials = baseSlice(arguments, 2),
              holders = replaceHolders(partials, bind.placeholder);

          bitmask |= PARTIAL_FLAG;
        }
        return createWrapper(func, bitmask, thisArg, partials, holders);
      }

      /**
       * Binds methods of an object to the object itself, overwriting the existing
       * method. Method names may be specified as individual arguments or as arrays
       * of method names. If no method names are provided all enumerable function
       * properties, own and inherited, of `object` are bound.
       *
       * **Note:** This method does not set the `length` property of bound functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} [methodNames] The object method names to bind,
       *  specified as individual method names or arrays of method names.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'onClick': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view);
       * jQuery('#docs').on('click', view.onClick);
       * // => logs 'clicked docs' when the element is clicked
       */
      function bindAll(object) {
        return baseBindAll(object,
          arguments.length > 1
            ? baseFlatten(arguments, false, false, 1)
            : functions(object)
        );
      }

      /**
       * Creates a function that invokes the method at `object[key]` and prepends
       * any additional `_.bindKey` arguments to those provided to the bound function.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist.
       * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Object} object The object the method belongs to.
       * @param {string} key The key of the method.
       * @param {...*} [args] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // using placeholders
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */
      function bindKey(object, key) {
        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
        if (arguments.length > 2) {
          var partials = baseSlice(arguments, 2),
              holders = replaceHolders(partials, bindKey.placeholder);

          bitmask |= PARTIAL_FLAG;
        }
        return createWrapper(key, bitmask, object, partials, holders);
      }

      /**
       * Creates a function that accepts one or more arguments of `func` that when
       * called either invokes `func` returning its result, if all `func` arguments
       * have been provided, or returns a function that accepts one or more of the
       * remaining `func` arguments, and so on. The arity of `func` may be specified
       * if `func.length` is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method does not set the `length` property of curried functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // using placeholders
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */
      function curry(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = null;
        }
        var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
        result.placeholder = curry.placeholder;
        return result;
      }

      /**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method does not set the `length` property of curried functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // using placeholders
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */
      function curryRight(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = null;
        }
        var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
        result.placeholder = curryRight.placeholder;
        return result;
      }

      /**
       * Creates a function that delays invoking `func` until after `wait` milliseconds
       * have elapsed since the last time it was invoked. The created function comes
       * with a `cancel` method to cancel delayed invocations. Provide an options
       * object to indicate that `func` should be invoked on the leading and/or
       * trailing edge of the `wait` timeout. Subsequent calls to the debounced
       * function return the result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
       * on the trailing edge of the timeout only if the the debounced function is
       * invoked more than once during the `wait` timeout.
       *
       * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options] The options object.
       * @param {boolean} [options.leading=false] Specify invoking on the leading
       *  edge of the timeout.
       * @param {number} [options.maxWait] The maximum time `func` is allowed to be
       *  delayed before it is invoked.
       * @param {boolean} [options.trailing=true] Specify invoking on the trailing
       *  edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // avoid costly calculations while the window size is in flux
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
       * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // ensure `batchLog` is invoked once after 1 second of debounced calls
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', _.debounce(batchLog, 250, {
       *   'maxWait': 1000
       * }));
       *
       * // cancel a debounced call
       * var todoChanges = _.debounce(batchLog, 1000);
       * Object.observe(models.todo, todoChanges);
       *
       * Object.observe(models, function(changes) {
       *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
       *     todoChanges.cancel();
       *   }
       * }, ['delete']);
       *
       * // ...at some point `models.todo` is changed
       * models.todo.completed = true;
       *
       * // ...before 1 second has passed `models.todo` is deleted
       * // which cancels the debounced `todoChanges` call
       * delete models.todo;
       */
      function debounce(func, wait, options) {
        var args,
            maxTimeoutId,
            result,
            stamp,
            thisArg,
            timeoutId,
            trailingCall,
            lastCalled = 0,
            maxWait = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = wait < 0 ? 0 : (+wait || 0);
        if (options === true) {
          var leading = true;
          trailing = false;
        } else if (isObject(options)) {
          leading = options.leading;
          maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
          trailing = 'trailing' in options ? options.trailing : trailing;
        }

        function cancel() {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          maxTimeoutId = timeoutId = trailingCall = undefined;
        }

        function delayed() {
          var remaining = wait - (now() - stamp);
          if (remaining <= 0 || remaining > wait) {
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            var isCalled = trailingCall;
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          } else {
            timeoutId = setTimeout(delayed, remaining);
          }
        }

        function maxDelayed() {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (trailing || (maxWait !== wait)) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        }

        function debounced() {
          args = arguments;
          stamp = now();
          thisArg = this;
          trailingCall = trailing && (timeoutId || !leading);

          if (maxWait === false) {
            var leadingCall = leading && !timeoutId;
          } else {
            if (!maxTimeoutId && !leading) {
              lastCalled = stamp;
            }
            var remaining = maxWait - (stamp - lastCalled),
                isCalled = remaining <= 0 || remaining > maxWait;

            if (isCalled) {
              if (maxTimeoutId) {
                maxTimeoutId = clearTimeout(maxTimeoutId);
              }
              lastCalled = stamp;
              result = func.apply(thisArg, args);
            }
            else if (!maxTimeoutId) {
              maxTimeoutId = setTimeout(maxDelayed, remaining);
            }
          }
          if (isCalled && timeoutId) {
            timeoutId = clearTimeout(timeoutId);
          }
          else if (!timeoutId && wait !== maxWait) {
            timeoutId = setTimeout(delayed, wait);
          }
          if (leadingCall) {
            isCalled = true;
            result = func.apply(thisArg, args);
          }
          if (isCalled && !timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
          return result;
        }
        debounced.cancel = cancel;
        return debounced;
      }

      /**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it is invoked.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke the function with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // logs 'deferred' after one or more milliseconds
       */
      function defer(func) {
        return baseDelay(func, 1, arguments, 1);
      }

      /**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it is invoked.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke the function with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => logs 'later' after one second
       */
      function delay(func, wait) {
        return baseDelay(func, wait, arguments, 2);
      }

      /**
       * Creates a function that returns the result of invoking the provided
       * functions with the `this` binding of the created function, where each
       * successive invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {...Function} [funcs] Functions to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow(_.add, square);
       * addSquare(1, 2);
       * // => 9
       */
      var flow = createComposer();

      /**
       * This method is like `_.flow` except that it creates a function that
       * invokes the provided functions from right to left.
       *
       * @static
       * @memberOf _
       * @alias backflow, compose
       * @category Function
       * @param {...Function} [funcs] Functions to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight(square, _.add);
       * addSquare(1, 2);
       * // => 9
       */
      var flowRight = createComposer(true);

      /**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is coerced to a string and used as the
       * cache key. The `func` is invoked with the `this` binding of the memoized
       * function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the ES `Map` method interface
       * of `get`, `has`, and `set`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoizing function.
       * @example
       *
       * var upperCase = _.memoize(function(string) {
       *   return string.toUpperCase();
       * });
       *
       * upperCase('fred');
       * // => 'FRED'
       *
       * // modifying the result cache
       * upperCase.cache.set('fred', 'BARNEY');
       * upperCase('fred');
       * // => 'BARNEY'
       *
       * // replacing `_.memoize.Cache`
       * var object = { 'user': 'fred' };
       * var other = { 'user': 'barney' };
       * var identity = _.memoize(_.identity);
       *
       * identity(object);
       * // => { 'user': 'fred' }
       * identity(other);
       * // => { 'user': 'fred' }
       *
       * _.memoize.Cache = WeakMap;
       * var identity = _.memoize(_.identity);
       *
       * identity(object);
       * // => { 'user': 'fred' }
       * identity(other);
       * // => { 'user': 'barney' }
       */
      function memoize(func, resolver) {
        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments,
              cache = memoized.cache,
              key = resolver ? resolver.apply(this, args) : args[0];

          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          cache.set(key, result);
          return result;
        };
        memoized.cache = new memoize.Cache;
        return memoized;
      }

      /**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */
      function negate(predicate) {
        if (typeof predicate != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          return !predicate.apply(this, arguments);
        };
      }

      /**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first call. The `func` is invoked
       * with the `this` binding of the created function.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // `initialize` invokes `createApplication` once
       */
      function once(func) {
        return before(func, 2);
      }

      /**
       * Creates a function that invokes `func` with `partial` arguments prepended
       * to those provided to the new function. This method is like `_.bind` except
       * it does **not** alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method does not set the `length` property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [args] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * var greet = function(greeting, name) {
       *   return greeting + ' ' + name;
       * };
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // using placeholders
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */
      function partial(func) {
        var partials = baseSlice(arguments, 1),
            holders = replaceHolders(partials, partial.placeholder);

        return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
      }

      /**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to those provided to the new function.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method does not set the `length` property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [args] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * var greet = function(greeting, name) {
       *   return greeting + ' ' + name;
       * };
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // using placeholders
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */
      function partialRight(func) {
        var partials = baseSlice(arguments, 1),
            holders = replaceHolders(partials, partialRight.placeholder);

        return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
      }

      /**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified indexes where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes,
       *  specified as individual indexes or arrays of indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, 2, 0, 1);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       *
       * var map = _.rearg(_.map, [1, 0]);
       * map(function(n) {
       *   return n * 3;
       * }, [1, 2, 3]);
       * // => [3, 6, 9]
       */
      function rearg(func) {
        var indexes = baseFlatten(arguments, false, false, 1);
        return createWrapper(func, REARG_FLAG, null, null, null, indexes);
      }

      /**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and the array of arguments provided to the created
       * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @returns {*} Returns the new function.
       * @example
       *
       * var spread = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * spread(['Fred', 'hello']);
       * // => 'Fred says hello'
       *
       * // with a Promise
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */
      function spread(func) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function(array) {
          return func.apply(this, array);
        };
      }

      /**
       * Creates a function that only invokes `func` at most once per every `wait`
       * milliseconds. The created function comes with a `cancel` method to cancel
       * delayed invocations. Provide an options object to indicate that `func`
       * should be invoked on the leading and/or trailing edge of the `wait` timeout.
       * Subsequent calls to the throttled function return the result of the last
       * `func` call.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
       * on the trailing edge of the timeout only if the the throttled function is
       * invoked more than once during the `wait` timeout.
       *
       * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options] The options object.
       * @param {boolean} [options.leading=true] Specify invoking on the leading
       *  edge of the timeout.
       * @param {boolean} [options.trailing=true] Specify invoking on the trailing
       *  edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // avoid excessively updating the position while scrolling
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
       * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
       *   'trailing': false
       * }));
       *
       * // cancel a trailing throttled call
       * jQuery(window).on('popstate', throttled.cancel);
       */
      function throttle(func, wait, options) {
        var leading = true,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (options === false) {
          leading = false;
        } else if (isObject(options)) {
          leading = 'leading' in options ? !!options.leading : leading;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        debounceOptions.leading = leading;
        debounceOptions.maxWait = +wait;
        debounceOptions.trailing = trailing;
        return debounce(func, wait, debounceOptions);
      }

      /**
       * Creates a function that provides `value` to the wrapper function as its
       * first argument. Any additional arguments provided to the function are
       * appended to those provided to the wrapper function. The wrapper is invoked
       * with the `this` binding of the created function.
       *
       * @static
       * @memberOf _
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} wrapper The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */
      function wrap(value, wrapper) {
        wrapper = wrapper == null ? identity : wrapper;
        return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
       * otherwise they are assigned by reference. If `customizer` is provided it is
       * invoked to produce the cloned values. If `customizer` returns `undefined`
       * cloning is handled by the method instead. The `customizer` is bound to
       * `thisArg` and invoked with two argument; (value [, index|key, object]).
       *
       * **Note:** This method is loosely based on the structured clone algorithm.
       * The enumerable properties of `arguments` objects and objects created by
       * constructors other than `Object` are cloned to plain `Object` objects. An
       * empty object is returned for uncloneable values such as functions, DOM nodes,
       * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @param {Function} [customizer] The function to customize cloning values.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {*} Returns the cloned value.
       * @example
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * var shallow = _.clone(users);
       * shallow[0] === users[0];
       * // => true
       *
       * var deep = _.clone(users, true);
       * deep[0] === users[0];
       * // => false
       *
       * // using a customizer callback
       * var el = _.clone(document.body, function(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * });
       *
       * el === document.body
       * // => false
       * el.nodeName
       * // => BODY
       * el.childNodes.length;
       * // => 0
       */
      function clone(value, isDeep, customizer, thisArg) {
        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
          isDeep = false;
        }
        else if (typeof isDeep == 'function') {
          thisArg = customizer;
          customizer = isDeep;
          isDeep = false;
        }
        customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
        return baseClone(value, isDeep, customizer);
      }

      /**
       * Creates a deep clone of `value`. If `customizer` is provided it is invoked
       * to produce the cloned values. If `customizer` returns `undefined` cloning
       * is handled by the method instead. The `customizer` is bound to `thisArg`
       * and invoked with two argument; (value [, index|key, object]).
       *
       * **Note:** This method is loosely based on the structured clone algorithm.
       * The enumerable properties of `arguments` objects and objects created by
       * constructors other than `Object` are cloned to plain `Object` objects. An
       * empty object is returned for uncloneable values such as functions, DOM nodes,
       * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to deep clone.
       * @param {Function} [customizer] The function to customize cloning values.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {*} Returns the deep cloned value.
       * @example
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * var deep = _.cloneDeep(users);
       * deep[0] === users[0];
       * // => false
       *
       * // using a customizer callback
       * var el = _.cloneDeep(document.body, function(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * });
       *
       * el === document.body
       * // => false
       * el.nodeName
       * // => BODY
       * el.childNodes.length;
       * // => 20
       */
      function cloneDeep(value, customizer, thisArg) {
        customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
        return baseClone(value, true, customizer);
      }

      /**
       * Checks if `value` is classified as an `arguments` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */
      function isArguments(value) {
        var length = isObjectLike(value) ? value.length : undefined;
        return (isLength(length) && objToString.call(value) == argsTag) || false;
      }

      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(function() { return arguments; }());
       * // => false
       */
      var isArray = nativeIsArray || function(value) {
        return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
      };

      /**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */
      function isBoolean(value) {
        return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
      }

      /**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */
      function isDate(value) {
        return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
      }

      /**
       * Checks if `value` is a DOM element.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */
      function isElement(value) {
        return (value && value.nodeType === 1 && isObjectLike(value) &&
          (objToString.call(value).indexOf('Element') > -1)) || false;
      }
      // Fallback for environments without DOM support.
      if (!support.dom) {
        isElement = function(value) {
          return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
        };
      }

      /**
       * Checks if `value` is empty. A value is considered empty unless it is an
       * `arguments` object, array, string, or jQuery-like collection with a length
       * greater than `0` or an object with own enumerable properties.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {Array|Object|string} value The value to inspect.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        var length = value.length;
        if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
            (isObjectLike(value) && isFunction(value.splice)))) {
          return !length;
        }
        return !keys(value).length;
      }

      /**
       * Performs a deep comparison between two values to determine if they are
       * equivalent. If `customizer` is provided it is invoked to compare values.
       * If `customizer` returns `undefined` comparisons are handled by the method
       * instead. The `customizer` is bound to `thisArg` and invoked with three
       * arguments; (value, other [, index|key]).
       *
       * **Note:** This method supports comparing arrays, booleans, `Date` objects,
       * numbers, `Object` objects, regexes, and strings. Objects are compared by
       * their own, not inherited, enumerable properties. Functions and DOM nodes
       * are **not** supported. Provide a customizer function to extend support
       * for comparing other values.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparing values.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'user': 'fred' };
       * var other = { 'user': 'fred' };
       *
       * object == other;
       * // => false
       *
       * _.isEqual(object, other);
       * // => true
       *
       * // using a customizer callback
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqual(array, other, function(value, other) {
       *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
       *     return true;
       *   }
       * });
       * // => true
       */
      function isEqual(value, other, customizer, thisArg) {
        customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
        if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
          return value === other;
        }
        var result = customizer ? customizer(value, other) : undefined;
        return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
      }

      /**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */
      function isError(value) {
        return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
      }

      /**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on ES `Number.isFinite`. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(10);
       * // => true
       *
       * _.isFinite('10');
       * // => false
       *
       * _.isFinite(true);
       * // => false
       *
       * _.isFinite(Object(10));
       * // => false
       *
       * _.isFinite(Infinity);
       * // => false
       */
      var isFinite = nativeNumIsFinite || function(value) {
        return typeof value == 'number' && nativeIsFinite(value);
      };

      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */
      var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in older versions of Chrome and Safari which return 'function' for regexes
        // and Safari 8 equivalents which return 'object' for typed array constructors.
        return objToString.call(value) == funcTag;
      };

      /**
       * Checks if `value` is the language type of `Object`.
       * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(1);
       * // => false
       */
      function isObject(value) {
        // Avoid a V8 JIT bug in Chrome 19-20.
        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
        var type = typeof value;
        return type == 'function' || (value && type == 'object') || false;
      }

      /**
       * Performs a deep comparison between `object` and `source` to determine if
       * `object` contains equivalent property values. If `customizer` is provided
       * it is invoked to compare values. If `customizer` returns `undefined`
       * comparisons are handled by the method instead. The `customizer` is bound
       * to `thisArg` and invoked with three arguments; (value, other, index|key).
       *
       * **Note:** This method supports comparing properties of arrays, booleans,
       * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
       * and DOM nodes are **not** supported. Provide a customizer function to extend
       * support for comparing other values.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparing values.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'user': 'fred', 'age': 40 };
       *
       * _.isMatch(object, { 'age': 40 });
       * // => true
       *
       * _.isMatch(object, { 'age': 36 });
       * // => false
       *
       * // using a customizer callback
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatch(object, source, function(value, other) {
       *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
       * });
       * // => true
       */
      function isMatch(object, source, customizer, thisArg) {
        var props = keys(source),
            length = props.length;

        customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
        if (!customizer && length == 1) {
          var key = props[0],
              value = source[key];

          if (isStrictComparable(value)) {
            return object != null && value === object[key] && hasOwnProperty.call(object, key);
          }
        }
        var values = Array(length),
            strictCompareFlags = Array(length);

        while (length--) {
          value = values[length] = source[props[length]];
          strictCompareFlags[length] = isStrictComparable(value);
        }
        return baseIsMatch(object, props, values, strictCompareFlags, customizer);
      }

      /**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is not the same as native `isNaN` which returns `true`
       * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */
      function isNaN(value) {
        // An `NaN` primitive is the only value that is not equal to itself.
        // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
        return isNumber(value) && value != +value;
      }

      /**
       * Checks if `value` is a native function.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */
      function isNative(value) {
        if (value == null) {
          return false;
        }
        if (objToString.call(value) == funcTag) {
          return reNative.test(fnToString.call(value));
        }
        return (isObjectLike(value) && reHostCtor.test(value)) || false;
      }

      /**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */
      function isNull(value) {
        return value === null;
      }

      /**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
       * as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isNumber(8.4);
       * // => true
       *
       * _.isNumber(NaN);
       * // => true
       *
       * _.isNumber('8.4');
       * // => false
       */
      function isNumber(value) {
        return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
      }

      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * **Note:** This method assumes objects created by the `Object` constructor
       * have no inherited enumerable properties.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */
      var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
        if (!(value && objToString.call(value) == objectTag)) {
          return false;
        }
        var valueOf = value.valueOf,
            objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

        return objProto
          ? (value == objProto || getPrototypeOf(value) == objProto)
          : shimIsPlainObject(value);
      };

      /**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */
      function isRegExp(value) {
        return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
      }

      /**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */
      function isString(value) {
        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
      }

      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */
      function isTypedArray(value) {
        return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
      }

      /**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */
      function isUndefined(value) {
        return typeof value == 'undefined';
      }

      /**
       * Converts `value` to an array.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * (function() {
       *   return _.toArray(arguments).slice(1);
       * }(1, 2, 3));
       * // => [2, 3]
       */
      function toArray(value) {
        var length = value ? value.length : 0;
        if (!isLength(length)) {
          return values(value);
        }
        if (!length) {
          return [];
        }
        return arrayCopy(value);
      }

      /**
       * Converts `value` to a plain object flattening inherited enumerable
       * properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */
      function toPlainObject(value) {
        return baseCopy(value, keysIn(value));
      }

      /*------------------------------------------------------------------------*/

      /**
       * Assigns own enumerable properties of source object(s) to the destination
       * object. Subsequent sources overwrite property assignments of previous sources.
       * If `customizer` is provided it is invoked to produce the assigned values.
       * The `customizer` is bound to `thisArg` and invoked with five arguments;
       * (objectValue, sourceValue, key, object, source).
       *
       * @static
       * @memberOf _
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @param {Function} [customizer] The function to customize assigning values.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
       * // => { 'user': 'fred', 'age': 40 }
       *
       * // using a customizer callback
       * var defaults = _.partialRight(_.assign, function(value, other) {
       *   return typeof value == 'undefined' ? other : value;
       * });
       *
       * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
       * // => { 'user': 'barney', 'age': 36 }
       */
      var assign = createAssigner(baseAssign);

      /**
       * Creates an object that inherits from the given `prototype` object. If a
       * `properties` object is provided its own enumerable properties are assigned
       * to the created object.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */
      function create(prototype, properties, guard) {
        var result = baseCreate(prototype);
        if (guard && isIterateeCall(prototype, properties, guard)) {
          properties = null;
        }
        return properties ? baseCopy(properties, result, keys(properties)) : result;
      }

      /**
       * Assigns own enumerable properties of source object(s) to the destination
       * object for all destination properties that resolve to `undefined`. Once a
       * property is set, additional values of the same property are ignored.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
       * // => { 'user': 'barney', 'age': 36 }
       */
      function defaults(object) {
        if (object == null) {
          return object;
        }
        var args = arrayCopy(arguments);
        args.push(assignDefaults);
        return assign.apply(undefined, args);
      }

      /**
       * This method is like `_.findIndex` except that it returns the key of the
       * first element `predicate` returns truthy for, instead of the element itself.
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(chr) {
       *   return chr.age < 40;
       * });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // using the `_.matches` callback shorthand
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.findKey(users, 'active', false);
       * // => 'fred'
       *
       * // using the `_.property` callback shorthand
       * _.findKey(users, 'active');
       * // => 'barney'
       */
      function findKey(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, baseForOwn, true);
      }

      /**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to search.
       * @param {Function|Object|string} [predicate=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(chr) {
       *   return chr.age < 40;
       * });
       * // => returns `pebbles` assuming `_.findKey` returns `barney`
       *
       * // using the `_.matches` callback shorthand
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // using the `_.matchesProperty` callback shorthand
       * _.findLastKey(users, 'active', false);
       * // => 'fred'
       *
       * // using the `_.property` callback shorthand
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */
      function findLastKey(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, baseForOwnRight, true);
      }

      /**
       * Iterates over own and inherited enumerable properties of an object invoking
       * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
       * with three arguments; (value, key, object). Iterator functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
       */
      function forIn(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return baseFor(object, iteratee, keysIn);
      }

      /**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
       */
      function forInRight(object, iteratee, thisArg) {
        iteratee = bindCallback(iteratee, thisArg, 3);
        return baseForRight(object, iteratee, keysIn);
      }

      /**
       * Iterates over own enumerable properties of an object invoking `iteratee`
       * for each property. The `iteratee` is bound to `thisArg` and invoked with
       * three arguments; (value, key, object). Iterator functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => logs 'a' and 'b' (iteration order is not guaranteed)
       */
      function forOwn(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return baseForOwn(object, iteratee);
      }

      /**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
       */
      function forOwnRight(object, iteratee, thisArg) {
        iteratee = bindCallback(iteratee, thisArg, 3);
        return baseForRight(object, iteratee, keys);
      }

      /**
       * Creates an array of function property names from all enumerable properties,
       * own and inherited, of `object`.
       *
       * @static
       * @memberOf _
       * @alias methods
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the new array of property names.
       * @example
       *
       * _.functions(_);
       * // => ['after', 'ary', 'assign', ...]
       */
      function functions(object) {
        return baseFunctions(object, keysIn(object));
      }

      /**
       * Checks if `key` exists as a direct property of `object` instead of an
       * inherited property.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {string} key The key to check.
       * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 3 };
       *
       * _.has(object, 'b');
       * // => true
       */
      function has(object, key) {
        return object ? hasOwnProperty.call(object, key) : false;
      }

      /**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite property
       * assignments of previous values unless `multiValue` is `true`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to invert.
       * @param {boolean} [multiValue] Allow multiple values per key.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       *
       * // with `multiValue`
       * _.invert(object, true);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */
      function invert(object, multiValue, guard) {
        if (guard && isIterateeCall(object, multiValue, guard)) {
          multiValue = null;
        }
        var index = -1,
            props = keys(object),
            length = props.length,
            result = {};

        while (++index < length) {
          var key = props[index],
              value = object[key];

          if (multiValue) {
            if (hasOwnProperty.call(result, value)) {
              result[value].push(key);
            } else {
              result[value] = [key];
            }
          }
          else {
            result[value] = key;
          }
        }
        return result;
      }

      /**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */
      var keys = !nativeKeys ? shimKeys : function(object) {
        if (object) {
          var Ctor = object.constructor,
              length = object.length;
        }
        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
            (typeof object != 'function' && (length && isLength(length)))) {
          return shimKeys(object);
        }
        return isObject(object) ? nativeKeys(object) : [];
      };

      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */
      function keysIn(object) {
        if (object == null) {
          return [];
        }
        if (!isObject(object)) {
          object = Object(object);
        }
        var length = object.length;
        length = (length && isLength(length) &&
          (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

        var Ctor = object.constructor,
            index = -1,
            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
            result = Array(length),
            skipIndexes = length > 0;

        while (++index < length) {
          result[index] = (index + '');
        }
        for (var key in object) {
          if (!(skipIndexes && isIndex(key, length)) &&
              !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * Creates an object with the same keys as `object` and values generated by
       * running each own enumerable property of `object` through `iteratee`. The
       * iteratee function is bound to `thisArg` and invoked with three arguments;
       * (value, key, object).
       *
       * If a property name is provided for `iteratee` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `iteratee` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function|Object|string} [iteratee=_.identity] The function invoked
       *  per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Object} Returns the new mapped object.
       * @example
       *
       * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
       *   return n * 3;
       * });
       * // => { 'a': 3, 'b': 6 }
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * // using the `_.property` callback shorthand
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */
      function mapValues(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          result[key] = iteratee(value, key, object);
        });
        return result;
      }

      /**
       * Recursively merges own enumerable properties of the source object(s), that
       * don't resolve to `undefined` into the destination object. Subsequent sources
       * overwrite property assignments of previous sources. If `customizer` is
       * provided it is invoked to produce the merged values of the destination and
       * source properties. If `customizer` returns `undefined` merging is handled
       * by the method instead. The `customizer` is bound to `thisArg` and invoked
       * with five arguments; (objectValue, sourceValue, key, object, source).
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @param {Function} [customizer] The function to customize merging properties.
       * @param {*} [thisArg] The `this` binding of `customizer`.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var users = {
       *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
       * };
       *
       * var ages = {
       *   'data': [{ 'age': 36 }, { 'age': 40 }]
       * };
       *
       * _.merge(users, ages);
       * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
       *
       * // using a customizer callback
       * var object = {
       *   'fruits': ['apple'],
       *   'vegetables': ['beet']
       * };
       *
       * var other = {
       *   'fruits': ['banana'],
       *   'vegetables': ['carrot']
       * };
       *
       * _.merge(object, other, function(a, b) {
       *   if (_.isArray(a)) {
       *     return a.concat(b);
       *   }
       * });
       * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
       */
      var merge = createAssigner(baseMerge);

      /**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable properties of `object` that are not omitted.
       * Property names may be specified as individual arguments or as arrays of
       * property names. If `predicate` is provided it is invoked for each property
       * of `object` omitting the properties `predicate` returns truthy for. The
       * predicate is bound to `thisArg` and invoked with three arguments;
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {Function|...(string|string[])} [predicate] The function invoked per
       *  iteration or property names to omit, specified as individual property
       *  names or arrays of property names.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'user': 'fred', 'age': 40 };
       *
       * _.omit(object, 'age');
       * // => { 'user': 'fred' }
       *
       * _.omit(object, _.isNumber);
       * // => { 'user': 'fred' }
       */
      function omit(object, predicate, thisArg) {
        if (object == null) {
          return {};
        }
        if (typeof predicate != 'function') {
          var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
          return pickByArray(object, baseDifference(keysIn(object), props));
        }
        predicate = bindCallback(predicate, thisArg, 3);
        return pickByCallback(object, function(value, key, object) {
          return !predicate(value, key, object);
        });
      }

      /**
       * Creates a two dimensional array of the key-value pairs for `object`,
       * e.g. `[[key1, value1], [key2, value2]]`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the new array of key-value pairs.
       * @example
       *
       * _.pairs({ 'barney': 36, 'fred': 40 });
       * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
       */
      function pairs(object) {
        var index = -1,
            props = keys(object),
            length = props.length,
            result = Array(length);

        while (++index < length) {
          var key = props[index];
          result[index] = [key, object[key]];
        }
        return result;
      }

      /**
       * Creates an object composed of the picked `object` properties. Property
       * names may be specified as individual arguments or as arrays of property
       * names. If `predicate` is provided it is invoked for each property of `object`
       * picking the properties `predicate` returns truthy for. The predicate is
       * bound to `thisArg` and invoked with three arguments; (value, key, object).
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {Function|...(string|string[])} [predicate] The function invoked per
       *  iteration or property names to pick, specified as individual property
       *  names or arrays of property names.
       * @param {*} [thisArg] The `this` binding of `predicate`.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'user': 'fred', 'age': 40 };
       *
       * _.pick(object, 'user');
       * // => { 'user': 'fred' }
       *
       * _.pick(object, _.isString);
       * // => { 'user': 'fred' }
       */
      function pick(object, predicate, thisArg) {
        if (object == null) {
          return {};
        }
        return typeof predicate == 'function'
          ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
          : pickByArray(object, baseFlatten(arguments, false, false, 1));
      }

      /**
       * Resolves the value of property `key` on `object`. If the value of `key` is
       * a function it is invoked with the `this` binding of `object` and its result
       * is returned, else the property value is returned. If the property value is
       * `undefined` the `defaultValue` is used in its place.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to resolve.
       * @param {*} [defaultValue] The value returned if the property value
       *  resolves to `undefined`.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'user': 'fred', 'age': _.constant(40) };
       *
       * _.result(object, 'user');
       * // => 'fred'
       *
       * _.result(object, 'age');
       * // => 40
       *
       * _.result(object, 'status', 'busy');
       * // => 'busy'
       *
       * _.result(object, 'status', _.constant('busy'));
       * // => 'busy'
       */
      function result(object, key, defaultValue) {
        var value = object == null ? undefined : object[key];
        if (typeof value == 'undefined') {
          value = defaultValue;
        }
        return isFunction(value) ? value.call(object) : value;
      }

      /**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own enumerable
       * properties through `iteratee`, with each invocation potentially mutating
       * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
       * with four arguments; (accumulator, value, key, object). Iterator functions
       * may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Array|Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * });
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
       *   result[key] = n * 3;
       * });
       * // => { 'a': 3, 'b': 6 }
       */
      function transform(object, iteratee, accumulator, thisArg) {
        var isArr = isArray(object) || isTypedArray(object);
        iteratee = getCallback(iteratee, thisArg, 4);

        if (accumulator == null) {
          if (isArr || isObject(object)) {
            var Ctor = object.constructor;
            if (isArr) {
              accumulator = isArray(object) ? new Ctor : [];
            } else {
              accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
            }
          } else {
            accumulator = {};
          }
        }
        (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
          return iteratee(accumulator, value, index, object);
        });
        return accumulator;
      }

      /**
       * Creates an array of the own enumerable property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */
      function values(object) {
        return baseValues(object, keys(object));
      }

      /**
       * Creates an array of the own and inherited enumerable property values
       * of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */
      function valuesIn(object) {
        return baseValues(object, keysIn(object));
      }

      /*------------------------------------------------------------------------*/

      /**
       * Checks if `n` is between `start` and up to but not including, `end`. If
       * `end` is not specified it is set to `start` with `start` then set to `0`.
       *
       * @static
       * @memberOf _
       * @category Number
       * @param {number} n The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       */
      function inRange(value, start, end) {
        start = +start || 0;
        if (typeof end === 'undefined') {
          end = start;
          start = 0;
        } else {
          end = +end || 0;
        }
        return value >= start && value < end;
      }

      /**
       * Produces a random number between `min` and `max` (inclusive). If only one
       * argument is provided a number between `0` and the given number is returned.
       * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
       * number is returned instead of an integer.
       *
       * @static
       * @memberOf _
       * @category Number
       * @param {number} [min=0] The minimum possible value.
       * @param {number} [max=1] The maximum possible value.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */
      function random(min, max, floating) {
        if (floating && isIterateeCall(min, max, floating)) {
          max = floating = null;
        }
        var noMin = min == null,
            noMax = max == null;

        if (floating == null) {
          if (noMax && typeof min == 'boolean') {
            floating = min;
            min = 1;
          }
          else if (typeof max == 'boolean') {
            floating = max;
            noMax = true;
          }
        }
        if (noMin && noMax) {
          max = 1;
          noMax = false;
        }
        min = +min || 0;
        if (noMax) {
          max = min;
          min = 0;
        } else {
          max = +max || 0;
        }
        if (floating || min % 1 || max % 1) {
          var rand = nativeRandom();
          return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
        }
        return baseRandom(min, max);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Converts `string` to camel case.
       * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar');
       * // => 'fooBar'
       *
       * _.camelCase('__foo_bar__');
       * // => 'fooBar'
       */
      var camelCase = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
      });

      /**
       * Capitalizes the first character of `string`.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('fred');
       * // => 'Fred'
       */
      function capitalize(string) {
        string = baseToString(string);
        return string && (string.charAt(0).toUpperCase() + string.slice(1));
      }

      /**
       * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
       * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('déjà vu');
       * // => 'deja vu'
       */
      function deburr(string) {
        string = baseToString(string);
        return string && string.replace(reLatin1, deburrLetter);
      }

      /**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to search.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search from.
       * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */
      function endsWith(string, target, position) {
        string = baseToString(string);
        target = (target + '');

        var length = string.length;
        position = typeof position == 'undefined'
          ? length
          : nativeMin(position < 0 ? 0 : (+position || 0), length);

        position -= target.length;
        return position >= 0 && string.indexOf(target, position) == position;
      }

      /**
       * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
       * their corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional characters
       * use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't require escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value.
       * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * Backticks are escaped because in Internet Explorer < 9, they can break out
       * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
       * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
       * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
       *
       * When working with HTML you should always quote attribute values to reduce
       * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */
      function escape(string) {
        // Reset `lastIndex` because in IE < 9 `String#replace` does not.
        string = baseToString(string);
        return (string && reHasUnescapedHtml.test(string))
          ? string.replace(reUnescapedHtml, escapeHtmlChar)
          : string;
      }

      /**
       * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
       * "+", "(", ")", "[", "]", "{" and "}" in `string`.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */
      function escapeRegExp(string) {
        string = baseToString(string);
        return (string && reHasRegExpChars.test(string))
          ? string.replace(reRegExpChars, '\\$&')
          : string;
      }

      /**
       * Converts `string` to kebab case.
       * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
       * more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__foo_bar__');
       * // => 'foo-bar'
       */
      var kebabCase = createCompounder(function(result, word, index) {
        return result + (index ? '-' : '') + word.toLowerCase();
      });

      /**
       * Pads `string` on the left and right sides if it is shorter then the given
       * padding length. The `chars` string may be truncated if the number of padding
       * characters can't be evenly divided by the padding length.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */
      function pad(string, length, chars) {
        string = baseToString(string);
        length = +length;

        var strLength = string.length;
        if (strLength >= length || !nativeIsFinite(length)) {
          return string;
        }
        var mid = (length - strLength) / 2,
            leftLength = floor(mid),
            rightLength = ceil(mid);

        chars = createPad('', rightLength, chars);
        return chars.slice(0, leftLength) + string + chars;
      }

      /**
       * Pads `string` on the left side if it is shorter then the given padding
       * length. The `chars` string may be truncated if the number of padding
       * characters exceeds the padding length.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padLeft('abc', 6);
       * // => '   abc'
       *
       * _.padLeft('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padLeft('abc', 3);
       * // => 'abc'
       */
      function padLeft(string, length, chars) {
        string = baseToString(string);
        return string && (createPad(string, length, chars) + string);
      }

      /**
       * Pads `string` on the right side if it is shorter then the given padding
       * length. The `chars` string may be truncated if the number of padding
       * characters exceeds the padding length.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padRight('abc', 6);
       * // => 'abc   '
       *
       * _.padRight('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padRight('abc', 3);
       * // => 'abc'
       */
      function padRight(string, length, chars) {
        string = baseToString(string);
        return string && (string + createPad(string, length, chars));
      }

      /**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
       * in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the ES5 implementation of `parseInt`.
       * See the [ES5 spec](https://es5.github.io/#E) for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */
      function parseInt(string, radix, guard) {
        if (guard && isIterateeCall(string, radix, guard)) {
          radix = 0;
        }
        return nativeParseInt(string, radix);
      }
      // Fallback for environments with pre-ES5 implementations.
      if (nativeParseInt(whitespace + '08') != 8) {
        parseInt = function(string, radix, guard) {
          // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
          // Chrome fails to trim leading <BOM> whitespace characters.
          // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
        };
      }

      /**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=0] The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */
      function repeat(string, n) {
        var result = '';
        string = baseToString(string);
        n = +n;
        if (n < 1 || !string || !nativeIsFinite(n)) {
          return result;
        }
        // Leverage the exponentiation by squaring algorithm for a faster repeat.
        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
        do {
          if (n % 2) {
            result += string;
          }
          n = floor(n / 2);
          string += string;
        } while (n);

        return result;
      }

      /**
       * Converts `string` to snake case.
       * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--foo-bar');
       * // => 'foo_bar'
       */
      var snakeCase = createCompounder(function(result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase();
      });

      /**
       * Converts `string` to start case.
       * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
       * for more details.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__foo_bar__');
       * // => 'Foo Bar'
       */
      var startCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
      });

      /**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to search.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */
      function startsWith(string, target, position) {
        string = baseToString(string);
        position = position == null
          ? 0
          : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

        return string.lastIndexOf(target, position) == position;
      }

      /**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is provided it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
       * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for more details.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options] The options object.
       * @param {RegExp} [options.escape] The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
       * @param {Object} [options.imports] An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
       * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
       * @param {string} [options.variable] The data object variable name.
       * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // using the "interpolate" delimiter to create a compiled template
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // using the HTML "escape" delimiter to escape data property values
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // using the "evaluate" delimiter to execute JavaScript and generate HTML
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // using the internal `print` function in "evaluate" delimiters
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // using the ES delimiter as an alternative to the default "interpolate" delimiter
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // using custom template delimiters
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // using backslashes to treat delimiters as plain text
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // using the `imports` option to import `jQuery` as `jq`
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // using the `sourceURL` option to specify a custom sourceURL for the template
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
       *
       * // using the `variable` option to ensure a with-statement isn't used in the compiled template
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // using the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and a stack trace
       * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */
      function template(string, options, otherOptions) {
        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
        var settings = lodash.templateSettings;

        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
          options = otherOptions = null;
        }
        string = baseToString(string);
        options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

        var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);

        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";

        // Compile the regexp to match each delimiter.
        var reDelimiters = RegExp(
          (options.escape || reNoMatch).source + '|' +
          interpolate.source + '|' +
          (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
          (options.evaluate || reNoMatch).source + '|$'
        , 'g');

        // Use a sourceURL for easier debugging.
        var sourceURL = '//# sourceURL=' +
          ('sourceURL' in options
            ? options.sourceURL
            : ('lodash.templateSources[' + (++templateCounter) + ']')
          ) + '\n';

        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);

          // Escape characters that can't be included in string literals.
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

          // Replace delimiters with snippets.
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;

          // The JS engine embedded in Adobe products requires returning the `match`
          // string in order to produce the correct `offset` value.
          return match;
        });

        source += "';\n";

        // If `variable` is not specified wrap a with-statement around the generated
        // code to add the data object to the top of the scope chain.
        var variable = options.variable;
        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        }
        // Cleanup code by stripping empty strings.
        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
          .replace(reEmptyStringMiddle, '$1')
          .replace(reEmptyStringTrailing, '$1;');

        // Frame code as the function body.
        source = 'function(' + (variable || 'obj') + ') {\n' +
          (variable
            ? ''
            : 'obj || (obj = {});\n'
          ) +
          "var __t, __p = ''" +
          (isEscaping
             ? ', __e = _.escape'
             : ''
          ) +
          (isEvaluating
            ? ', __j = Array.prototype.join;\n' +
              "function print() { __p += __j.call(arguments, '') }\n"
            : ';\n'
          ) +
          source +
          'return __p\n}';

        var result = attempt(function() {
          return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        });

        // Provide the compiled function's source by its `toString` method or
        // the `source` property as a convenience for inlining compiled templates.
        result.source = source;
        if (isError(result)) {
          throw result;
        }
        return result;
      }

      /**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar]
       */
      function trim(string, chars, guard) {
        var value = string;
        string = baseToString(string);
        if (!string) {
          return string;
        }
        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
          return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
        }
        chars = (chars + '');
        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
      }

      /**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimLeft('  abc  ');
       * // => 'abc  '
       *
       * _.trimLeft('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */
      function trimLeft(string, chars, guard) {
        var value = string;
        string = baseToString(string);
        if (!string) {
          return string;
        }
        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
          return string.slice(trimmedLeftIndex(string));
        }
        return string.slice(charsLeftIndex(string, (chars + '')));
      }

      /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimRight('  abc  ');
       * // => '  abc'
       *
       * _.trimRight('-_-abc-_-', '_-');
       * // => '-_-abc'
       */
      function trimRight(string, chars, guard) {
        var value = string;
        string = baseToString(string);
        if (!string) {
          return string;
        }
        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
          return string.slice(0, trimmedRightIndex(string) + 1);
        }
        return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
      }

      /**
       * Truncates `string` if it is longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object|number} [options] The options object or maximum string length.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.trunc('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.trunc('hi-diddly-ho there, neighborino', 24);
       * // => 'hi-diddly-ho there, n...'
       *
       * _.trunc('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.trunc('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * //=> 'hi-diddly-ho there...'
       *
       * _.trunc('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */
      function trunc(string, options, guard) {
        if (guard && isIterateeCall(string, options, guard)) {
          options = null;
        }
        var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;

        if (options != null) {
          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? (+options.length || 0) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          } else {
            length = +options || 0;
          }
        }
        string = baseToString(string);
        if (length >= string.length) {
          return string;
        }
        var end = length - omission.length;
        if (end < 1) {
          return omission;
        }
        var result = string.slice(0, end);
        if (separator == null) {
          return result + omission;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match,
                newEnd,
                substring = string.slice(0, end);

            if (!separator.global) {
              separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
            }
            separator.lastIndex = 0;
            while ((match = separator.exec(substring))) {
              newEnd = match.index;
            }
            result = result.slice(0, newEnd == null ? end : newEnd);
          }
        } else if (string.indexOf(separator, end) != end) {
          var index = result.lastIndexOf(separator);
          if (index > -1) {
            result = result.slice(0, index);
          }
        }
        return result + omission;
      }

      /**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
       * corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional HTML
       * entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */
      function unescape(string) {
        string = baseToString(string);
        return (string && reHasEscapedHtml.test(string))
          ? string.replace(reEscapedHtml, unescapeHtmlChar)
          : string;
      }

      /**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */
      function words(string, pattern, guard) {
        if (guard && isIterateeCall(string, pattern, guard)) {
          pattern = null;
        }
        string = baseToString(string);
        return string.match(pattern || reWords) || [];
      }

      /*------------------------------------------------------------------------*/

      /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it is invoked.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {*} func The function to attempt.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // avoid throwing errors for invalid selectors
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */
      function attempt() {
        var func = arguments[0],
            length = arguments.length,
            args = Array(length ? (length - 1) : 0);

        while (--length > 0) {
          args[length - 1] = arguments[length];
        }
        try {
          return func.apply(undefined, args);
        } catch(e) {
          return isError(e) ? e : new Error(e);
        }
      }

      /**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and arguments of the created function. If `func` is a property name the
       * created callback returns the property value for a given element. If `func`
       * is an object the created callback returns `true` for elements that contain
       * the equivalent object properties, otherwise it returns `false`.
       *
       * @static
       * @memberOf _
       * @alias iteratee
       * @category Utility
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // wrap to create custom callback shorthands
       * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
       *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
       *   if (!match) {
       *     return callback(func, thisArg);
       *   }
       *   return function(object) {
       *     return match[2] == 'gt'
       *       ? object[match[1]] > match[3]
       *       : object[match[1]] < match[3];
       *   };
       * });
       *
       * _.filter(users, 'age__gt36');
       * // => [{ 'user': 'fred', 'age': 40 }]
       */
      function callback(func, thisArg, guard) {
        if (guard && isIterateeCall(func, thisArg, guard)) {
          thisArg = null;
        }
        return isObjectLike(func)
          ? matches(func)
          : baseCallback(func, thisArg);
      }

      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var object = { 'user': 'fred' };
       * var getter = _.constant(object);
       *
       * getter() === object;
       * // => true
       */
      function constant(value) {
        return function() {
          return value;
        };
      }

      /**
       * This method returns the first argument provided to it.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'user': 'fred' };
       *
       * _.identity(object) === object;
       * // => true
       */
      function identity(value) {
        return value;
      }

      /**
       * Creates a function which performs a deep comparison between a given object
       * and `source`, returning `true` if the given object has equivalent property
       * values, else `false`.
       *
       * **Note:** This method supports comparing arrays, booleans, `Date` objects,
       * numbers, `Object` objects, regexes, and strings. Objects are compared by
       * their own, not inherited, enumerable properties. For comparing a single
       * own or inherited property value see `_.matchesProperty`.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, _.matches({ 'age': 40, 'active': false }));
       * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
       */
      function matches(source) {
        return baseMatches(baseClone(source, true));
      }

      /**
       * Creates a function which compares the property value of `key` on a given
       * object to `value`.
       *
       * **Note:** This method supports comparing arrays, booleans, `Date` objects,
       * numbers, `Object` objects, regexes, and strings. Objects are compared by
       * their own, not inherited, enumerable properties.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {string} key The key of the property to get.
       * @param {*} value The value to compare.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' },
       *   { 'user': 'pebbles' }
       * ];
       *
       * _.find(users, _.matchesProperty('user', 'fred'));
       * // => { 'user': 'fred', 'age': 40 }
       */
      function matchesProperty(key, value) {
        return baseMatchesProperty(key + '', baseClone(value, true));
      }

      /**
       * Adds all own enumerable function properties of a source object to the
       * destination object. If `object` is a function then methods are added to
       * its prototype as well.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Function|Object} [object=this] object The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options] The options object.
       * @param {boolean} [options.chain=true] Specify whether the functions added
       *  are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
       * var _ = require('lodash').runInContext();
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */
      function mixin(object, source, options) {
        if (options == null) {
          var isObj = isObject(source),
              props = isObj && keys(source),
              methodNames = props && props.length && baseFunctions(source, props);

          if (!(methodNames ? methodNames.length : isObj)) {
            methodNames = false;
            options = source;
            source = object;
            object = this;
          }
        }
        if (!methodNames) {
          methodNames = baseFunctions(source, keys(source));
        }
        var chain = true,
            index = -1,
            isFunc = isFunction(object),
            length = methodNames.length;

        if (options === false) {
          chain = false;
        } else if (isObject(options) && 'chain' in options) {
          chain = options.chain;
        }
        while (++index < length) {
          var methodName = methodNames[index],
              func = source[methodName];

          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = (function(func) {
              return function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__);
                  (result.__actions__ = arrayCopy(this.__actions__)).push({
                    'func': func,
                    'args': arguments,
                    'thisArg': object
                  });
                  result.__chain__ = chainAll;
                  return result;
                }
                var args = [this.value()];
                push.apply(args, arguments);
                return func.apply(object, args);
              };
            }(func));
          }
        }
        return object;
      }

      /**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */
      function noConflict() {
        context._ = oldDash;
        return this;
      }

      /**
       * A no-operation function which returns `undefined` regardless of the
       * arguments it receives.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @example
       *
       * var object = { 'user': 'fred' };
       *
       * _.noop(object) === undefined;
       * // => true
       */
      function noop() {
        // No operation performed.
      }

      /**
       * Creates a function which returns the property value of `key` on a given object.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var users = [
       *   { 'user': 'fred' },
       *   { 'user': 'barney' }
       * ];
       *
       * var getName = _.property('user');
       *
       * _.map(users, getName);
       * // => ['fred', barney']
       *
       * _.pluck(_.sortBy(users, getName), 'user');
       * // => ['barney', 'fred']
       */
      function property(key) {
        return baseProperty(key + '');
      }

      /**
       * The inverse of `_.property`; this method creates a function which returns
       * the property value of a given key on `object`.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Object} object The object to inspect.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var object = { 'a': 3, 'b': 1, 'c': 2 };
       *
       * _.map(['a', 'c'], _.propertyOf(object));
       * // => [3, 2]
       *
       * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
       * // => ['b', 'c', 'a']
       */
      function propertyOf(object) {
        return function(key) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. If `end` is not specified it is
       * set to `start` with `start` then set to `0`. If `start` is less than `end`
       * a zero-length range is created unless a negative `step` is specified.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the new array of numbers.
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */
      function range(start, end, step) {
        if (step && isIterateeCall(start, end, step)) {
          end = step = null;
        }
        start = +start || 0;
        step = step == null ? 1 : (+step || 0);

        if (end == null) {
          end = start;
          start = 0;
        } else {
          end = +end || 0;
        }
        // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
        // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
        var index = -1,
            length = nativeMax(ceil((end - start) / (step || 1)), 0),
            result = Array(length);

        while (++index < length) {
          result[index] = start;
          start += step;
        }
        return result;
      }

      /**
       * Invokes the iteratee function `n` times, returning an array of the results
       * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
       * one argument; (index).
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
       * // => [3, 6, 4]
       *
       * _.times(3, function(n) {
       *   mage.castSpell(n);
       * });
       * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
       *
       * _.times(3, function(n) {
       *   this.cast(n);
       * }, mage);
       * // => also invokes `mage.castSpell(n)` three times
       */
      function times(n, iteratee, thisArg) {
        n = +n;

        // Exit early to avoid a JSC JIT bug in Safari 8
        // where `Array(0)` is treated as `Array(1)`.
        if (n < 1 || !nativeIsFinite(n)) {
          return [];
        }
        var index = -1,
            result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

        iteratee = bindCallback(iteratee, thisArg, 1);
        while (++index < n) {
          if (index < MAX_ARRAY_LENGTH) {
            result[index] = iteratee(index);
          } else {
            iteratee(index);
          }
        }
        return result;
      }

      /**
       * Generates a unique ID. If `prefix` is provided the ID is appended to it.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {string} [prefix] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */
      function uniqueId(prefix) {
        var id = ++idCounter;
        return baseToString(prefix) + id;
      }

      /*------------------------------------------------------------------------*/

      /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @category Math
       * @param {number} augend The first number to add.
       * @param {number} addend The second number to add.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */
      function add(augend, addend) {
        return augend + addend;
      }

      /**
       * Gets the maximum value of `collection`. If `collection` is empty or falsey
       * `-Infinity` is returned. If an iteratee function is provided it is invoked
       * for each value in `collection` to generate the criterion by which the value
       * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
       * arguments; (value, index, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Math
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => -Infinity
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * _.max(users, function(chr) {
       *   return chr.age;
       * });
       * // => { 'user': 'fred', 'age': 40 };
       *
       * // using the `_.property` callback shorthand
       * _.max(users, 'age');
       * // => { 'user': 'fred', 'age': 40 };
       */
      var max = createExtremum(arrayMax);

      /**
       * Gets the minimum value of `collection`. If `collection` is empty or falsey
       * `Infinity` is returned. If an iteratee function is provided it is invoked
       * for each value in `collection` to generate the criterion by which the value
       * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
       * arguments; (value, index, collection).
       *
       * If a property name is provided for `predicate` the created `_.property`
       * style callback returns the property value of the given element.
       *
       * If a value is also provided for `thisArg` the created `_.matchesProperty`
       * style callback returns `true` for elements that have a matching property
       * value, else `false`.
       *
       * If an object is provided for `predicate` the created `_.matches` style
       * callback returns `true` for elements that have the properties of the given
       * object, else `false`.
       *
       * @static
       * @memberOf _
       * @category Math
       * @param {Array|Object|string} collection The collection to iterate over.
       * @param {Function|Object|string} [iteratee] The function invoked per iteration.
       * @param {*} [thisArg] The `this` binding of `iteratee`.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => Infinity
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * _.min(users, function(chr) {
       *   return chr.age;
       * });
       * // => { 'user': 'barney', 'age': 36 };
       *
       * // using the `_.property` callback shorthand
       * _.min(users, 'age');
       * // => { 'user': 'barney', 'age': 36 };
       */
      var min = createExtremum(arrayMin, true);

      /**
       * Gets the sum of the values in `collection`.
       *
       * @static
       * @memberOf _
       * @category Math
       * @param {Array|Object|string} collection The collection to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 6, 2]);
       * // => 12
       *
       * _.sum({ 'a': 4, 'b': 6, 'c': 2 });
       * // => 12
       */
      function sum(collection) {
        if (!isArray(collection)) {
          collection = toIterable(collection);
        }
        var length = collection.length,
            result = 0;

        while (length--) {
          result += +collection[length] || 0;
        }
        return result;
      }

      /*------------------------------------------------------------------------*/

      // Ensure wrappers are instances of `baseLodash`.
      lodash.prototype = baseLodash.prototype;

      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;

      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;

      // Add functions to the `Map` cache.
      MapCache.prototype['delete'] = mapDelete;
      MapCache.prototype.get = mapGet;
      MapCache.prototype.has = mapHas;
      MapCache.prototype.set = mapSet;

      // Add functions to the `Set` cache.
      SetCache.prototype.push = cachePush;

      // Assign cache to `_.memoize`.
      memoize.Cache = MapCache;

      // Add functions that return wrapped values when chaining.
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.callback = callback;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.functions = functions;
      lodash.groupBy = groupBy;
      lodash.indexBy = indexBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.invert = invert;
      lodash.invoke = invoke;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.omit = omit;
      lodash.once = once;
      lodash.pairs = pairs;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pluck = pluck;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortByAll = sortByAll;
      lodash.sortByOrder = sortByOrder;
      lodash.spread = spread;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.times = times;
      lodash.toArray = toArray;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.union = union;
      lodash.uniq = uniq;
      lodash.unzip = unzip;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.where = where;
      lodash.without = without;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.zip = zip;
      lodash.zipObject = zipObject;

      // Add aliases.
      lodash.backflow = flowRight;
      lodash.collect = map;
      lodash.compose = flowRight;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.extend = assign;
      lodash.iteratee = callback;
      lodash.methods = functions;
      lodash.object = zipObject;
      lodash.select = filter;
      lodash.tail = rest;
      lodash.unique = uniq;

      // Add functions to `lodash.prototype`.
      mixin(lodash, lodash);

      /*------------------------------------------------------------------------*/

      // Add functions that return unwrapped values when chaining.
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.deburr = deburr;
      lodash.endsWith = endsWith;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.findWhere = findWhere;
      lodash.first = first;
      lodash.has = has;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isBoolean = isBoolean;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isMatch = isMatch;
      lodash.isNaN = isNaN;
      lodash.isNative = isNative;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isString = isString;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.max = max;
      lodash.min = min;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padLeft = padLeft;
      lodash.padRight = padRight;
      lodash.parseInt = parseInt;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.result = result;
      lodash.runInContext = runInContext;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.sum = sum;
      lodash.template = template;
      lodash.trim = trim;
      lodash.trimLeft = trimLeft;
      lodash.trimRight = trimRight;
      lodash.trunc = trunc;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.words = words;

      // Add aliases.
      lodash.all = every;
      lodash.any = some;
      lodash.contains = includes;
      lodash.detect = find;
      lodash.foldl = reduce;
      lodash.foldr = reduceRight;
      lodash.head = first;
      lodash.include = includes;
      lodash.inject = reduce;

      mixin(lodash, (function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!lodash.prototype[methodName]) {
            source[methodName] = func;
          }
        });
        return source;
      }()), false);

      /*------------------------------------------------------------------------*/

      // Add functions capable of returning wrapped and unwrapped values when chaining.
      lodash.sample = sample;

      lodash.prototype.sample = function(n) {
        if (!this.__chain__ && n == null) {
          return sample(this.value());
        }
        return this.thru(function(value) {
          return sample(value, n);
        });
      };

      /*------------------------------------------------------------------------*/

      /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type string
       */
      lodash.VERSION = VERSION;

      // Assign default placeholders.
      arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });

      // Add `LazyWrapper` methods that accept an `iteratee` value.
      arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {
        var isFilter = type != LAZY_MAP_FLAG,
            isDropWhile = type == LAZY_DROP_WHILE_FLAG;

        LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
          var filtered = this.__filtered__,
              result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
              iteratees = result.__iteratees__ || (result.__iteratees__ = []);

          iteratees.push({
            'done': false,
            'count': 0,
            'index': 0,
            'iteratee': getCallback(iteratee, thisArg, 1),
            'limit': -1,
            'type': type
          });

          result.__filtered__ = filtered || isFilter;
          return result;
        };
      });

      // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
      arrayEach(['drop', 'take'], function(methodName, index) {
        var whileName = methodName + 'While';

        LazyWrapper.prototype[methodName] = function(n) {
          var filtered = this.__filtered__,
              result = (filtered && !index) ? this.dropWhile() : this.clone();

          n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
          if (filtered) {
            if (index) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              last(result.__iteratees__).limit = n;
            }
          } else {
            var views = result.__views__ || (result.__views__ = []);
            views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
          }
          return result;
        };

        LazyWrapper.prototype[methodName + 'Right'] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };

        LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
          return this.reverse()[whileName](predicate, thisArg).reverse();
        };
      });

      // Add `LazyWrapper` methods for `_.first` and `_.last`.
      arrayEach(['first', 'last'], function(methodName, index) {
        var takeName = 'take' + (index ? 'Right' : '');

        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });

      // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
      arrayEach(['initial', 'rest'], function(methodName, index) {
        var dropName = 'drop' + (index ? '' : 'Right');

        LazyWrapper.prototype[methodName] = function() {
          return this[dropName](1);
        };
      });

      // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
      arrayEach(['pluck', 'where'], function(methodName, index) {
        var operationName = index ? 'filter' : 'map',
            createCallback = index ? baseMatches : baseProperty;

        LazyWrapper.prototype[methodName] = function(value) {
          return this[operationName](createCallback(value));
        };
      });

      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };

      LazyWrapper.prototype.reject = function(predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 1);
        return this.filter(function(value) {
          return !predicate(value);
        });
      };

      LazyWrapper.prototype.slice = function(start, end) {
        start = start == null ? 0 : (+start || 0);
        var result = start < 0 ? this.takeRight(-start) : this.drop(start);

        if (typeof end != 'undefined') {
          end = (+end || 0);
          result = end < 0 ? result.dropRight(-end) : result.take(end - start);
        }
        return result;
      };

      LazyWrapper.prototype.toArray = function() {
        return this.drop(0);
      };

      // Add `LazyWrapper` methods to `lodash.prototype`.
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName],
            checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
            retUnwrapped = /^(?:first|last)$/.test(methodName);

        lodash.prototype[methodName] = function() {
          var args = arguments,
              length = args.length,
              chainAll = this.__chain__,
              value = this.__wrapped__,
              isHybrid = !!this.__actions__.length,
              isLazy = value instanceof LazyWrapper,
              iteratee = args[0],
              useLazy = isLazy || isArray(value);

          if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
            // avoid lazy use if the iteratee has a `length` other than `1`
            isLazy = useLazy = false;
          }
          var onlyLazy = isLazy && !isHybrid;
          if (retUnwrapped && !chainAll) {
            return onlyLazy
              ? func.call(value)
              : lodashFunc.call(lodash, this.value());
          }
          var interceptor = function(value) {
            var otherArgs = [value];
            push.apply(otherArgs, args);
            return lodashFunc.apply(lodash, otherArgs);
          };
          if (useLazy) {
            var wrapper = onlyLazy ? value : new LazyWrapper(this),
                result = func.apply(wrapper, args);

            if (!retUnwrapped && (isHybrid || result.__actions__)) {
              var actions = result.__actions__ || (result.__actions__ = []);
              actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
            }
            return new LodashWrapper(result, chainAll);
          }
          return this.thru(interceptor);
        };
      });

      // Add `Array` and `String` methods to `lodash.prototype`.
      arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            return func.apply(this.value(), args);
          }
          return this[chainName](function(value) {
            return func.apply(value, args);
          });
        };
      });

      // Add functions to the lazy wrapper.
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;

      // Add chaining functions to the `lodash` wrapper.
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toString = wrapperToString;
      lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

      // Add function aliases to the `lodash` wrapper.
      lodash.prototype.collect = lodash.prototype.map;
      lodash.prototype.head = lodash.prototype.first;
      lodash.prototype.select = lodash.prototype.filter;
      lodash.prototype.tail = lodash.prototype.rest;

      return lodash;
    }

    /*--------------------------------------------------------------------------*/

    // Export lodash.
    var _ = runInContext();

    // Some AMD build optimizers like r.js check for condition patterns like the following:
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      // Expose lodash to the global object when an AMD loader is present to avoid
      // errors in cases where lodash is loaded by a script tag and not intended
      // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
      // more details.
      root._ = _;

      // Define as an anonymous module so, through path mapping, it can be
      // referenced as the "underscore" module.
      define.modules.lodash = (function() {
        return _;
      })();
    }
    // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
    else if (freeExports && freeModule) {
      // Export for Node.js or RingoJS.
      if (moduleExports) {
        (freeModule.exports = _)._ = _;
      }
      // Export for Narwhal or Rhino -require.
      else {
        freeExports._ = _;
      }
    }
    else {
      // Export for a browser or Rhino.
      root._ = _;
    }
  }.call(this));

  define.modules['lib/events'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var _ = define.modules.lodash;

      var slice = Array.prototype.slice;

      // Regular expression used to split event strings.
      var eventSplitter = /\s+/;

      // Implement fancy features of the Events API such as multiple event
      // names `"change blur"` and jQuery-style event maps `{change: action}`
      // in terms of the existing API.
      var eventsApi = function(obj, action, name, rest) {
        if (!name) return true;

        // Handle event maps.
        if (typeof name === 'object') {
          for (var key in name) {
            obj[action].apply(obj, [key, name[key]].concat(rest));
          }
          return false;
        }

        // Handle space separated event names.
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          for (var i = 0, l = names.length; i < l; i++) {
            obj[action].apply(obj, [names[i]].concat(rest));
          }
          return false;
        }

        return true;
      };

      // A difficult-to-believe, but optimized internal dispatch function for
      // triggering events. Tries to keep the usual cases speedy (most internal
      // Backbone events have 3 arguments).
      var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
          case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
          case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
          case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
          default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
        }
      };

      // Bind an event to a `callback` function. Passing `"all"` will bind
      // the callback to all events fired.
      exports.on = function(name, callback, context) {
        if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
        this._events = this._events || {};
        var events = this._events[name] || (this._events[name] = []);
        events.push({callback: callback, context: context, ctx: context || this});
        return this;
      };

      // Bind an event to only be triggered a single time. After the first time
      // the callback is invoked, it will be removed.
      exports.once = function(name, callback, context) {
        if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
        var self = this;
        var once = _.once(function() {
          self.off(name, once);
          callback.apply(this, arguments);
        });
        once._callback = callback;
        return this.on(name, once, context);
      };

      // Remove one or many callbacks. If `context` is null, removes all
      // callbacks with that function. If `callback` is null, removes all
      // callbacks for the event. If `name` is null, removes all bound
      // callbacks for all events.
      exports.off = function(name, callback, context) {
        var retain, ev, events, names, i, l, j, k;
        if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
        if (!name && !callback && !context) {
          this._events = {};
          return this;
        }
        names = name ? [name] : _.keys(this._events);
        for (i = 0, l = names.length; i < l; i++) {
          name = names[i];
          if (events = this._events[name]) {
            this._events[name] = retain = [];
            if (callback || context) {
              for (j = 0, k = events.length; j < k; j++) {
                ev = events[j];
                if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                    (context && context !== ev.context)) {
                  retain.push(ev);
                }
              }
            }
            if (!retain.length) delete this._events[name];
          }
        }

        return this;
      };

      // Trigger one or many events, firing all bound callbacks. Callbacks are
      // passed the same arguments as `trigger` is, apart from the event name
      // (unless you're listening on `"all"`, which will cause your callback to
      // receive the true name of the event as the first argument).
      exports.trigger = function(name) {
        if (!this._events) return this;
        var args = slice.call(arguments, 1);
        if (!eventsApi(this, 'trigger', name, args)) return this;
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events) triggerEvents(events, args);
        if (allEvents) triggerEvents(allEvents, arguments);
        return this;
      };

      // Inversion-of-control versions of `on` and `once`. Tell *this* object to
      // listen to an event in another object ... keeping track of what it's
      // listening to.
      exports.listenTo = function(obj, name, callback) {
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        listeningTo[id] = obj;
        if (!callback && typeof name === 'object') callback = this;
        obj.on(name, callback, this);
        return this;
      };

      exports.listenToOnce = function(obj, name, callback) {
        if (typeof name === 'object') {
          for (var event in name) this.listenToOnce(obj, event, name[event]);
          return this;
        }
        var cb = _.once(function() {
          this.stopListening(obj, name, cb);
          callback.apply(this, arguments);
        });
        cb._callback = callback;
        return this.listenTo(obj, name, cb);
      };

      // Tell this object to stop listening to either specific events ... or
      // to every object it's currently listening to.
      exports.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var remove = !name && !callback;
        if (!callback && typeof name === 'object') callback = this;
        if (obj) (listeningTo = {})[obj._listenId] = obj;
        for (var id in listeningTo) {
          obj = listeningTo[id];
          obj.off(name, callback, this);
          if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
        }
        return this;
      };

      // Aliases for backwards compatibility.
      exports.bind   = exports.on;
      exports.unbind = exports.off;
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module inheritance
   * @requires module:lodash
   */
  define.modules['lib/inheritance'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // Third-party dependencies.
      var _ = define.modules.lodash;

      // support/object/create
      // support/object/defineProperty

      /**
       * Generalize the initialization of a new instance so that it can be easily
       * called from either `new` or `create`.
       *
       * @private
       * @param {Function} Surrogate - A constructor function.
       * @param {Object} child - The instance object to use.
       * @param {Arguments} args - An arguments object from `create` or `new`.
       * @returns {Object} An initialized instance.
       */
      function initialize(Surrogate, child, args) {
        // Invoke the constructor, passing along all arguments.
        var retVal = Surrogate.prototype.constructor.apply(child, args);

        // Do not pass along empty objects.
        if (Surrogate.prototype.constructor === Object) {
          retVal = false;
        }

        // Proxy through return values.
        return retVal ? retVal : child;
      }

      /**
       * Optionally allow users to create instances without using the new keyword.
       *
       * @public
       * @memberOf module:inheritance
       * @returns {Object} An initialized instance.
       */
      exports.create = function() {
        return initialize(this, Object.create(this.prototype), arguments);
      };

      /**
       * Extends the parent Object, without triggering anything special.
       *
       * @public
       * @memberOf module:inheritance
       * @param instanceProperties
       * @param classProperties
       * @returns {Function} A surrogate constructor that has been extended.
       */
      exports.extend = function(instanceProperties, classProperties) {
        var Parent = this;

        // Extending creates a new constructor that will be based off the parent.
        function Surrogate() {
          // Allow for constructors to be called without `new`.
          if (!(this instanceof Surrogate)) {
            // Only way to pass arguments to a constructor that will be initialized
            // with the `new` keyword.
            var InnerCtor = _.bind.apply(null, [Surrogate].concat(arguments));

            // Return a new instance of this constructor.
            return new InnerCtor();
          }

          return initialize(Surrogate, this, arguments);
        }

        // Convenience method for accessing the parent.
        Object.defineProperty(Surrogate, "super", {
          // Keep this property protected.
          writable: false,

          // If no arguments are passed, return the parent prototype, otherwise
          // call the specified method on the parent and pass along all arguments.
          value: function(method, context, args) {
            return method ? Parent.prototype[method].apply(context, args) : Parent;
          }
        });

        // Apply the class properties.
        _.extend(Surrogate, classProperties);

        // Ensure there is a direct reference to the parent.  `__proto__` will be
        // standardized in ES6.
        Surrogate.__proto__ = Parent;

        // Ensure the prototype inherits from `this`.
        Surrogate.prototype = Object.create(Parent.prototype);

        // Backbone compatibility.
        Surrogate.__super__ = Parent.prototype;

        // Populate prototype with `instanceProperties`.
        _.extend(Surrogate.prototype, instanceProperties);

        return Surrogate;
      };

      /**
       * Allow class properties to be mixed into the constructor.
       *
       * @public
       * @memberOf module:inheritance
       * @param {Object} classProperties - A list of properties to be mixed in.
       */
      exports.mixin = function(classProperties) {
        _.extend(this, classProperties);
      };
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module class
   * @requires module:events
   * @requires module:inheritance
   * @requires module:lodash
   */
  define.modules['lib/class'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // WebApp internals.
      var Events = define.modules['lib/events'];
      var Inheritance = define.modules['lib/inheritance'];

      // Third-party dependencies.
      var _ = define.modules.lodash;

      /**
       * Base Class constructor.
       */
      function Class() {}

      // Classes provide events.
      _.extend(Class.prototype, Events, {
        // Set the default constructor.
        constructor: Class
      });

      // Classes provide inheritance.
      _.extend(Class, Inheritance);

      module.exports = Class;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/util/errors'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var _ = define.modules.lodash;

      /**
       * Url
       *
       * @param message
       */
      exports.Url = function(message) {
        message = message || "A `url` property or function must be specified.";

        this.name = "UrlError";
        this.message = message;
      };

      /**
       * MissingAdapter
       *
       * @param message
       */
      exports.MissingAdapter = function(message) {
        message = message || "An `adapter` property must be specified.";

        this.name = "MissingAdapter";
        this.message = message;
      };

      /**
       * InvalidName
       *
       * @param message
       */
      exports.InvalidName = function(message) {
        message = message || "A valid name must be specified.";

        this.name = "InvalidName";
        this.message = message;
      };

      /**
       * InvalidCallback
       *
       * @param message
       */
      exports.InvalidCallback = function(message) {
        message = message || "A valid callback must be specified.";

        this.name = "InvalidCallback";
        this.message = message;
      };

      // Automatically wire up the prototype, instead of manual assignment.
      _.each(exports, function(Ctor) {
        Ctor.prototype = Error.prototype;
      });
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module channel
   * @requires module:events
   * @requires module:class
   * @requires module:util/errors
   * @requires module:lodash
   */
  define.modules['lib/channel'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // WebApp internals.
      var Events = define.modules['lib/events'];
      var Class = define.modules['lib/class'];
      var Errors = define.modules['lib/util/errors'];

      // Third-party dependencies.
      var _ = define.modules.lodash;

      // Global event bus.
      var Bus = _.extend({}, Events);

      // Global channel cache.
      var Cache = {};

      /**
       * A channel is subscribed to and managed from this formal construct.
       *
       * @memberOf module:channel
       */
      var Channel = Class.extend({
        /**
         * Formats a UUID suitable
         * Source: https://gist.github.com/jed/982883
         *
         * @return
         */
        uuid: function() {
          return "0000-0000-0000-0000-0000".replace(/0/g, function() {
            return Math.floor(Math.random() * 16).toString(16);
          });
        },

        /**
         * Creates or returns an existing Channel.
         *
         * @param {string} name - to identify the channel.
         */
        constructor: function(name) {
          // Name must be a string that does not contain spaces.
          if (typeof name !== "string" || name.indexOf(" ") > -1) {
            name = this.uuid();
          }

          this.name(name);
          this.data = this.data || {};
        },

        name: function(name) {
          // Cache the first instance created.
          if (!Cache[name]) {
            Cache[name] = this;
            this.__name__ = name;
          }
          // Re-use the existing instance.
          else {
            this.__proto__ = Cache[name];
          }
        },

        /**
         * Listen to broadcasted events.
         *
         * @param {string} path
         * @param {function} callback
         * @param {object} context
         *
         */
        subscribe: function(path, callback, context) {
          // Argument shifting.
          if (typeof path !== "string") {
            context = callback || this;
            callback = path;
            path = undefined;
          }

          // Monitor the bus and trigger based on what is being monitored.
          this.listenTo(Bus, this.__name__, function(key, value) {
            value = value || key;

            // If a path was provided, match it to the emitted key.  If no path was
            // provided, simply funnel all key/val to the callback.
            if ((path && path === key) || !path) {
              callback.call(context, value, key);
            }
          });
        },

        /**
         * Unsubscribes an entire channel instance or only specific sub channels
         * within the instance.
         *
         * @param {string} name
         */
        unsubscribe: function(name) {
          this.stopListening(Bus, name);
        },

        /**
         * Write changes into the Channel stream.
         *
         * @param key
         * @param val
         */
        publish: function(key, val) {
          if (typeof key === "object" && !Array.isArray(key)) {
            _.each(key, function(val, key) {
              this.data[key] = val;
              Bus.trigger(this.__name__, key, val);
            }, this);
          }
          else {
            this.data[key] = val;
            Bus.trigger(this.__name__, key, val);
          }
        }
      });

      module.exports = Channel;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/sync/adapter'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];
      var _ = define.modules.lodash;

      var Adapter = Class.extend({
        constructor: function(properties) {
          // Merge in the additional properties.
          _.extend(this, properties);
        },

        isAvailable: function() {
          throw "Method not implemented.";
        },

        get: function() {
          throw "Method not implemented.";
        },

        set: function() {
          throw "Method not implemented.";
        }
      });

      module.exports = Adapter;
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module sync/adapters/rest
   * @requires module:sync/adapter
   */
  define.modules['lib/sync/adapters/rest'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Adapter = define.modules['lib/sync/adapter'];

      var Rest = Adapter.extend({
        /**
         * Map from CRUD to HTTP for our default `Backbone.sync` implementation.
         *
         * @public
         * @memberOf module:sync/adapters/rest
         * @type {Object}
         */
        methodMap: {
          "create": "POST",
          "update": "PUT",
          "patch":  "PATCH",
          "delete": "DELETE",
          "read":   "GET"
        },

        /**
         * constructor
         *
         * @return
         */
        constructor: function(options) {
          var method = options.method;
          var model = options.model;

          options = options.options || options;

          // JSON-request options.
          if (!options.type) {
            options.type = this.methodMap[method];
          }

          if (!options.dataType) {
            options.dataType = "json";
          }

          // Ensure that we have the appropriate request data.
          if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            options.contentType = 'application/json';
            options.data = JSON.stringify(options.attrs || model.toJSON(options));
          }

        },

        /**
         * get
         *
         * @return
         */
        get: function() {
          return this.cache;
        },

        /**
         * set
         *
         * @param objects
         * @return
         */
        set: function(objects) {
          this.cache = objects;
        }
      });

      module.exports = Rest;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/sync/transport'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];

      var _ = define.modules.lodash;

      var Transport = Class.extend({
        constructor: function(properties) {
          // Merge in the additional properties.
          this.options = _.extend({}, this.options, properties.options);

          // If a channel is set, bind to it.
          // Set up custom Model handler logic for the channel.
          if (this.channel) {
            // Whenever this internal data changes, update.
            this.on("change", function() {
              this.channel.publish(this.changed);
            }, this);
          }
        },

        isAvailable: function() {
          throw "Method not implemented.";
        },

        connect: function() {
          throw "Method not implemented.";
        },

        disconnect: function() {
          throw "Method not implemented.";
        },

        request: function() {
          throw "Method not implemented.";
        },

        requestIfModified: function() {
          throw "Method not implemented.";
        }
      });

      module.exports = Transport;
    })(null, module.exports, module);

    return module.exports;
  })();

  /*!
   * jQuery JavaScript Library v2.1.3
   * http://jquery.com/
   *
   * Includes Sizzle.js
   * http://sizzlejs.com/
   *
   * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2014-12-18T15:11Z
   */

  (function( global, factory ) {

  	if ( typeof module === "object" && typeof module.exports === "object" ) {
  		// For CommonJS and CommonJS-like environments where a proper `window`
  		// is present, execute the factory and get jQuery.
  		// For environments that do not have a `window` with a `document`
  		// (such as Node.js), expose a factory as module.exports.
  		// This accentuates the need for the creation of a real `window`.
  		// e.g. var jQuery = require("jquery")(window);
  		// See ticket #14549 for more info.
  		module.exports = global.document ?
  			factory( global, true ) :
  			function( w ) {
  				if ( !w.document ) {
  					throw new Error( "jQuery requires a window with a document" );
  				}
  				return factory( w );
  			};
  	} else {
  		factory( global );
  	}

  // Pass this if window is not defined yet
  }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

  // Support: Firefox 18+
  // Can't be in strict mode, several libs including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  //

  var arr = [];

  var slice = arr.slice;

  var concat = arr.concat;

  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var support = {};



  var
  	// Use the correct document accordingly with window argument (sandbox)
  	document = window.document,

  	version = "2.1.3",

  	// Define a local copy of jQuery
  	jQuery = function( selector, context ) {
  		// The jQuery object is actually just the init constructor 'enhanced'
  		// Need init if jQuery is called (just allow error to be thrown if not included)
  		return new jQuery.fn.init( selector, context );
  	},

  	// Support: Android<4.1
  	// Make sure we trim BOM and NBSP
  	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

  	// Matches dashed string for camelizing
  	rmsPrefix = /^-ms-/,
  	rdashAlpha = /-([\da-z])/gi,

  	// Used by jQuery.camelCase as callback to replace()
  	fcamelCase = function( all, letter ) {
  		return letter.toUpperCase();
  	};

  jQuery.fn = jQuery.prototype = {
  	// The current version of jQuery being used
  	jquery: version,

  	constructor: jQuery,

  	// Start with an empty selector
  	selector: "",

  	// The default length of a jQuery object is 0
  	length: 0,

  	toArray: function() {
  		return slice.call( this );
  	},

  	// Get the Nth element in the matched element set OR
  	// Get the whole matched element set as a clean array
  	get: function( num ) {
  		return num != null ?

  			// Return just the one element from the set
  			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

  			// Return all the elements in a clean array
  			slice.call( this );
  	},

  	// Take an array of elements and push it onto the stack
  	// (returning the new matched element set)
  	pushStack: function( elems ) {

  		// Build a new jQuery matched element set
  		var ret = jQuery.merge( this.constructor(), elems );

  		// Add the old object onto the stack (as a reference)
  		ret.prevObject = this;
  		ret.context = this.context;

  		// Return the newly-formed element set
  		return ret;
  	},

  	// Execute a callback for every element in the matched set.
  	// (You can seed the arguments with an array of args, but this is
  	// only used internally.)
  	each: function( callback, args ) {
  		return jQuery.each( this, callback, args );
  	},

  	map: function( callback ) {
  		return this.pushStack( jQuery.map(this, function( elem, i ) {
  			return callback.call( elem, i, elem );
  		}));
  	},

  	slice: function() {
  		return this.pushStack( slice.apply( this, arguments ) );
  	},

  	first: function() {
  		return this.eq( 0 );
  	},

  	last: function() {
  		return this.eq( -1 );
  	},

  	eq: function( i ) {
  		var len = this.length,
  			j = +i + ( i < 0 ? len : 0 );
  		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
  	},

  	end: function() {
  		return this.prevObject || this.constructor(null);
  	},

  	// For internal use only.
  	// Behaves like an Array's method, not like a jQuery method.
  	push: push,
  	sort: arr.sort,
  	splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
  	var options, name, src, copy, copyIsArray, clone,
  		target = arguments[0] || {},
  		i = 1,
  		length = arguments.length,
  		deep = false;

  	// Handle a deep copy situation
  	if ( typeof target === "boolean" ) {
  		deep = target;

  		// Skip the boolean and the target
  		target = arguments[ i ] || {};
  		i++;
  	}

  	// Handle case when target is a string or something (possible in deep copy)
  	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
  		target = {};
  	}

  	// Extend jQuery itself if only one argument is passed
  	if ( i === length ) {
  		target = this;
  		i--;
  	}

  	for ( ; i < length; i++ ) {
  		// Only deal with non-null/undefined values
  		if ( (options = arguments[ i ]) != null ) {
  			// Extend the base object
  			for ( name in options ) {
  				src = target[ name ];
  				copy = options[ name ];

  				// Prevent never-ending loop
  				if ( target === copy ) {
  					continue;
  				}

  				// Recurse if we're merging plain objects or arrays
  				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
  					if ( copyIsArray ) {
  						copyIsArray = false;
  						clone = src && jQuery.isArray(src) ? src : [];

  					} else {
  						clone = src && jQuery.isPlainObject(src) ? src : {};
  					}

  					// Never move original objects, clone them
  					target[ name ] = jQuery.extend( deep, clone, copy );

  				// Don't bring in undefined values
  				} else if ( copy !== undefined ) {
  					target[ name ] = copy;
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  jQuery.extend({
  	// Unique for each copy of jQuery on the page
  	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  	// Assume jQuery is ready without the ready module
  	isReady: true,

  	error: function( msg ) {
  		throw new Error( msg );
  	},

  	noop: function() {},

  	isFunction: function( obj ) {
  		return jQuery.type(obj) === "function";
  	},

  	isArray: Array.isArray,

  	isWindow: function( obj ) {
  		return obj != null && obj === obj.window;
  	},

  	isNumeric: function( obj ) {
  		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
  		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  		// subtraction forces infinities to NaN
  		// adding 1 corrects loss of precision from parseFloat (#15100)
  		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
  	},

  	isPlainObject: function( obj ) {
  		// Not plain objects:
  		// - Any object or value whose internal [[Class]] property is not "[object Object]"
  		// - DOM nodes
  		// - window
  		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
  			return false;
  		}

  		if ( obj.constructor &&
  				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
  			return false;
  		}

  		// If the function hasn't returned already, we're confident that
  		// |obj| is a plain object, created by {} or constructed with new Object
  		return true;
  	},

  	isEmptyObject: function( obj ) {
  		var name;
  		for ( name in obj ) {
  			return false;
  		}
  		return true;
  	},

  	type: function( obj ) {
  		if ( obj == null ) {
  			return obj + "";
  		}
  		// Support: Android<4.0, iOS<6 (functionish RegExp)
  		return typeof obj === "object" || typeof obj === "function" ?
  			class2type[ toString.call(obj) ] || "object" :
  			typeof obj;
  	},

  	// Evaluates a script in a global context
  	globalEval: function( code ) {
  		var script,
  			indirect = eval;

  		code = jQuery.trim( code );

  		if ( code ) {
  			// If the code includes a valid, prologue position
  			// strict mode pragma, execute code by injecting a
  			// script tag into the document.
  			if ( code.indexOf("use strict") === 1 ) {
  				script = document.createElement("script");
  				script.text = code;
  				document.head.appendChild( script ).parentNode.removeChild( script );
  			} else {
  			// Otherwise, avoid the DOM node creation, insertion
  			// and removal by using an indirect global eval
  				indirect( code );
  			}
  		}
  	},

  	// Convert dashed to camelCase; used by the css and data modules
  	// Support: IE9-11+
  	// Microsoft forgot to hump their vendor prefix (#9572)
  	camelCase: function( string ) {
  		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  	},

  	nodeName: function( elem, name ) {
  		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  	},

  	// args is for internal usage only
  	each: function( obj, callback, args ) {
  		var value,
  			i = 0,
  			length = obj.length,
  			isArray = isArraylike( obj );

  		if ( args ) {
  			if ( isArray ) {
  				for ( ; i < length; i++ ) {
  					value = callback.apply( obj[ i ], args );

  					if ( value === false ) {
  						break;
  					}
  				}
  			} else {
  				for ( i in obj ) {
  					value = callback.apply( obj[ i ], args );

  					if ( value === false ) {
  						break;
  					}
  				}
  			}

  		// A special, fast, case for the most common use of each
  		} else {
  			if ( isArray ) {
  				for ( ; i < length; i++ ) {
  					value = callback.call( obj[ i ], i, obj[ i ] );

  					if ( value === false ) {
  						break;
  					}
  				}
  			} else {
  				for ( i in obj ) {
  					value = callback.call( obj[ i ], i, obj[ i ] );

  					if ( value === false ) {
  						break;
  					}
  				}
  			}
  		}

  		return obj;
  	},

  	// Support: Android<4.1
  	trim: function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "" );
  	},

  	// results is for internal usage only
  	makeArray: function( arr, results ) {
  		var ret = results || [];

  		if ( arr != null ) {
  			if ( isArraylike( Object(arr) ) ) {
  				jQuery.merge( ret,
  					typeof arr === "string" ?
  					[ arr ] : arr
  				);
  			} else {
  				push.call( ret, arr );
  			}
  		}

  		return ret;
  	},

  	inArray: function( elem, arr, i ) {
  		return arr == null ? -1 : indexOf.call( arr, elem, i );
  	},

  	merge: function( first, second ) {
  		var len = +second.length,
  			j = 0,
  			i = first.length;

  		for ( ; j < len; j++ ) {
  			first[ i++ ] = second[ j ];
  		}

  		first.length = i;

  		return first;
  	},

  	grep: function( elems, callback, invert ) {
  		var callbackInverse,
  			matches = [],
  			i = 0,
  			length = elems.length,
  			callbackExpect = !invert;

  		// Go through the array, only saving the items
  		// that pass the validator function
  		for ( ; i < length; i++ ) {
  			callbackInverse = !callback( elems[ i ], i );
  			if ( callbackInverse !== callbackExpect ) {
  				matches.push( elems[ i ] );
  			}
  		}

  		return matches;
  	},

  	// arg is for internal usage only
  	map: function( elems, callback, arg ) {
  		var value,
  			i = 0,
  			length = elems.length,
  			isArray = isArraylike( elems ),
  			ret = [];

  		// Go through the array, translating each of the items to their new values
  		if ( isArray ) {
  			for ( ; i < length; i++ ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}

  		// Go through every key on the object,
  		} else {
  			for ( i in elems ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}
  		}

  		// Flatten any nested arrays
  		return concat.apply( [], ret );
  	},

  	// A global GUID counter for objects
  	guid: 1,

  	// Bind a function to a context, optionally partially applying any
  	// arguments.
  	proxy: function( fn, context ) {
  		var tmp, args, proxy;

  		if ( typeof context === "string" ) {
  			tmp = fn[ context ];
  			context = fn;
  			fn = tmp;
  		}

  		// Quick check to determine if target is callable, in the spec
  		// this throws a TypeError, but we will just return undefined.
  		if ( !jQuery.isFunction( fn ) ) {
  			return undefined;
  		}

  		// Simulated bind
  		args = slice.call( arguments, 2 );
  		proxy = function() {
  			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  		};

  		// Set the guid of unique handler to the same of original handler, so it can be removed
  		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  		return proxy;
  	},

  	now: Date.now,

  	// jQuery.support is not used in Core but other projects attach their
  	// properties to it so it needs to exist.
  	support: support
  });

  // Populate the class2type map
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
  	class2type[ "[object " + name + "]" ] = name.toLowerCase();
  });

  function isArraylike( obj ) {
  	var length = obj.length,
  		type = jQuery.type( obj );

  	if ( type === "function" || jQuery.isWindow( obj ) ) {
  		return false;
  	}

  	if ( obj.nodeType === 1 && length ) {
  		return true;
  	}

  	return type === "array" || length === 0 ||
  		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.2.0-pre
   * http://sizzlejs.com/
   *
   * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2014-12-16
   */
  (function( window ) {

  var i,
  	support,
  	Expr,
  	getText,
  	isXML,
  	tokenize,
  	compile,
  	select,
  	outermostContext,
  	sortInput,
  	hasDuplicate,

  	// Local document vars
  	setDocument,
  	document,
  	docElem,
  	documentIsHTML,
  	rbuggyQSA,
  	rbuggyMatches,
  	matches,
  	contains,

  	// Instance-specific data
  	expando = "sizzle" + 1 * new Date(),
  	preferredDoc = window.document,
  	dirruns = 0,
  	done = 0,
  	classCache = createCache(),
  	tokenCache = createCache(),
  	compilerCache = createCache(),
  	sortOrder = function( a, b ) {
  		if ( a === b ) {
  			hasDuplicate = true;
  		}
  		return 0;
  	},

  	// General-purpose constants
  	MAX_NEGATIVE = 1 << 31,

  	// Instance methods
  	hasOwn = ({}).hasOwnProperty,
  	arr = [],
  	pop = arr.pop,
  	push_native = arr.push,
  	push = arr.push,
  	slice = arr.slice,
  	// Use a stripped-down indexOf as it's faster than native
  	// http://jsperf.com/thor-indexof-vs-for/5
  	indexOf = function( list, elem ) {
  		var i = 0,
  			len = list.length;
  		for ( ; i < len; i++ ) {
  			if ( list[i] === elem ) {
  				return i;
  			}
  		}
  		return -1;
  	},

  	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  	// Regular expressions

  	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
  	whitespace = "[\\x20\\t\\r\\n\\f]",
  	// http://www.w3.org/TR/css3-syntax/#characters
  	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

  	// Loosely modeled on CSS identifier characters
  	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
  	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  	identifier = characterEncoding.replace( "w", "w#" ),

  	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +
  		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
  		"*\\]",

  	pseudos = ":(" + characterEncoding + ")(?:\\((" +
  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  	rwhitespace = new RegExp( whitespace + "+", "g" ),
  	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

  	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

  	rpseudo = new RegExp( pseudos ),
  	ridentifier = new RegExp( "^" + identifier + "$" ),

  	matchExpr = {
  		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
  		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
  		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
  		"ATTR": new RegExp( "^" + attributes ),
  		"PSEUDO": new RegExp( "^" + pseudos ),
  		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
  			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
  			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
  		// For use in libraries implementing .is()
  		// We use this for POS matching in `select`
  		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
  			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  	},

  	rinputs = /^(?:input|select|textarea|button)$/i,
  	rheader = /^h\d$/i,

  	rnative = /^[^{]+\{\s*\[native \w/,

  	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  	rsibling = /[+~]/,
  	rescape = /'|\\/g,

  	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
  	funescape = function( _, escaped, escapedWhitespace ) {
  		var high = "0x" + escaped - 0x10000;
  		// NaN means non-codepoint
  		// Support: Firefox<24
  		// Workaround erroneous numeric interpretation of +"0x"
  		return high !== high || escapedWhitespace ?
  			escaped :
  			high < 0 ?
  				// BMP codepoint
  				String.fromCharCode( high + 0x10000 ) :
  				// Supplemental Plane codepoint (surrogate pair)
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  	},

  	// Used for iframes
  	// See setDocument()
  	// Removing the function wrapper causes a "Permission Denied"
  	// error in IE
  	unloadHandler = function() {
  		setDocument();
  	};

  // Optimize for push.apply( _, NodeList )
  try {
  	push.apply(
  		(arr = slice.call( preferredDoc.childNodes )),
  		preferredDoc.childNodes
  	);
  	// Support: Android<4.0
  	// Detect silently failing push.apply
  	arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
  	push = { apply: arr.length ?

  		// Leverage slice if possible
  		function( target, els ) {
  			push_native.apply( target, slice.call(els) );
  		} :

  		// Support: IE<9
  		// Otherwise append directly
  		function( target, els ) {
  			var j = target.length,
  				i = 0;
  			// Can't trust NodeList.length
  			while ( (target[j++] = els[i++]) ) {}
  			target.length = j - 1;
  		}
  	};
  }

  function Sizzle( selector, context, results, seed ) {
  	var match, elem, m, nodeType,
  		// QSA vars
  		i, groups, old, nid, newContext, newSelector;

  	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
  		setDocument( context );
  	}

  	context = context || document;
  	results = results || [];
  	nodeType = context.nodeType;

  	if ( typeof selector !== "string" || !selector ||
  		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  		return results;
  	}

  	if ( !seed && documentIsHTML ) {

  		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
  		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
  			// Speed-up: Sizzle("#ID")
  			if ( (m = match[1]) ) {
  				if ( nodeType === 9 ) {
  					elem = context.getElementById( m );
  					// Check parentNode to catch when Blackberry 4.6 returns
  					// nodes that are no longer in the document (jQuery #6963)
  					if ( elem && elem.parentNode ) {
  						// Handle the case where IE, Opera, and Webkit return items
  						// by name instead of ID
  						if ( elem.id === m ) {
  							results.push( elem );
  							return results;
  						}
  					} else {
  						return results;
  					}
  				} else {
  					// Context is not a document
  					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
  						contains( context, elem ) && elem.id === m ) {
  						results.push( elem );
  						return results;
  					}
  				}

  			// Speed-up: Sizzle("TAG")
  			} else if ( match[2] ) {
  				push.apply( results, context.getElementsByTagName( selector ) );
  				return results;

  			// Speed-up: Sizzle(".CLASS")
  			} else if ( (m = match[3]) && support.getElementsByClassName ) {
  				push.apply( results, context.getElementsByClassName( m ) );
  				return results;
  			}
  		}

  		// QSA path
  		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
  			nid = old = expando;
  			newContext = context;
  			newSelector = nodeType !== 1 && selector;

  			// qSA works strangely on Element-rooted queries
  			// We can work around this by specifying an extra ID on the root
  			// and working up from there (Thanks to Andrew Dupont for the technique)
  			// IE 8 doesn't work on object elements
  			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
  				groups = tokenize( selector );

  				if ( (old = context.getAttribute("id")) ) {
  					nid = old.replace( rescape, "\\$&" );
  				} else {
  					context.setAttribute( "id", nid );
  				}
  				nid = "[id='" + nid + "'] ";

  				i = groups.length;
  				while ( i-- ) {
  					groups[i] = nid + toSelector( groups[i] );
  				}
  				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
  				newSelector = groups.join(",");
  			}

  			if ( newSelector ) {
  				try {
  					push.apply( results,
  						newContext.querySelectorAll( newSelector )
  					);
  					return results;
  				} catch(qsaError) {
  				} finally {
  					if ( !old ) {
  						context.removeAttribute("id");
  					}
  				}
  			}
  		}
  	}

  	// All others
  	return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }

  /**
   * Create key-value caches of limited size
   * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
  	var keys = [];

  	function cache( key, value ) {
  		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
  		if ( keys.push( key + " " ) > Expr.cacheLength ) {
  			// Only keep the most recent entries
  			delete cache[ keys.shift() ];
  		}
  		return (cache[ key + " " ] = value);
  	}
  	return cache;
  }

  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
  	fn[ expando ] = true;
  	return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
  function assert( fn ) {
  	var div = document.createElement("div");

  	try {
  		return !!fn( div );
  	} catch (e) {
  		return false;
  	} finally {
  		// Remove from its parent by default
  		if ( div.parentNode ) {
  			div.parentNode.removeChild( div );
  		}
  		// release memory in IE
  		div = null;
  	}
  }

  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
  	var arr = attrs.split("|"),
  		i = attrs.length;

  	while ( i-- ) {
  		Expr.attrHandle[ arr[i] ] = handler;
  	}
  }

  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
  	var cur = b && a,
  		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
  			( ~b.sourceIndex || MAX_NEGATIVE ) -
  			( ~a.sourceIndex || MAX_NEGATIVE );

  	// Use IE sourceIndex if available on both nodes
  	if ( diff ) {
  		return diff;
  	}

  	// Check if b follows a
  	if ( cur ) {
  		while ( (cur = cur.nextSibling) ) {
  			if ( cur === b ) {
  				return -1;
  			}
  		}
  	}

  	return a ? 1 : -1;
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return name === "input" && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return (name === "input" || name === "button") && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
  	return markFunction(function( argument ) {
  		argument = +argument;
  		return markFunction(function( seed, matches ) {
  			var j,
  				matchIndexes = fn( [], seed.length, argument ),
  				i = matchIndexes.length;

  			// Match elements found at the specified indexes
  			while ( i-- ) {
  				if ( seed[ (j = matchIndexes[i]) ] ) {
  					seed[j] = !(matches[j] = seed[j]);
  				}
  			}
  		});
  	});
  }

  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
  	return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  // Expose support vars for convenience
  support = Sizzle.support = {};

  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
  	// documentElement is verified for cases where it doesn't yet exist
  	// (such as loading iframes in IE - #4833)
  	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  	return documentElement ? documentElement.nodeName !== "HTML" : false;
  };

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
  	var hasCompare, parent,
  		doc = node ? node.ownerDocument || node : preferredDoc;

  	// If no document and documentElement is available, return
  	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
  		return document;
  	}

  	// Set our document
  	document = doc;
  	docElem = doc.documentElement;
  	parent = doc.defaultView;

  	// Support: IE>8
  	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
  	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
  	// IE6-8 do not support the defaultView property so parent will be undefined
  	if ( parent && parent !== parent.top ) {
  		// IE11 does not have attachEvent, so all must suffer
  		if ( parent.addEventListener ) {
  			parent.addEventListener( "unload", unloadHandler, false );
  		} else if ( parent.attachEvent ) {
  			parent.attachEvent( "onunload", unloadHandler );
  		}
  	}

  	/* Support tests
  	---------------------------------------------------------------------- */
  	documentIsHTML = !isXML( doc );

  	/* Attributes
  	---------------------------------------------------------------------- */

  	// Support: IE<8
  	// Verify that getAttribute really returns attributes and not properties
  	// (excepting IE8 booleans)
  	support.attributes = assert(function( div ) {
  		div.className = "i";
  		return !div.getAttribute("className");
  	});

  	/* getElement(s)By*
  	---------------------------------------------------------------------- */

  	// Check if getElementsByTagName("*") returns only elements
  	support.getElementsByTagName = assert(function( div ) {
  		div.appendChild( doc.createComment("") );
  		return !div.getElementsByTagName("*").length;
  	});

  	// Support: IE<9
  	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

  	// Support: IE<10
  	// Check if getElementById returns elements by name
  	// The broken getElementById methods don't pick up programatically-set names,
  	// so use a roundabout getElementsByName test
  	support.getById = assert(function( div ) {
  		docElem.appendChild( div ).id = expando;
  		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
  	});

  	// ID find and filter
  	if ( support.getById ) {
  		Expr.find["ID"] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var m = context.getElementById( id );
  				// Check parentNode to catch when Blackberry 4.6 returns
  				// nodes that are no longer in the document #6963
  				return m && m.parentNode ? [ m ] : [];
  			}
  		};
  		Expr.filter["ID"] = function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				return elem.getAttribute("id") === attrId;
  			};
  		};
  	} else {
  		// Support: IE6/7
  		// getElementById is not reliable as a find shortcut
  		delete Expr.find["ID"];

  		Expr.filter["ID"] =  function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
  				return node && node.value === attrId;
  			};
  		};
  	}

  	// Tag
  	Expr.find["TAG"] = support.getElementsByTagName ?
  		function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else if ( support.qsa ) {
  				return context.querySelectorAll( tag );
  			}
  		} :

  		function( tag, context ) {
  			var elem,
  				tmp = [],
  				i = 0,
  				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
  				results = context.getElementsByTagName( tag );

  			// Filter out possible comments
  			if ( tag === "*" ) {
  				while ( (elem = results[i++]) ) {
  					if ( elem.nodeType === 1 ) {
  						tmp.push( elem );
  					}
  				}

  				return tmp;
  			}
  			return results;
  		};

  	// Class
  	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
  		if ( documentIsHTML ) {
  			return context.getElementsByClassName( className );
  		}
  	};

  	/* QSA/matchesSelector
  	---------------------------------------------------------------------- */

  	// QSA and matchesSelector support

  	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  	rbuggyMatches = [];

  	// qSa(:focus) reports false when true (Chrome 21)
  	// We allow this because of a bug in IE8/9 that throws an error
  	// whenever `document.activeElement` is accessed on an iframe
  	// So, we allow :focus to pass through QSA all the time to avoid the IE error
  	// See http://bugs.jquery.com/ticket/13378
  	rbuggyQSA = [];

  	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert(function( div ) {
  			// Select is set to empty string on purpose
  			// This is to test IE's treatment of not explicitly
  			// setting a boolean content attribute,
  			// since its presence should be enough
  			// http://bugs.jquery.com/ticket/12359
  			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
  				"<select id='" + expando + "-\f]' msallowcapture=''>" +
  				"<option selected=''></option></select>";

  			// Support: IE8, Opera 11-12.16
  			// Nothing should be selected when empty strings follow ^= or $= or *=
  			// The test attribute must be unknown in Opera but "safe" for WinRT
  			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
  			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
  				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
  			}

  			// Support: IE8
  			// Boolean attributes and "value" are not treated correctly
  			if ( !div.querySelectorAll("[selected]").length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
  			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push("~=");
  			}

  			// Webkit/Opera - :checked should return selected option elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			// IE8 throws error here and will not see later tests
  			if ( !div.querySelectorAll(":checked").length ) {
  				rbuggyQSA.push(":checked");
  			}

  			// Support: Safari 8+, iOS 8+
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibing-combinator selector` fails
  			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push(".#.+[+~]");
  			}
  		});

  		assert(function( div ) {
  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			var input = doc.createElement("input");
  			input.setAttribute( "type", "hidden" );
  			div.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE8
  			// Enforce case-sensitivity of name attribute
  			if ( div.querySelectorAll("[name=d]").length ) {
  				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
  			}

  			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
  			// IE8 throws error here and will not see later tests
  			if ( !div.querySelectorAll(":enabled").length ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Opera 10-11 does not throw on post-comma invalid pseudos
  			div.querySelectorAll("*,:x");
  			rbuggyQSA.push(",.*:");
  		});
  	}

  	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
  		docElem.webkitMatchesSelector ||
  		docElem.mozMatchesSelector ||
  		docElem.oMatchesSelector ||
  		docElem.msMatchesSelector) )) ) {

  		assert(function( div ) {
  			// Check to see if it's possible to do matchesSelector
  			// on a disconnected node (IE 9)
  			support.disconnectedMatch = matches.call( div, "div" );

  			// This should fail with an exception
  			// Gecko does not error, returns false instead
  			matches.call( div, "[s!='']:x" );
  			rbuggyMatches.push( "!=", pseudos );
  		});
  	}

  	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
  	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

  	/* Contains
  	---------------------------------------------------------------------- */
  	hasCompare = rnative.test( docElem.compareDocumentPosition );

  	// Element contains another
  	// Purposefully does not implement inclusive descendent
  	// As in, an element does not contain itself
  	contains = hasCompare || rnative.test( docElem.contains ) ?
  		function( a, b ) {
  			var adown = a.nodeType === 9 ? a.documentElement : a,
  				bup = b && b.parentNode;
  			return a === bup || !!( bup && bup.nodeType === 1 && (
  				adown.contains ?
  					adown.contains( bup ) :
  					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  			));
  		} :
  		function( a, b ) {
  			if ( b ) {
  				while ( (b = b.parentNode) ) {
  					if ( b === a ) {
  						return true;
  					}
  				}
  			}
  			return false;
  		};

  	/* Sorting
  	---------------------------------------------------------------------- */

  	// Document order sorting
  	sortOrder = hasCompare ?
  	function( a, b ) {

  		// Flag for duplicate removal
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		// Sort on method existence if only one input has compareDocumentPosition
  		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  		if ( compare ) {
  			return compare;
  		}

  		// Calculate position if both inputs belong to the same document
  		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
  			a.compareDocumentPosition( b ) :

  			// Otherwise we know they are disconnected
  			1;

  		// Disconnected nodes
  		if ( compare & 1 ||
  			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

  			// Choose the first element that is related to our preferred document
  			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
  				return -1;
  			}
  			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
  				return 1;
  			}

  			// Maintain original order
  			return sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;
  		}

  		return compare & 4 ? -1 : 1;
  	} :
  	function( a, b ) {
  		// Exit early if the nodes are identical
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		var cur,
  			i = 0,
  			aup = a.parentNode,
  			bup = b.parentNode,
  			ap = [ a ],
  			bp = [ b ];

  		// Parentless nodes are either documents or disconnected
  		if ( !aup || !bup ) {
  			return a === doc ? -1 :
  				b === doc ? 1 :
  				aup ? -1 :
  				bup ? 1 :
  				sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;

  		// If the nodes are siblings, we can do a quick check
  		} else if ( aup === bup ) {
  			return siblingCheck( a, b );
  		}

  		// Otherwise we need full lists of their ancestors for comparison
  		cur = a;
  		while ( (cur = cur.parentNode) ) {
  			ap.unshift( cur );
  		}
  		cur = b;
  		while ( (cur = cur.parentNode) ) {
  			bp.unshift( cur );
  		}

  		// Walk down the tree looking for a discrepancy
  		while ( ap[i] === bp[i] ) {
  			i++;
  		}

  		return i ?
  			// Do a sibling check if the nodes have a common ancestor
  			siblingCheck( ap[i], bp[i] ) :

  			// Otherwise nodes in our document sort first
  			ap[i] === preferredDoc ? -1 :
  			bp[i] === preferredDoc ? 1 :
  			0;
  	};

  	return doc;
  };

  Sizzle.matches = function( expr, elements ) {
  	return Sizzle( expr, null, null, elements );
  };

  Sizzle.matchesSelector = function( elem, expr ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	// Make sure that attribute selectors are quoted
  	expr = expr.replace( rattributeQuotes, "='$1']" );

  	if ( support.matchesSelector && documentIsHTML &&
  		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
  		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

  		try {
  			var ret = matches.call( elem, expr );

  			// IE 9's matchesSelector returns false on disconnected nodes
  			if ( ret || support.disconnectedMatch ||
  					// As well, disconnected nodes are said to be in a document
  					// fragment in IE 9
  					elem.document && elem.document.nodeType !== 11 ) {
  				return ret;
  			}
  		} catch (e) {}
  	}

  	return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };

  Sizzle.contains = function( context, elem ) {
  	// Set document vars if needed
  	if ( ( context.ownerDocument || context ) !== document ) {
  		setDocument( context );
  	}
  	return contains( context, elem );
  };

  Sizzle.attr = function( elem, name ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	var fn = Expr.attrHandle[ name.toLowerCase() ],
  		// Don't get fooled by Object.prototype properties (jQuery #13807)
  		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  			fn( elem, name, !documentIsHTML ) :
  			undefined;

  	return val !== undefined ?
  		val :
  		support.attributes || !documentIsHTML ?
  			elem.getAttribute( name ) :
  			(val = elem.getAttributeNode(name)) && val.specified ?
  				val.value :
  				null;
  };

  Sizzle.error = function( msg ) {
  	throw new Error( "Syntax error, unrecognized expression: " + msg );
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
  	var elem,
  		duplicates = [],
  		j = 0,
  		i = 0;

  	// Unless we *know* we can detect duplicates, assume their presence
  	hasDuplicate = !support.detectDuplicates;
  	sortInput = !support.sortStable && results.slice( 0 );
  	results.sort( sortOrder );

  	if ( hasDuplicate ) {
  		while ( (elem = results[i++]) ) {
  			if ( elem === results[ i ] ) {
  				j = duplicates.push( i );
  			}
  		}
  		while ( j-- ) {
  			results.splice( duplicates[ j ], 1 );
  		}
  	}

  	// Clear input after sorting to release objects
  	// See https://github.com/jquery/sizzle/pull/225
  	sortInput = null;

  	return results;
  };

  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
  	var node,
  		ret = "",
  		i = 0,
  		nodeType = elem.nodeType;

  	if ( !nodeType ) {
  		// If no nodeType, this is expected to be an array
  		while ( (node = elem[i++]) ) {
  			// Do not traverse comment nodes
  			ret += getText( node );
  		}
  	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
  		// Use textContent for elements
  		// innerText usage removed for consistency of new lines (jQuery #11153)
  		if ( typeof elem.textContent === "string" ) {
  			return elem.textContent;
  		} else {
  			// Traverse its children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				ret += getText( elem );
  			}
  		}
  	} else if ( nodeType === 3 || nodeType === 4 ) {
  		return elem.nodeValue;
  	}
  	// Do not include comment or processing instruction nodes

  	return ret;
  };

  Expr = Sizzle.selectors = {

  	// Can be adjusted by the user
  	cacheLength: 50,

  	createPseudo: markFunction,

  	match: matchExpr,

  	attrHandle: {},

  	find: {},

  	relative: {
  		">": { dir: "parentNode", first: true },
  		" ": { dir: "parentNode" },
  		"+": { dir: "previousSibling", first: true },
  		"~": { dir: "previousSibling" }
  	},

  	preFilter: {
  		"ATTR": function( match ) {
  			match[1] = match[1].replace( runescape, funescape );

  			// Move the given value to match[3] whether quoted or unquoted
  			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

  			if ( match[2] === "~=" ) {
  				match[3] = " " + match[3] + " ";
  			}

  			return match.slice( 0, 4 );
  		},

  		"CHILD": function( match ) {
  			/* matches from matchExpr["CHILD"]
  				1 type (only|nth|...)
  				2 what (child|of-type)
  				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  				4 xn-component of xn+y argument ([+-]?\d*n|)
  				5 sign of xn-component
  				6 x of xn-component
  				7 sign of y-component
  				8 y of y-component
  			*/
  			match[1] = match[1].toLowerCase();

  			if ( match[1].slice( 0, 3 ) === "nth" ) {
  				// nth-* requires argument
  				if ( !match[3] ) {
  					Sizzle.error( match[0] );
  				}

  				// numeric x and y parameters for Expr.filter.CHILD
  				// remember that false/true cast respectively to 0/1
  				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
  				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

  			// other types prohibit arguments
  			} else if ( match[3] ) {
  				Sizzle.error( match[0] );
  			}

  			return match;
  		},

  		"PSEUDO": function( match ) {
  			var excess,
  				unquoted = !match[6] && match[2];

  			if ( matchExpr["CHILD"].test( match[0] ) ) {
  				return null;
  			}

  			// Accept quoted arguments as-is
  			if ( match[3] ) {
  				match[2] = match[4] || match[5] || "";

  			// Strip excess characters from unquoted arguments
  			} else if ( unquoted && rpseudo.test( unquoted ) &&
  				// Get excess from tokenize (recursively)
  				(excess = tokenize( unquoted, true )) &&
  				// advance to the next closing parenthesis
  				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

  				// excess is a negative index
  				match[0] = match[0].slice( 0, excess );
  				match[2] = unquoted.slice( 0, excess );
  			}

  			// Return only captures needed by the pseudo filter method (type and argument)
  			return match.slice( 0, 3 );
  		}
  	},

  	filter: {

  		"TAG": function( nodeNameSelector ) {
  			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  			return nodeNameSelector === "*" ?
  				function() { return true; } :
  				function( elem ) {
  					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
  				};
  		},

  		"CLASS": function( className ) {
  			var pattern = classCache[ className + " " ];

  			return pattern ||
  				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
  				classCache( className, function( elem ) {
  					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
  				});
  		},

  		"ATTR": function( name, operator, check ) {
  			return function( elem ) {
  				var result = Sizzle.attr( elem, name );

  				if ( result == null ) {
  					return operator === "!=";
  				}
  				if ( !operator ) {
  					return true;
  				}

  				result += "";

  				return operator === "=" ? result === check :
  					operator === "!=" ? result !== check :
  					operator === "^=" ? check && result.indexOf( check ) === 0 :
  					operator === "*=" ? check && result.indexOf( check ) > -1 :
  					operator === "$=" ? check && result.slice( -check.length ) === check :
  					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
  					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
  					false;
  			};
  		},

  		"CHILD": function( type, what, argument, first, last ) {
  			var simple = type.slice( 0, 3 ) !== "nth",
  				forward = type.slice( -4 ) !== "last",
  				ofType = what === "of-type";

  			return first === 1 && last === 0 ?

  				// Shortcut for :nth-*(n)
  				function( elem ) {
  					return !!elem.parentNode;
  				} :

  				function( elem, context, xml ) {
  					var cache, outerCache, node, diff, nodeIndex, start,
  						dir = simple !== forward ? "nextSibling" : "previousSibling",
  						parent = elem.parentNode,
  						name = ofType && elem.nodeName.toLowerCase(),
  						useCache = !xml && !ofType;

  					if ( parent ) {

  						// :(first|last|only)-(child|of-type)
  						if ( simple ) {
  							while ( dir ) {
  								node = elem;
  								while ( (node = node[ dir ]) ) {
  									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
  										return false;
  									}
  								}
  								// Reverse direction for :only-* (if we haven't yet done so)
  								start = dir = type === "only" && !start && "nextSibling";
  							}
  							return true;
  						}

  						start = [ forward ? parent.firstChild : parent.lastChild ];

  						// non-xml :nth-child(...) stores cache data on `parent`
  						if ( forward && useCache ) {
  							// Seek `elem` from a previously-cached index
  							outerCache = parent[ expando ] || (parent[ expando ] = {});
  							cache = outerCache[ type ] || [];
  							nodeIndex = cache[0] === dirruns && cache[1];
  							diff = cache[0] === dirruns && cache[2];
  							node = nodeIndex && parent.childNodes[ nodeIndex ];

  							while ( (node = ++nodeIndex && node && node[ dir ] ||

  								// Fallback to seeking `elem` from the start
  								(diff = nodeIndex = 0) || start.pop()) ) {

  								// When found, cache indexes on `parent` and break
  								if ( node.nodeType === 1 && ++diff && node === elem ) {
  									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
  									break;
  								}
  							}

  						// Use previously-cached element index if available
  						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
  							diff = cache[1];

  						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
  						} else {
  							// Use the same loop as above to seek `elem` from the start
  							while ( (node = ++nodeIndex && node && node[ dir ] ||
  								(diff = nodeIndex = 0) || start.pop()) ) {

  								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
  									// Cache the index of each encountered element
  									if ( useCache ) {
  										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
  									}

  									if ( node === elem ) {
  										break;
  									}
  								}
  							}
  						}

  						// Incorporate the offset, then check against cycle size
  						diff -= last;
  						return diff === first || ( diff % first === 0 && diff / first >= 0 );
  					}
  				};
  		},

  		"PSEUDO": function( pseudo, argument ) {
  			// pseudo-class names are case-insensitive
  			// http://www.w3.org/TR/selectors/#pseudo-classes
  			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  			// Remember that setFilters inherits from pseudos
  			var args,
  				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  					Sizzle.error( "unsupported pseudo: " + pseudo );

  			// The user may use createPseudo to indicate that
  			// arguments are needed to create the filter function
  			// just as Sizzle does
  			if ( fn[ expando ] ) {
  				return fn( argument );
  			}

  			// But maintain support for old signatures
  			if ( fn.length > 1 ) {
  				args = [ pseudo, pseudo, "", argument ];
  				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  					markFunction(function( seed, matches ) {
  						var idx,
  							matched = fn( seed, argument ),
  							i = matched.length;
  						while ( i-- ) {
  							idx = indexOf( seed, matched[i] );
  							seed[ idx ] = !( matches[ idx ] = matched[i] );
  						}
  					}) :
  					function( elem ) {
  						return fn( elem, 0, args );
  					};
  			}

  			return fn;
  		}
  	},

  	pseudos: {
  		// Potentially complex pseudos
  		"not": markFunction(function( selector ) {
  			// Trim the selector passed to compile
  			// to avoid treating leading and trailing
  			// spaces as combinators
  			var input = [],
  				results = [],
  				matcher = compile( selector.replace( rtrim, "$1" ) );

  			return matcher[ expando ] ?
  				markFunction(function( seed, matches, context, xml ) {
  					var elem,
  						unmatched = matcher( seed, null, xml, [] ),
  						i = seed.length;

  					// Match elements unmatched by `matcher`
  					while ( i-- ) {
  						if ( (elem = unmatched[i]) ) {
  							seed[i] = !(matches[i] = elem);
  						}
  					}
  				}) :
  				function( elem, context, xml ) {
  					input[0] = elem;
  					matcher( input, null, xml, results );
  					// Don't keep the element (issue #299)
  					input[0] = null;
  					return !results.pop();
  				};
  		}),

  		"has": markFunction(function( selector ) {
  			return function( elem ) {
  				return Sizzle( selector, elem ).length > 0;
  			};
  		}),

  		"contains": markFunction(function( text ) {
  			text = text.replace( runescape, funescape );
  			return function( elem ) {
  				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
  			};
  		}),

  		// "Whether an element is represented by a :lang() selector
  		// is based solely on the element's language value
  		// being equal to the identifier C,
  		// or beginning with the identifier C immediately followed by "-".
  		// The matching of C against the element's language value is performed case-insensitively.
  		// The identifier C does not have to be a valid language name."
  		// http://www.w3.org/TR/selectors/#lang-pseudo
  		"lang": markFunction( function( lang ) {
  			// lang value must be a valid identifier
  			if ( !ridentifier.test(lang || "") ) {
  				Sizzle.error( "unsupported lang: " + lang );
  			}
  			lang = lang.replace( runescape, funescape ).toLowerCase();
  			return function( elem ) {
  				var elemLang;
  				do {
  					if ( (elemLang = documentIsHTML ?
  						elem.lang :
  						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

  						elemLang = elemLang.toLowerCase();
  						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  					}
  				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
  				return false;
  			};
  		}),

  		// Miscellaneous
  		"target": function( elem ) {
  			var hash = window.location && window.location.hash;
  			return hash && hash.slice( 1 ) === elem.id;
  		},

  		"root": function( elem ) {
  			return elem === docElem;
  		},

  		"focus": function( elem ) {
  			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
  		},

  		// Boolean properties
  		"enabled": function( elem ) {
  			return elem.disabled === false;
  		},

  		"disabled": function( elem ) {
  			return elem.disabled === true;
  		},

  		"checked": function( elem ) {
  			// In CSS3, :checked should return both checked and selected elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			var nodeName = elem.nodeName.toLowerCase();
  			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
  		},

  		"selected": function( elem ) {
  			// Accessing this property makes selected-by-default
  			// options in Safari work properly
  			if ( elem.parentNode ) {
  				elem.parentNode.selectedIndex;
  			}

  			return elem.selected === true;
  		},

  		// Contents
  		"empty": function( elem ) {
  			// http://www.w3.org/TR/selectors/#empty-pseudo
  			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  			//   but not by others (comment: 8; processing instruction: 7; etc.)
  			// nodeType < 6 works because attributes (2) do not appear as children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				if ( elem.nodeType < 6 ) {
  					return false;
  				}
  			}
  			return true;
  		},

  		"parent": function( elem ) {
  			return !Expr.pseudos["empty"]( elem );
  		},

  		// Element/input types
  		"header": function( elem ) {
  			return rheader.test( elem.nodeName );
  		},

  		"input": function( elem ) {
  			return rinputs.test( elem.nodeName );
  		},

  		"button": function( elem ) {
  			var name = elem.nodeName.toLowerCase();
  			return name === "input" && elem.type === "button" || name === "button";
  		},

  		"text": function( elem ) {
  			var attr;
  			return elem.nodeName.toLowerCase() === "input" &&
  				elem.type === "text" &&

  				// Support: IE<8
  				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
  				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
  		},

  		// Position-in-collection
  		"first": createPositionalPseudo(function() {
  			return [ 0 ];
  		}),

  		"last": createPositionalPseudo(function( matchIndexes, length ) {
  			return [ length - 1 ];
  		}),

  		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			return [ argument < 0 ? argument + length : argument ];
  		}),

  		"even": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 0;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"odd": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 1;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; --i >= 0; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; ++i < length; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		})
  	}
  };

  Expr.pseudos["nth"] = Expr.pseudos["eq"];

  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  	Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
  	Expr.pseudos[ i ] = createButtonPseudo( i );
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  	var matched, match, tokens, type,
  		soFar, groups, preFilters,
  		cached = tokenCache[ selector + " " ];

  	if ( cached ) {
  		return parseOnly ? 0 : cached.slice( 0 );
  	}

  	soFar = selector;
  	groups = [];
  	preFilters = Expr.preFilter;

  	while ( soFar ) {

  		// Comma and first run
  		if ( !matched || (match = rcomma.exec( soFar )) ) {
  			if ( match ) {
  				// Don't consume trailing commas as valid
  				soFar = soFar.slice( match[0].length ) || soFar;
  			}
  			groups.push( (tokens = []) );
  		}

  		matched = false;

  		// Combinators
  		if ( (match = rcombinators.exec( soFar )) ) {
  			matched = match.shift();
  			tokens.push({
  				value: matched,
  				// Cast descendant combinators to space
  				type: match[0].replace( rtrim, " " )
  			});
  			soFar = soFar.slice( matched.length );
  		}

  		// Filters
  		for ( type in Expr.filter ) {
  			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
  				(match = preFilters[ type ]( match ))) ) {
  				matched = match.shift();
  				tokens.push({
  					value: matched,
  					type: type,
  					matches: match
  				});
  				soFar = soFar.slice( matched.length );
  			}
  		}

  		if ( !matched ) {
  			break;
  		}
  	}

  	// Return the length of the invalid excess
  	// if we're just parsing
  	// Otherwise, throw an error or return tokens
  	return parseOnly ?
  		soFar.length :
  		soFar ?
  			Sizzle.error( selector ) :
  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  };

  function toSelector( tokens ) {
  	var i = 0,
  		len = tokens.length,
  		selector = "";
  	for ( ; i < len; i++ ) {
  		selector += tokens[i].value;
  	}
  	return selector;
  }

  function addCombinator( matcher, combinator, base ) {
  	var dir = combinator.dir,
  		checkNonElements = base && dir === "parentNode",
  		doneName = done++;

  	return combinator.first ?
  		// Check against closest ancestor/preceding element
  		function( elem, context, xml ) {
  			while ( (elem = elem[ dir ]) ) {
  				if ( elem.nodeType === 1 || checkNonElements ) {
  					return matcher( elem, context, xml );
  				}
  			}
  		} :

  		// Check against all ancestor/preceding elements
  		function( elem, context, xml ) {
  			var oldCache, outerCache,
  				newCache = [ dirruns, doneName ];

  			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
  			if ( xml ) {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						if ( matcher( elem, context, xml ) ) {
  							return true;
  						}
  					}
  				}
  			} else {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						outerCache = elem[ expando ] || (elem[ expando ] = {});
  						if ( (oldCache = outerCache[ dir ]) &&
  							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  							// Assign to newCache so results back-propagate to previous elements
  							return (newCache[ 2 ] = oldCache[ 2 ]);
  						} else {
  							// Reuse newcache so results back-propagate to previous elements
  							outerCache[ dir ] = newCache;

  							// A match means we're done; a fail means we have to keep checking
  							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
  								return true;
  							}
  						}
  					}
  				}
  			}
  		};
  }

  function elementMatcher( matchers ) {
  	return matchers.length > 1 ?
  		function( elem, context, xml ) {
  			var i = matchers.length;
  			while ( i-- ) {
  				if ( !matchers[i]( elem, context, xml ) ) {
  					return false;
  				}
  			}
  			return true;
  		} :
  		matchers[0];
  }

  function multipleContexts( selector, contexts, results ) {
  	var i = 0,
  		len = contexts.length;
  	for ( ; i < len; i++ ) {
  		Sizzle( selector, contexts[i], results );
  	}
  	return results;
  }

  function condense( unmatched, map, filter, context, xml ) {
  	var elem,
  		newUnmatched = [],
  		i = 0,
  		len = unmatched.length,
  		mapped = map != null;

  	for ( ; i < len; i++ ) {
  		if ( (elem = unmatched[i]) ) {
  			if ( !filter || filter( elem, context, xml ) ) {
  				newUnmatched.push( elem );
  				if ( mapped ) {
  					map.push( i );
  				}
  			}
  		}
  	}

  	return newUnmatched;
  }

  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  	if ( postFilter && !postFilter[ expando ] ) {
  		postFilter = setMatcher( postFilter );
  	}
  	if ( postFinder && !postFinder[ expando ] ) {
  		postFinder = setMatcher( postFinder, postSelector );
  	}
  	return markFunction(function( seed, results, context, xml ) {
  		var temp, i, elem,
  			preMap = [],
  			postMap = [],
  			preexisting = results.length,

  			// Get initial elements from seed or context
  			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

  			// Prefilter to get matcher input, preserving a map for seed-results synchronization
  			matcherIn = preFilter && ( seed || !selector ) ?
  				condense( elems, preMap, preFilter, context, xml ) :
  				elems,

  			matcherOut = matcher ?
  				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
  				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results :
  				matcherIn;

  		// Find primary matches
  		if ( matcher ) {
  			matcher( matcherIn, matcherOut, context, xml );
  		}

  		// Apply postFilter
  		if ( postFilter ) {
  			temp = condense( matcherOut, postMap );
  			postFilter( temp, [], context, xml );

  			// Un-match failing elements by moving them back to matcherIn
  			i = temp.length;
  			while ( i-- ) {
  				if ( (elem = temp[i]) ) {
  					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
  				}
  			}
  		}

  		if ( seed ) {
  			if ( postFinder || preFilter ) {
  				if ( postFinder ) {
  					// Get the final matcherOut by condensing this intermediate into postFinder contexts
  					temp = [];
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( (elem = matcherOut[i]) ) {
  							// Restore matcherIn since elem is not yet a final match
  							temp.push( (matcherIn[i] = elem) );
  						}
  					}
  					postFinder( null, (matcherOut = []), temp, xml );
  				}

  				// Move matched elements from seed to results to keep them synchronized
  				i = matcherOut.length;
  				while ( i-- ) {
  					if ( (elem = matcherOut[i]) &&
  						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

  						seed[temp] = !(results[temp] = elem);
  					}
  				}
  			}

  		// Add elements to results, through postFinder if defined
  		} else {
  			matcherOut = condense(
  				matcherOut === results ?
  					matcherOut.splice( preexisting, matcherOut.length ) :
  					matcherOut
  			);
  			if ( postFinder ) {
  				postFinder( null, results, matcherOut, xml );
  			} else {
  				push.apply( results, matcherOut );
  			}
  		}
  	});
  }

  function matcherFromTokens( tokens ) {
  	var checkContext, matcher, j,
  		len = tokens.length,
  		leadingRelative = Expr.relative[ tokens[0].type ],
  		implicitRelative = leadingRelative || Expr.relative[" "],
  		i = leadingRelative ? 1 : 0,

  		// The foundational matcher ensures that elements are reachable from top-level context(s)
  		matchContext = addCombinator( function( elem ) {
  			return elem === checkContext;
  		}, implicitRelative, true ),
  		matchAnyContext = addCombinator( function( elem ) {
  			return indexOf( checkContext, elem ) > -1;
  		}, implicitRelative, true ),
  		matchers = [ function( elem, context, xml ) {
  			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
  				(checkContext = context).nodeType ?
  					matchContext( elem, context, xml ) :
  					matchAnyContext( elem, context, xml ) );
  			// Avoid hanging onto element (issue #299)
  			checkContext = null;
  			return ret;
  		} ];

  	for ( ; i < len; i++ ) {
  		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
  			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
  		} else {
  			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

  			// Return special upon seeing a positional matcher
  			if ( matcher[ expando ] ) {
  				// Find the next relative operator (if any) for proper handling
  				j = ++i;
  				for ( ; j < len; j++ ) {
  					if ( Expr.relative[ tokens[j].type ] ) {
  						break;
  					}
  				}
  				return setMatcher(
  					i > 1 && elementMatcher( matchers ),
  					i > 1 && toSelector(
  						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
  					).replace( rtrim, "$1" ),
  					matcher,
  					i < j && matcherFromTokens( tokens.slice( i, j ) ),
  					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
  					j < len && toSelector( tokens )
  				);
  			}
  			matchers.push( matcher );
  		}
  	}

  	return elementMatcher( matchers );
  }

  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  	var bySet = setMatchers.length > 0,
  		byElement = elementMatchers.length > 0,
  		superMatcher = function( seed, context, xml, results, outermost ) {
  			var elem, j, matcher,
  				matchedCount = 0,
  				i = "0",
  				unmatched = seed && [],
  				setMatched = [],
  				contextBackup = outermostContext,
  				// We must always have either seed elements or outermost context
  				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
  				// Use integer dirruns iff this is the outermost matcher
  				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
  				len = elems.length;

  			if ( outermost ) {
  				outermostContext = context !== document && context;
  			}

  			// Add elements passing elementMatchers directly to results
  			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
  			// Support: IE<9, Safari
  			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
  			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
  				if ( byElement && elem ) {
  					j = 0;
  					while ( (matcher = elementMatchers[j++]) ) {
  						if ( matcher( elem, context, xml ) ) {
  							results.push( elem );
  							break;
  						}
  					}
  					if ( outermost ) {
  						dirruns = dirrunsUnique;
  					}
  				}

  				// Track unmatched elements for set filters
  				if ( bySet ) {
  					// They will have gone through all possible matchers
  					if ( (elem = !matcher && elem) ) {
  						matchedCount--;
  					}

  					// Lengthen the array for every element, matched or not
  					if ( seed ) {
  						unmatched.push( elem );
  					}
  				}
  			}

  			// Apply set filters to unmatched elements
  			matchedCount += i;
  			if ( bySet && i !== matchedCount ) {
  				j = 0;
  				while ( (matcher = setMatchers[j++]) ) {
  					matcher( unmatched, setMatched, context, xml );
  				}

  				if ( seed ) {
  					// Reintegrate element matches to eliminate the need for sorting
  					if ( matchedCount > 0 ) {
  						while ( i-- ) {
  							if ( !(unmatched[i] || setMatched[i]) ) {
  								setMatched[i] = pop.call( results );
  							}
  						}
  					}

  					// Discard index placeholder values to get only actual matches
  					setMatched = condense( setMatched );
  				}

  				// Add matches to results
  				push.apply( results, setMatched );

  				// Seedless set matches succeeding multiple successful matchers stipulate sorting
  				if ( outermost && !seed && setMatched.length > 0 &&
  					( matchedCount + setMatchers.length ) > 1 ) {

  					Sizzle.uniqueSort( results );
  				}
  			}

  			// Override manipulation of globals by nested matchers
  			if ( outermost ) {
  				dirruns = dirrunsUnique;
  				outermostContext = contextBackup;
  			}

  			return unmatched;
  		};

  	return bySet ?
  		markFunction( superMatcher ) :
  		superMatcher;
  }

  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  	var i,
  		setMatchers = [],
  		elementMatchers = [],
  		cached = compilerCache[ selector + " " ];

  	if ( !cached ) {
  		// Generate a function of recursive functions that can be used to check each element
  		if ( !match ) {
  			match = tokenize( selector );
  		}
  		i = match.length;
  		while ( i-- ) {
  			cached = matcherFromTokens( match[i] );
  			if ( cached[ expando ] ) {
  				setMatchers.push( cached );
  			} else {
  				elementMatchers.push( cached );
  			}
  		}

  		// Cache the compiled function
  		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  		// Save selector and tokenization
  		cached.selector = selector;
  	}
  	return cached;
  };

  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
  	var i, tokens, token, type, find,
  		compiled = typeof selector === "function" && selector,
  		match = !seed && tokenize( (selector = compiled.selector || selector) );

  	results = results || [];

  	// Try to minimize operations if there is no seed and only one group
  	if ( match.length === 1 ) {

  		// Take a shortcut and set the context if the root selector is an ID
  		tokens = match[0] = match[0].slice( 0 );
  		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
  				support.getById && context.nodeType === 9 && documentIsHTML &&
  				Expr.relative[ tokens[1].type ] ) {

  			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
  			if ( !context ) {
  				return results;

  			// Precompiled matchers will still verify ancestry, so step up a level
  			} else if ( compiled ) {
  				context = context.parentNode;
  			}

  			selector = selector.slice( tokens.shift().value.length );
  		}

  		// Fetch a seed set for right-to-left matching
  		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
  		while ( i-- ) {
  			token = tokens[i];

  			// Abort if we hit a combinator
  			if ( Expr.relative[ (type = token.type) ] ) {
  				break;
  			}
  			if ( (find = Expr.find[ type ]) ) {
  				// Search, expanding context for leading sibling combinators
  				if ( (seed = find(
  					token.matches[0].replace( runescape, funescape ),
  					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
  				)) ) {

  					// If seed is empty or no tokens remain, we can return early
  					tokens.splice( i, 1 );
  					selector = seed.length && toSelector( tokens );
  					if ( !selector ) {
  						push.apply( results, seed );
  						return results;
  					}

  					break;
  				}
  			}
  		}
  	}

  	// Compile and execute a filtering function if one is not provided
  	// Provide `match` to avoid retokenization if we modified the selector above
  	( compiled || compile( selector, match ) )(
  		seed,
  		context,
  		!documentIsHTML,
  		results,
  		rsibling.test( selector ) && testContext( context.parentNode ) || context
  	);
  	return results;
  };

  // One-time assignments

  // Sort stability
  support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;

  // Initialize against the default document
  setDocument();

  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert(function( div1 ) {
  	// Should return 1, but returns 4 (following)
  	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
  });

  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert(function( div ) {
  	div.innerHTML = "<a href='#'></a>";
  	return div.firstChild.getAttribute("href") === "#" ;
  }) ) {
  	addHandle( "type|href|height|width", function( elem, name, isXML ) {
  		if ( !isXML ) {
  			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
  		}
  	});
  }

  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert(function( div ) {
  	div.innerHTML = "<input/>";
  	div.firstChild.setAttribute( "value", "" );
  	return div.firstChild.getAttribute( "value" ) === "";
  }) ) {
  	addHandle( "value", function( elem, name, isXML ) {
  		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
  			return elem.defaultValue;
  		}
  	});
  }

  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert(function( div ) {
  	return div.getAttribute("disabled") == null;
  }) ) {
  	addHandle( booleans, function( elem, name, isXML ) {
  		var val;
  		if ( !isXML ) {
  			return elem[ name ] === true ? name.toLowerCase() :
  					(val = elem.getAttributeNode( name )) && val.specified ?
  					val.value :
  				null;
  		}
  	});
  }

  return Sizzle;

  })( window );



  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;



  var rneedsContext = jQuery.expr.match.needsContext;

  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



  var risSimple = /^.[^:#\[\.,]*$/;

  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
  	if ( jQuery.isFunction( qualifier ) ) {
  		return jQuery.grep( elements, function( elem, i ) {
  			/* jshint -W018 */
  			return !!qualifier.call( elem, i, elem ) !== not;
  		});

  	}

  	if ( qualifier.nodeType ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( elem === qualifier ) !== not;
  		});

  	}

  	if ( typeof qualifier === "string" ) {
  		if ( risSimple.test( qualifier ) ) {
  			return jQuery.filter( qualifier, elements, not );
  		}

  		qualifier = jQuery.filter( qualifier, elements );
  	}

  	return jQuery.grep( elements, function( elem ) {
  		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
  	});
  }

  jQuery.filter = function( expr, elems, not ) {
  	var elem = elems[ 0 ];

  	if ( not ) {
  		expr = ":not(" + expr + ")";
  	}

  	return elems.length === 1 && elem.nodeType === 1 ?
  		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
  		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  			return elem.nodeType === 1;
  		}));
  };

  jQuery.fn.extend({
  	find: function( selector ) {
  		var i,
  			len = this.length,
  			ret = [],
  			self = this;

  		if ( typeof selector !== "string" ) {
  			return this.pushStack( jQuery( selector ).filter(function() {
  				for ( i = 0; i < len; i++ ) {
  					if ( jQuery.contains( self[ i ], this ) ) {
  						return true;
  					}
  				}
  			}) );
  		}

  		for ( i = 0; i < len; i++ ) {
  			jQuery.find( selector, self[ i ], ret );
  		}

  		// Needed because $( selector, context ) becomes $( context ).find( selector )
  		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
  		ret.selector = this.selector ? this.selector + " " + selector : selector;
  		return ret;
  	},
  	filter: function( selector ) {
  		return this.pushStack( winnow(this, selector || [], false) );
  	},
  	not: function( selector ) {
  		return this.pushStack( winnow(this, selector || [], true) );
  	},
  	is: function( selector ) {
  		return !!winnow(
  			this,

  			// If this is a positional/relative selector, check membership in the returned set
  			// so $("p:first").is("p:last") won't return true for a doc with two "p".
  			typeof selector === "string" && rneedsContext.test( selector ) ?
  				jQuery( selector ) :
  				selector || [],
  			false
  		).length;
  	}
  });


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

  	// A simple way to check for HTML strings
  	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  	// Strict HTML recognition (#11290: must start with <)
  	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

  	init = jQuery.fn.init = function( selector, context ) {
  		var match, elem;

  		// HANDLE: $(""), $(null), $(undefined), $(false)
  		if ( !selector ) {
  			return this;
  		}

  		// Handle HTML strings
  		if ( typeof selector === "string" ) {
  			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
  				// Assume that strings that start and end with <> are HTML and skip the regex check
  				match = [ null, selector, null ];

  			} else {
  				match = rquickExpr.exec( selector );
  			}

  			// Match html or make sure no context is specified for #id
  			if ( match && (match[1] || !context) ) {

  				// HANDLE: $(html) -> $(array)
  				if ( match[1] ) {
  					context = context instanceof jQuery ? context[0] : context;

  					// Option to run scripts is true for back-compat
  					// Intentionally let the error be thrown if parseHTML is not present
  					jQuery.merge( this, jQuery.parseHTML(
  						match[1],
  						context && context.nodeType ? context.ownerDocument || context : document,
  						true
  					) );

  					// HANDLE: $(html, props)
  					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
  						for ( match in context ) {
  							// Properties of context are called as methods if possible
  							if ( jQuery.isFunction( this[ match ] ) ) {
  								this[ match ]( context[ match ] );

  							// ...and otherwise set as attributes
  							} else {
  								this.attr( match, context[ match ] );
  							}
  						}
  					}

  					return this;

  				// HANDLE: $(#id)
  				} else {
  					elem = document.getElementById( match[2] );

  					// Support: Blackberry 4.6
  					// gEBID returns nodes no longer in the document (#6963)
  					if ( elem && elem.parentNode ) {
  						// Inject the element directly into the jQuery object
  						this.length = 1;
  						this[0] = elem;
  					}

  					this.context = document;
  					this.selector = selector;
  					return this;
  				}

  			// HANDLE: $(expr, $(...))
  			} else if ( !context || context.jquery ) {
  				return ( context || rootjQuery ).find( selector );

  			// HANDLE: $(expr, context)
  			// (which is just equivalent to: $(context).find(expr)
  			} else {
  				return this.constructor( context ).find( selector );
  			}

  		// HANDLE: $(DOMElement)
  		} else if ( selector.nodeType ) {
  			this.context = this[0] = selector;
  			this.length = 1;
  			return this;

  		// HANDLE: $(function)
  		// Shortcut for document ready
  		} else if ( jQuery.isFunction( selector ) ) {
  			return typeof rootjQuery.ready !== "undefined" ?
  				rootjQuery.ready( selector ) :
  				// Execute immediately if ready is not present
  				selector( jQuery );
  		}

  		if ( selector.selector !== undefined ) {
  			this.selector = selector.selector;
  			this.context = selector.context;
  		}

  		return jQuery.makeArray( selector, this );
  	};

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery( document );


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
  	// Methods guaranteed to produce a unique set when starting from a unique set
  	guaranteedUnique = {
  		children: true,
  		contents: true,
  		next: true,
  		prev: true
  	};

  jQuery.extend({
  	dir: function( elem, dir, until ) {
  		var matched = [],
  			truncate = until !== undefined;

  		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
  			if ( elem.nodeType === 1 ) {
  				if ( truncate && jQuery( elem ).is( until ) ) {
  					break;
  				}
  				matched.push( elem );
  			}
  		}
  		return matched;
  	},

  	sibling: function( n, elem ) {
  		var matched = [];

  		for ( ; n; n = n.nextSibling ) {
  			if ( n.nodeType === 1 && n !== elem ) {
  				matched.push( n );
  			}
  		}

  		return matched;
  	}
  });

  jQuery.fn.extend({
  	has: function( target ) {
  		var targets = jQuery( target, this ),
  			l = targets.length;

  		return this.filter(function() {
  			var i = 0;
  			for ( ; i < l; i++ ) {
  				if ( jQuery.contains( this, targets[i] ) ) {
  					return true;
  				}
  			}
  		});
  	},

  	closest: function( selectors, context ) {
  		var cur,
  			i = 0,
  			l = this.length,
  			matched = [],
  			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
  				jQuery( selectors, context || this.context ) :
  				0;

  		for ( ; i < l; i++ ) {
  			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
  				// Always skip document fragments
  				if ( cur.nodeType < 11 && (pos ?
  					pos.index(cur) > -1 :

  					// Don't pass non-elements to Sizzle
  					cur.nodeType === 1 &&
  						jQuery.find.matchesSelector(cur, selectors)) ) {

  					matched.push( cur );
  					break;
  				}
  			}
  		}

  		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
  	},

  	// Determine the position of an element within the set
  	index: function( elem ) {

  		// No argument, return index in parent
  		if ( !elem ) {
  			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  		}

  		// Index in selector
  		if ( typeof elem === "string" ) {
  			return indexOf.call( jQuery( elem ), this[ 0 ] );
  		}

  		// Locate the position of the desired element
  		return indexOf.call( this,

  			// If it receives a jQuery object, the first element is used
  			elem.jquery ? elem[ 0 ] : elem
  		);
  	},

  	add: function( selector, context ) {
  		return this.pushStack(
  			jQuery.unique(
  				jQuery.merge( this.get(), jQuery( selector, context ) )
  			)
  		);
  	},

  	addBack: function( selector ) {
  		return this.add( selector == null ?
  			this.prevObject : this.prevObject.filter(selector)
  		);
  	}
  });

  function sibling( cur, dir ) {
  	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
  	return cur;
  }

  jQuery.each({
  	parent: function( elem ) {
  		var parent = elem.parentNode;
  		return parent && parent.nodeType !== 11 ? parent : null;
  	},
  	parents: function( elem ) {
  		return jQuery.dir( elem, "parentNode" );
  	},
  	parentsUntil: function( elem, i, until ) {
  		return jQuery.dir( elem, "parentNode", until );
  	},
  	next: function( elem ) {
  		return sibling( elem, "nextSibling" );
  	},
  	prev: function( elem ) {
  		return sibling( elem, "previousSibling" );
  	},
  	nextAll: function( elem ) {
  		return jQuery.dir( elem, "nextSibling" );
  	},
  	prevAll: function( elem ) {
  		return jQuery.dir( elem, "previousSibling" );
  	},
  	nextUntil: function( elem, i, until ) {
  		return jQuery.dir( elem, "nextSibling", until );
  	},
  	prevUntil: function( elem, i, until ) {
  		return jQuery.dir( elem, "previousSibling", until );
  	},
  	siblings: function( elem ) {
  		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
  	},
  	children: function( elem ) {
  		return jQuery.sibling( elem.firstChild );
  	},
  	contents: function( elem ) {
  		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
  	}
  }, function( name, fn ) {
  	jQuery.fn[ name ] = function( until, selector ) {
  		var matched = jQuery.map( this, fn, until );

  		if ( name.slice( -5 ) !== "Until" ) {
  			selector = until;
  		}

  		if ( selector && typeof selector === "string" ) {
  			matched = jQuery.filter( selector, matched );
  		}

  		if ( this.length > 1 ) {
  			// Remove duplicates
  			if ( !guaranteedUnique[ name ] ) {
  				jQuery.unique( matched );
  			}

  			// Reverse order for parents* and prev-derivatives
  			if ( rparentsprev.test( name ) ) {
  				matched.reverse();
  			}
  		}

  		return this.pushStack( matched );
  	};
  });
  var rnotwhite = (/\S+/g);



  // String to Object options format cache
  var optionsCache = {};

  // Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
  	var object = optionsCache[ options ] = {};
  	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
  		object[ flag ] = true;
  	});
  	return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {

  	// Convert options from String-formatted to Object-formatted if needed
  	// (we check in cache first)
  	options = typeof options === "string" ?
  		( optionsCache[ options ] || createOptions( options ) ) :
  		jQuery.extend( {}, options );

  	var // Last fire value (for non-forgettable lists)
  		memory,
  		// Flag to know if list was already fired
  		fired,
  		// Flag to know if list is currently firing
  		firing,
  		// First callback to fire (used internally by add and fireWith)
  		firingStart,
  		// End of the loop when firing
  		firingLength,
  		// Index of currently firing callback (modified by remove if needed)
  		firingIndex,
  		// Actual callback list
  		list = [],
  		// Stack of fire calls for repeatable lists
  		stack = !options.once && [],
  		// Fire callbacks
  		fire = function( data ) {
  			memory = options.memory && data;
  			fired = true;
  			firingIndex = firingStart || 0;
  			firingStart = 0;
  			firingLength = list.length;
  			firing = true;
  			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
  				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
  					memory = false; // To prevent further calls using add
  					break;
  				}
  			}
  			firing = false;
  			if ( list ) {
  				if ( stack ) {
  					if ( stack.length ) {
  						fire( stack.shift() );
  					}
  				} else if ( memory ) {
  					list = [];
  				} else {
  					self.disable();
  				}
  			}
  		},
  		// Actual Callbacks object
  		self = {
  			// Add a callback or a collection of callbacks to the list
  			add: function() {
  				if ( list ) {
  					// First, we save the current length
  					var start = list.length;
  					(function add( args ) {
  						jQuery.each( args, function( _, arg ) {
  							var type = jQuery.type( arg );
  							if ( type === "function" ) {
  								if ( !options.unique || !self.has( arg ) ) {
  									list.push( arg );
  								}
  							} else if ( arg && arg.length && type !== "string" ) {
  								// Inspect recursively
  								add( arg );
  							}
  						});
  					})( arguments );
  					// Do we need to add the callbacks to the
  					// current firing batch?
  					if ( firing ) {
  						firingLength = list.length;
  					// With memory, if we're not firing then
  					// we should call right away
  					} else if ( memory ) {
  						firingStart = start;
  						fire( memory );
  					}
  				}
  				return this;
  			},
  			// Remove a callback from the list
  			remove: function() {
  				if ( list ) {
  					jQuery.each( arguments, function( _, arg ) {
  						var index;
  						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  							list.splice( index, 1 );
  							// Handle firing indexes
  							if ( firing ) {
  								if ( index <= firingLength ) {
  									firingLength--;
  								}
  								if ( index <= firingIndex ) {
  									firingIndex--;
  								}
  							}
  						}
  					});
  				}
  				return this;
  			},
  			// Check if a given callback is in the list.
  			// If no argument is given, return whether or not list has callbacks attached.
  			has: function( fn ) {
  				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
  			},
  			// Remove all callbacks from the list
  			empty: function() {
  				list = [];
  				firingLength = 0;
  				return this;
  			},
  			// Have the list do nothing anymore
  			disable: function() {
  				list = stack = memory = undefined;
  				return this;
  			},
  			// Is it disabled?
  			disabled: function() {
  				return !list;
  			},
  			// Lock the list in its current state
  			lock: function() {
  				stack = undefined;
  				if ( !memory ) {
  					self.disable();
  				}
  				return this;
  			},
  			// Is it locked?
  			locked: function() {
  				return !stack;
  			},
  			// Call all callbacks with the given context and arguments
  			fireWith: function( context, args ) {
  				if ( list && ( !fired || stack ) ) {
  					args = args || [];
  					args = [ context, args.slice ? args.slice() : args ];
  					if ( firing ) {
  						stack.push( args );
  					} else {
  						fire( args );
  					}
  				}
  				return this;
  			},
  			// Call all the callbacks with the given arguments
  			fire: function() {
  				self.fireWith( this, arguments );
  				return this;
  			},
  			// To know if the callbacks have already been called at least once
  			fired: function() {
  				return !!fired;
  			}
  		};

  	return self;
  };


  jQuery.extend({

  	Deferred: function( func ) {
  		var tuples = [
  				// action, add listener, listener list, final state
  				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
  				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
  				[ "notify", "progress", jQuery.Callbacks("memory") ]
  			],
  			state = "pending",
  			promise = {
  				state: function() {
  					return state;
  				},
  				always: function() {
  					deferred.done( arguments ).fail( arguments );
  					return this;
  				},
  				then: function( /* fnDone, fnFail, fnProgress */ ) {
  					var fns = arguments;
  					return jQuery.Deferred(function( newDefer ) {
  						jQuery.each( tuples, function( i, tuple ) {
  							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
  							// deferred[ done | fail | progress ] for forwarding actions to newDefer
  							deferred[ tuple[1] ](function() {
  								var returned = fn && fn.apply( this, arguments );
  								if ( returned && jQuery.isFunction( returned.promise ) ) {
  									returned.promise()
  										.done( newDefer.resolve )
  										.fail( newDefer.reject )
  										.progress( newDefer.notify );
  								} else {
  									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
  								}
  							});
  						});
  						fns = null;
  					}).promise();
  				},
  				// Get a promise for this deferred
  				// If obj is provided, the promise aspect is added to the object
  				promise: function( obj ) {
  					return obj != null ? jQuery.extend( obj, promise ) : promise;
  				}
  			},
  			deferred = {};

  		// Keep pipe for back-compat
  		promise.pipe = promise.then;

  		// Add list-specific methods
  		jQuery.each( tuples, function( i, tuple ) {
  			var list = tuple[ 2 ],
  				stateString = tuple[ 3 ];

  			// promise[ done | fail | progress ] = list.add
  			promise[ tuple[1] ] = list.add;

  			// Handle state
  			if ( stateString ) {
  				list.add(function() {
  					// state = [ resolved | rejected ]
  					state = stateString;

  				// [ reject_list | resolve_list ].disable; progress_list.lock
  				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
  			}

  			// deferred[ resolve | reject | notify ]
  			deferred[ tuple[0] ] = function() {
  				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
  				return this;
  			};
  			deferred[ tuple[0] + "With" ] = list.fireWith;
  		});

  		// Make the deferred a promise
  		promise.promise( deferred );

  		// Call given func if any
  		if ( func ) {
  			func.call( deferred, deferred );
  		}

  		// All done!
  		return deferred;
  	},

  	// Deferred helper
  	when: function( subordinate /* , ..., subordinateN */ ) {
  		var i = 0,
  			resolveValues = slice.call( arguments ),
  			length = resolveValues.length,

  			// the count of uncompleted subordinates
  			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

  			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
  			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

  			// Update function for both resolve and progress values
  			updateFunc = function( i, contexts, values ) {
  				return function( value ) {
  					contexts[ i ] = this;
  					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  					if ( values === progressValues ) {
  						deferred.notifyWith( contexts, values );
  					} else if ( !( --remaining ) ) {
  						deferred.resolveWith( contexts, values );
  					}
  				};
  			},

  			progressValues, progressContexts, resolveContexts;

  		// Add listeners to Deferred subordinates; treat others as resolved
  		if ( length > 1 ) {
  			progressValues = new Array( length );
  			progressContexts = new Array( length );
  			resolveContexts = new Array( length );
  			for ( ; i < length; i++ ) {
  				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
  					resolveValues[ i ].promise()
  						.done( updateFunc( i, resolveContexts, resolveValues ) )
  						.fail( deferred.reject )
  						.progress( updateFunc( i, progressContexts, progressValues ) );
  				} else {
  					--remaining;
  				}
  			}
  		}

  		// If we're not waiting on anything, resolve the master
  		if ( !remaining ) {
  			deferred.resolveWith( resolveContexts, resolveValues );
  		}

  		return deferred.promise();
  	}
  });


  // The deferred used on DOM ready
  var readyList;

  jQuery.fn.ready = function( fn ) {
  	// Add the callback
  	jQuery.ready.promise().done( fn );

  	return this;
  };

  jQuery.extend({
  	// Is the DOM ready to be used? Set to true once it occurs.
  	isReady: false,

  	// A counter to track how many items to wait for before
  	// the ready event fires. See #6781
  	readyWait: 1,

  	// Hold (or release) the ready event
  	holdReady: function( hold ) {
  		if ( hold ) {
  			jQuery.readyWait++;
  		} else {
  			jQuery.ready( true );
  		}
  	},

  	// Handle when the DOM is ready
  	ready: function( wait ) {

  		// Abort if there are pending holds or we're already ready
  		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  			return;
  		}

  		// Remember that the DOM is ready
  		jQuery.isReady = true;

  		// If a normal DOM Ready event fired, decrement, and wait if need be
  		if ( wait !== true && --jQuery.readyWait > 0 ) {
  			return;
  		}

  		// If there are functions bound, to execute
  		readyList.resolveWith( document, [ jQuery ] );

  		// Trigger any bound ready events
  		if ( jQuery.fn.triggerHandler ) {
  			jQuery( document ).triggerHandler( "ready" );
  			jQuery( document ).off( "ready" );
  		}
  	}
  });

  /**
   * The ready event handler and self cleanup method
   */
  function completed() {
  	document.removeEventListener( "DOMContentLoaded", completed, false );
  	window.removeEventListener( "load", completed, false );
  	jQuery.ready();
  }

  jQuery.ready.promise = function( obj ) {
  	if ( !readyList ) {

  		readyList = jQuery.Deferred();

  		// Catch cases where $(document).ready() is called after the browser event has already occurred.
  		// We once tried to use readyState "interactive" here, but it caused issues like the one
  		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
  		if ( document.readyState === "complete" ) {
  			// Handle it asynchronously to allow scripts the opportunity to delay ready
  			setTimeout( jQuery.ready );

  		} else {

  			// Use the handy event callback
  			document.addEventListener( "DOMContentLoaded", completed, false );

  			// A fallback to window.onload, that will always work
  			window.addEventListener( "load", completed, false );
  		}
  	}
  	return readyList.promise( obj );
  };

  // Kick off the DOM ready check even if the user does not
  jQuery.ready.promise();




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  	var i = 0,
  		len = elems.length,
  		bulk = key == null;

  	// Sets many values
  	if ( jQuery.type( key ) === "object" ) {
  		chainable = true;
  		for ( i in key ) {
  			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
  		}

  	// Sets one value
  	} else if ( value !== undefined ) {
  		chainable = true;

  		if ( !jQuery.isFunction( value ) ) {
  			raw = true;
  		}

  		if ( bulk ) {
  			// Bulk operations run against the entire set
  			if ( raw ) {
  				fn.call( elems, value );
  				fn = null;

  			// ...except when executing function values
  			} else {
  				bulk = fn;
  				fn = function( elem, key, value ) {
  					return bulk.call( jQuery( elem ), value );
  				};
  			}
  		}

  		if ( fn ) {
  			for ( ; i < len; i++ ) {
  				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
  			}
  		}
  	}

  	return chainable ?
  		elems :

  		// Gets
  		bulk ?
  			fn.call( elems ) :
  			len ? fn( elems[0], key ) : emptyGet;
  };


  /**
   * Determines whether an object can have data
   */
  jQuery.acceptData = function( owner ) {
  	// Accepts only:
  	//  - Node
  	//    - Node.ELEMENT_NODE
  	//    - Node.DOCUMENT_NODE
  	//  - Object
  	//    - Any
  	/* jshint -W018 */
  	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };


  function Data() {
  	// Support: Android<4,
  	// Old WebKit does not have Object.preventExtensions/freeze method,
  	// return new empty object instead with no [[set]] accessor
  	Object.defineProperty( this.cache = {}, 0, {
  		get: function() {
  			return {};
  		}
  	});

  	this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.accepts = jQuery.acceptData;

  Data.prototype = {
  	key: function( owner ) {
  		// We can accept data for non-element nodes in modern browsers,
  		// but we should not, see #8335.
  		// Always return the key for a frozen object.
  		if ( !Data.accepts( owner ) ) {
  			return 0;
  		}

  		var descriptor = {},
  			// Check if the owner object already has a cache key
  			unlock = owner[ this.expando ];

  		// If not, create one
  		if ( !unlock ) {
  			unlock = Data.uid++;

  			// Secure it in a non-enumerable, non-writable property
  			try {
  				descriptor[ this.expando ] = { value: unlock };
  				Object.defineProperties( owner, descriptor );

  			// Support: Android<4
  			// Fallback to a less secure definition
  			} catch ( e ) {
  				descriptor[ this.expando ] = unlock;
  				jQuery.extend( owner, descriptor );
  			}
  		}

  		// Ensure the cache object
  		if ( !this.cache[ unlock ] ) {
  			this.cache[ unlock ] = {};
  		}

  		return unlock;
  	},
  	set: function( owner, data, value ) {
  		var prop,
  			// There may be an unlock assigned to this node,
  			// if there is no entry for this "owner", create one inline
  			// and set the unlock as though an owner entry had always existed
  			unlock = this.key( owner ),
  			cache = this.cache[ unlock ];

  		// Handle: [ owner, key, value ] args
  		if ( typeof data === "string" ) {
  			cache[ data ] = value;

  		// Handle: [ owner, { properties } ] args
  		} else {
  			// Fresh assignments by object are shallow copied
  			if ( jQuery.isEmptyObject( cache ) ) {
  				jQuery.extend( this.cache[ unlock ], data );
  			// Otherwise, copy the properties one-by-one to the cache object
  			} else {
  				for ( prop in data ) {
  					cache[ prop ] = data[ prop ];
  				}
  			}
  		}
  		return cache;
  	},
  	get: function( owner, key ) {
  		// Either a valid cache is found, or will be created.
  		// New caches will be created and the unlock returned,
  		// allowing direct access to the newly created
  		// empty data object. A valid owner object must be provided.
  		var cache = this.cache[ this.key( owner ) ];

  		return key === undefined ?
  			cache : cache[ key ];
  	},
  	access: function( owner, key, value ) {
  		var stored;
  		// In cases where either:
  		//
  		//   1. No key was specified
  		//   2. A string key was specified, but no value provided
  		//
  		// Take the "read" path and allow the get method to determine
  		// which value to return, respectively either:
  		//
  		//   1. The entire cache object
  		//   2. The data stored at the key
  		//
  		if ( key === undefined ||
  				((key && typeof key === "string") && value === undefined) ) {

  			stored = this.get( owner, key );

  			return stored !== undefined ?
  				stored : this.get( owner, jQuery.camelCase(key) );
  		}

  		// [*]When the key is not a string, or both a key and value
  		// are specified, set or extend (existing objects) with either:
  		//
  		//   1. An object of properties
  		//   2. A key and value
  		//
  		this.set( owner, key, value );

  		// Since the "set" path can have two possible entry points
  		// return the expected data based on which path was taken[*]
  		return value !== undefined ? value : key;
  	},
  	remove: function( owner, key ) {
  		var i, name, camel,
  			unlock = this.key( owner ),
  			cache = this.cache[ unlock ];

  		if ( key === undefined ) {
  			this.cache[ unlock ] = {};

  		} else {
  			// Support array or space separated string of keys
  			if ( jQuery.isArray( key ) ) {
  				// If "name" is an array of keys...
  				// When data is initially created, via ("key", "val") signature,
  				// keys will be converted to camelCase.
  				// Since there is no way to tell _how_ a key was added, remove
  				// both plain key and camelCase key. #12786
  				// This will only penalize the array argument path.
  				name = key.concat( key.map( jQuery.camelCase ) );
  			} else {
  				camel = jQuery.camelCase( key );
  				// Try the string as a key before any manipulation
  				if ( key in cache ) {
  					name = [ key, camel ];
  				} else {
  					// If a key with the spaces exists, use it.
  					// Otherwise, create an array by matching non-whitespace
  					name = camel;
  					name = name in cache ?
  						[ name ] : ( name.match( rnotwhite ) || [] );
  				}
  			}

  			i = name.length;
  			while ( i-- ) {
  				delete cache[ name[ i ] ];
  			}
  		}
  	},
  	hasData: function( owner ) {
  		return !jQuery.isEmptyObject(
  			this.cache[ owner[ this.expando ] ] || {}
  		);
  	},
  	discard: function( owner ) {
  		if ( owner[ this.expando ] ) {
  			delete this.cache[ owner[ this.expando ] ];
  		}
  	}
  };
  var data_priv = new Data();

  var data_user = new Data();



  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  	rmultiDash = /([A-Z])/g;

  function dataAttr( elem, key, data ) {
  	var name;

  	// If nothing was found internally, try to fetch any
  	// data from the HTML5 data-* attribute
  	if ( data === undefined && elem.nodeType === 1 ) {
  		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
  		data = elem.getAttribute( name );

  		if ( typeof data === "string" ) {
  			try {
  				data = data === "true" ? true :
  					data === "false" ? false :
  					data === "null" ? null :
  					// Only convert to a number if it doesn't change the string
  					+data + "" === data ? +data :
  					rbrace.test( data ) ? jQuery.parseJSON( data ) :
  					data;
  			} catch( e ) {}

  			// Make sure we set the data so it isn't changed later
  			data_user.set( elem, key, data );
  		} else {
  			data = undefined;
  		}
  	}
  	return data;
  }

  jQuery.extend({
  	hasData: function( elem ) {
  		return data_user.hasData( elem ) || data_priv.hasData( elem );
  	},

  	data: function( elem, name, data ) {
  		return data_user.access( elem, name, data );
  	},

  	removeData: function( elem, name ) {
  		data_user.remove( elem, name );
  	},

  	// TODO: Now that all calls to _data and _removeData have been replaced
  	// with direct calls to data_priv methods, these can be deprecated.
  	_data: function( elem, name, data ) {
  		return data_priv.access( elem, name, data );
  	},

  	_removeData: function( elem, name ) {
  		data_priv.remove( elem, name );
  	}
  });

  jQuery.fn.extend({
  	data: function( key, value ) {
  		var i, name, data,
  			elem = this[ 0 ],
  			attrs = elem && elem.attributes;

  		// Gets all values
  		if ( key === undefined ) {
  			if ( this.length ) {
  				data = data_user.get( elem );

  				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
  					i = attrs.length;
  					while ( i-- ) {

  						// Support: IE11+
  						// The attrs elements can be null (#14894)
  						if ( attrs[ i ] ) {
  							name = attrs[ i ].name;
  							if ( name.indexOf( "data-" ) === 0 ) {
  								name = jQuery.camelCase( name.slice(5) );
  								dataAttr( elem, name, data[ name ] );
  							}
  						}
  					}
  					data_priv.set( elem, "hasDataAttrs", true );
  				}
  			}

  			return data;
  		}

  		// Sets multiple values
  		if ( typeof key === "object" ) {
  			return this.each(function() {
  				data_user.set( this, key );
  			});
  		}

  		return access( this, function( value ) {
  			var data,
  				camelKey = jQuery.camelCase( key );

  			// The calling jQuery object (element matches) is not empty
  			// (and therefore has an element appears at this[ 0 ]) and the
  			// `value` parameter was not undefined. An empty jQuery object
  			// will result in `undefined` for elem = this[ 0 ] which will
  			// throw an exception if an attempt to read a data cache is made.
  			if ( elem && value === undefined ) {
  				// Attempt to get data from the cache
  				// with the key as-is
  				data = data_user.get( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to get data from the cache
  				// with the key camelized
  				data = data_user.get( elem, camelKey );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to "discover" the data in
  				// HTML5 custom data-* attrs
  				data = dataAttr( elem, camelKey, undefined );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// We tried really hard, but the data doesn't exist.
  				return;
  			}

  			// Set the data...
  			this.each(function() {
  				// First, attempt to store a copy or reference of any
  				// data that might've been store with a camelCased key.
  				var data = data_user.get( this, camelKey );

  				// For HTML5 data-* attribute interop, we have to
  				// store property names with dashes in a camelCase form.
  				// This might not apply to all properties...*
  				data_user.set( this, camelKey, value );

  				// *... In the case of properties that might _actually_
  				// have dashes, we need to also store a copy of that
  				// unchanged property.
  				if ( key.indexOf("-") !== -1 && data !== undefined ) {
  					data_user.set( this, key, value );
  				}
  			});
  		}, null, value, arguments.length > 1, null, true );
  	},

  	removeData: function( key ) {
  		return this.each(function() {
  			data_user.remove( this, key );
  		});
  	}
  });


  jQuery.extend({
  	queue: function( elem, type, data ) {
  		var queue;

  		if ( elem ) {
  			type = ( type || "fx" ) + "queue";
  			queue = data_priv.get( elem, type );

  			// Speed up dequeue by getting out quickly if this is just a lookup
  			if ( data ) {
  				if ( !queue || jQuery.isArray( data ) ) {
  					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
  				} else {
  					queue.push( data );
  				}
  			}
  			return queue || [];
  		}
  	},

  	dequeue: function( elem, type ) {
  		type = type || "fx";

  		var queue = jQuery.queue( elem, type ),
  			startLength = queue.length,
  			fn = queue.shift(),
  			hooks = jQuery._queueHooks( elem, type ),
  			next = function() {
  				jQuery.dequeue( elem, type );
  			};

  		// If the fx queue is dequeued, always remove the progress sentinel
  		if ( fn === "inprogress" ) {
  			fn = queue.shift();
  			startLength--;
  		}

  		if ( fn ) {

  			// Add a progress sentinel to prevent the fx queue from being
  			// automatically dequeued
  			if ( type === "fx" ) {
  				queue.unshift( "inprogress" );
  			}

  			// Clear up the last queue stop function
  			delete hooks.stop;
  			fn.call( elem, next, hooks );
  		}

  		if ( !startLength && hooks ) {
  			hooks.empty.fire();
  		}
  	},

  	// Not public - generate a queueHooks object, or return the current one
  	_queueHooks: function( elem, type ) {
  		var key = type + "queueHooks";
  		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
  			empty: jQuery.Callbacks("once memory").add(function() {
  				data_priv.remove( elem, [ type + "queue", key ] );
  			})
  		});
  	}
  });

  jQuery.fn.extend({
  	queue: function( type, data ) {
  		var setter = 2;

  		if ( typeof type !== "string" ) {
  			data = type;
  			type = "fx";
  			setter--;
  		}

  		if ( arguments.length < setter ) {
  			return jQuery.queue( this[0], type );
  		}

  		return data === undefined ?
  			this :
  			this.each(function() {
  				var queue = jQuery.queue( this, type, data );

  				// Ensure a hooks for this queue
  				jQuery._queueHooks( this, type );

  				if ( type === "fx" && queue[0] !== "inprogress" ) {
  					jQuery.dequeue( this, type );
  				}
  			});
  	},
  	dequeue: function( type ) {
  		return this.each(function() {
  			jQuery.dequeue( this, type );
  		});
  	},
  	clearQueue: function( type ) {
  		return this.queue( type || "fx", [] );
  	},
  	// Get a promise resolved when queues of a certain type
  	// are emptied (fx is the type by default)
  	promise: function( type, obj ) {
  		var tmp,
  			count = 1,
  			defer = jQuery.Deferred(),
  			elements = this,
  			i = this.length,
  			resolve = function() {
  				if ( !( --count ) ) {
  					defer.resolveWith( elements, [ elements ] );
  				}
  			};

  		if ( typeof type !== "string" ) {
  			obj = type;
  			type = undefined;
  		}
  		type = type || "fx";

  		while ( i-- ) {
  			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
  			if ( tmp && tmp.empty ) {
  				count++;
  				tmp.empty.add( resolve );
  			}
  		}
  		resolve();
  		return defer.promise( obj );
  	}
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  var isHidden = function( elem, el ) {
  		// isHidden might be called from jQuery#filter function;
  		// in that case, element will be second argument
  		elem = el || elem;
  		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
  	};

  var rcheckableType = (/^(?:checkbox|radio)$/i);



  (function() {
  	var fragment = document.createDocumentFragment(),
  		div = fragment.appendChild( document.createElement( "div" ) ),
  		input = document.createElement( "input" );

  	// Support: Safari<=5.1
  	// Check state lost if the name is set (#11217)
  	// Support: Windows Web Apps (WWA)
  	// `name` and `type` must use .setAttribute for WWA (#14901)
  	input.setAttribute( "type", "radio" );
  	input.setAttribute( "checked", "checked" );
  	input.setAttribute( "name", "t" );

  	div.appendChild( input );

  	// Support: Safari<=5.1, Android<4.2
  	// Older WebKit doesn't clone checked state correctly in fragments
  	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  	// Support: IE<=11+
  	// Make sure textarea (and checkbox) defaultValue is properly cloned
  	div.innerHTML = "<textarea>x</textarea>";
  	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;



  support.focusinBubbles = "onfocusin" in window;


  var
  	rkeyEvent = /^key/,
  	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
  	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

  function returnTrue() {
  	return true;
  }

  function returnFalse() {
  	return false;
  }

  function safeActiveElement() {
  	try {
  		return document.activeElement;
  	} catch ( err ) { }
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

  	global: {},

  	add: function( elem, types, handler, data, selector ) {

  		var handleObjIn, eventHandle, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = data_priv.get( elem );

  		// Don't attach events to noData or text/comment nodes (but allow plain objects)
  		if ( !elemData ) {
  			return;
  		}

  		// Caller can pass in an object of custom data in lieu of the handler
  		if ( handler.handler ) {
  			handleObjIn = handler;
  			handler = handleObjIn.handler;
  			selector = handleObjIn.selector;
  		}

  		// Make sure that the handler has a unique ID, used to find/remove it later
  		if ( !handler.guid ) {
  			handler.guid = jQuery.guid++;
  		}

  		// Init the element's event structure and main handler, if this is the first
  		if ( !(events = elemData.events) ) {
  			events = elemData.events = {};
  		}
  		if ( !(eventHandle = elemData.handle) ) {
  			eventHandle = elemData.handle = function( e ) {
  				// Discard the second event of a jQuery.event.trigger() and
  				// when an event is called after a page has unloaded
  				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
  					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  			};
  		}

  		// Handle multiple events separated by a space
  		types = ( types || "" ).match( rnotwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[t] ) || [];
  			type = origType = tmp[1];
  			namespaces = ( tmp[2] || "" ).split( "." ).sort();

  			// There *must* be a type, no attaching namespace-only handlers
  			if ( !type ) {
  				continue;
  			}

  			// If event changes its type, use the special event handlers for the changed type
  			special = jQuery.event.special[ type ] || {};

  			// If selector defined, determine special event api type, otherwise given type
  			type = ( selector ? special.delegateType : special.bindType ) || type;

  			// Update special based on newly reset type
  			special = jQuery.event.special[ type ] || {};

  			// handleObj is passed to all event handlers
  			handleObj = jQuery.extend({
  				type: type,
  				origType: origType,
  				data: data,
  				handler: handler,
  				guid: handler.guid,
  				selector: selector,
  				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  				namespace: namespaces.join(".")
  			}, handleObjIn );

  			// Init the event handler queue if we're the first
  			if ( !(handlers = events[ type ]) ) {
  				handlers = events[ type ] = [];
  				handlers.delegateCount = 0;

  				// Only use addEventListener if the special events handler returns false
  				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
  					if ( elem.addEventListener ) {
  						elem.addEventListener( type, eventHandle, false );
  					}
  				}
  			}

  			if ( special.add ) {
  				special.add.call( elem, handleObj );

  				if ( !handleObj.handler.guid ) {
  					handleObj.handler.guid = handler.guid;
  				}
  			}

  			// Add to the element's handler list, delegates in front
  			if ( selector ) {
  				handlers.splice( handlers.delegateCount++, 0, handleObj );
  			} else {
  				handlers.push( handleObj );
  			}

  			// Keep track of which events have ever been used, for event optimization
  			jQuery.event.global[ type ] = true;
  		}

  	},

  	// Detach an event or set of events from an element
  	remove: function( elem, types, handler, selector, mappedTypes ) {

  		var j, origCount, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

  		if ( !elemData || !(events = elemData.events) ) {
  			return;
  		}

  		// Once for each type.namespace in types; type may be omitted
  		types = ( types || "" ).match( rnotwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[t] ) || [];
  			type = origType = tmp[1];
  			namespaces = ( tmp[2] || "" ).split( "." ).sort();

  			// Unbind all events (on this namespace, if provided) for the element
  			if ( !type ) {
  				for ( type in events ) {
  					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  				}
  				continue;
  			}

  			special = jQuery.event.special[ type ] || {};
  			type = ( selector ? special.delegateType : special.bindType ) || type;
  			handlers = events[ type ] || [];
  			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

  			// Remove matching events
  			origCount = j = handlers.length;
  			while ( j-- ) {
  				handleObj = handlers[ j ];

  				if ( ( mappedTypes || origType === handleObj.origType ) &&
  					( !handler || handler.guid === handleObj.guid ) &&
  					( !tmp || tmp.test( handleObj.namespace ) ) &&
  					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
  					handlers.splice( j, 1 );

  					if ( handleObj.selector ) {
  						handlers.delegateCount--;
  					}
  					if ( special.remove ) {
  						special.remove.call( elem, handleObj );
  					}
  				}
  			}

  			// Remove generic event handler if we removed something and no more handlers exist
  			// (avoids potential for endless recursion during removal of special event handlers)
  			if ( origCount && !handlers.length ) {
  				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
  					jQuery.removeEvent( elem, type, elemData.handle );
  				}

  				delete events[ type ];
  			}
  		}

  		// Remove the expando if it's no longer used
  		if ( jQuery.isEmptyObject( events ) ) {
  			delete elemData.handle;
  			data_priv.remove( elem, "events" );
  		}
  	},

  	trigger: function( event, data, elem, onlyHandlers ) {

  		var i, cur, tmp, bubbleType, ontype, handle, special,
  			eventPath = [ elem || document ],
  			type = hasOwn.call( event, "type" ) ? event.type : event,
  			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

  		cur = tmp = elem = elem || document;

  		// Don't do events on text and comment nodes
  		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  			return;
  		}

  		// focus/blur morphs to focusin/out; ensure we're not firing them right now
  		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  			return;
  		}

  		if ( type.indexOf(".") >= 0 ) {
  			// Namespaced trigger; create a regexp to match event type in handle()
  			namespaces = type.split(".");
  			type = namespaces.shift();
  			namespaces.sort();
  		}
  		ontype = type.indexOf(":") < 0 && "on" + type;

  		// Caller can pass in a jQuery.Event object, Object, or just an event type string
  		event = event[ jQuery.expando ] ?
  			event :
  			new jQuery.Event( type, typeof event === "object" && event );

  		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  		event.isTrigger = onlyHandlers ? 2 : 3;
  		event.namespace = namespaces.join(".");
  		event.namespace_re = event.namespace ?
  			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
  			null;

  		// Clean up the event in case it is being reused
  		event.result = undefined;
  		if ( !event.target ) {
  			event.target = elem;
  		}

  		// Clone any incoming data and prepend the event, creating the handler arg list
  		data = data == null ?
  			[ event ] :
  			jQuery.makeArray( data, [ event ] );

  		// Allow special events to draw outside the lines
  		special = jQuery.event.special[ type ] || {};
  		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  			return;
  		}

  		// Determine event propagation path in advance, per W3C events spec (#9951)
  		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
  		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

  			bubbleType = special.delegateType || type;
  			if ( !rfocusMorph.test( bubbleType + type ) ) {
  				cur = cur.parentNode;
  			}
  			for ( ; cur; cur = cur.parentNode ) {
  				eventPath.push( cur );
  				tmp = cur;
  			}

  			// Only add window if we got to document (e.g., not plain obj or detached DOM)
  			if ( tmp === (elem.ownerDocument || document) ) {
  				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  			}
  		}

  		// Fire handlers on the event path
  		i = 0;
  		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

  			event.type = i > 1 ?
  				bubbleType :
  				special.bindType || type;

  			// jQuery handler
  			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
  			if ( handle ) {
  				handle.apply( cur, data );
  			}

  			// Native handler
  			handle = ontype && cur[ ontype ];
  			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
  				event.result = handle.apply( cur, data );
  				if ( event.result === false ) {
  					event.preventDefault();
  				}
  			}
  		}
  		event.type = type;

  		// If nobody prevented the default action, do it now
  		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
  				jQuery.acceptData( elem ) ) {

  				// Call a native DOM method on the target with the same name name as the event.
  				// Don't do default actions on window, that's where global variables be (#6170)
  				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

  					// Don't re-trigger an onFOO event when we call its FOO() method
  					tmp = elem[ ontype ];

  					if ( tmp ) {
  						elem[ ontype ] = null;
  					}

  					// Prevent re-triggering of the same event, since we already bubbled it above
  					jQuery.event.triggered = type;
  					elem[ type ]();
  					jQuery.event.triggered = undefined;

  					if ( tmp ) {
  						elem[ ontype ] = tmp;
  					}
  				}
  			}
  		}

  		return event.result;
  	},

  	dispatch: function( event ) {

  		// Make a writable jQuery.Event from the native event object
  		event = jQuery.event.fix( event );

  		var i, j, ret, matched, handleObj,
  			handlerQueue = [],
  			args = slice.call( arguments ),
  			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
  			special = jQuery.event.special[ event.type ] || {};

  		// Use the fix-ed jQuery.Event rather than the (read-only) native event
  		args[0] = event;
  		event.delegateTarget = this;

  		// Call the preDispatch hook for the mapped type, and let it bail if desired
  		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  			return;
  		}

  		// Determine handlers
  		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  		// Run delegates first; they may want to stop propagation beneath us
  		i = 0;
  		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
  			event.currentTarget = matched.elem;

  			j = 0;
  			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

  				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
  				// a subset or equal to those in the bound event (both can have no namespace).
  				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

  					event.handleObj = handleObj;
  					event.data = handleObj.data;

  					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
  							.apply( matched.elem, args );

  					if ( ret !== undefined ) {
  						if ( (event.result = ret) === false ) {
  							event.preventDefault();
  							event.stopPropagation();
  						}
  					}
  				}
  			}
  		}

  		// Call the postDispatch hook for the mapped type
  		if ( special.postDispatch ) {
  			special.postDispatch.call( this, event );
  		}

  		return event.result;
  	},

  	handlers: function( event, handlers ) {
  		var i, matches, sel, handleObj,
  			handlerQueue = [],
  			delegateCount = handlers.delegateCount,
  			cur = event.target;

  		// Find delegate handlers
  		// Black-hole SVG <use> instance trees (#13180)
  		// Avoid non-left-click bubbling in Firefox (#3861)
  		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

  			for ( ; cur !== this; cur = cur.parentNode || this ) {

  				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
  				if ( cur.disabled !== true || event.type !== "click" ) {
  					matches = [];
  					for ( i = 0; i < delegateCount; i++ ) {
  						handleObj = handlers[ i ];

  						// Don't conflict with Object.prototype properties (#13203)
  						sel = handleObj.selector + " ";

  						if ( matches[ sel ] === undefined ) {
  							matches[ sel ] = handleObj.needsContext ?
  								jQuery( sel, this ).index( cur ) >= 0 :
  								jQuery.find( sel, this, null, [ cur ] ).length;
  						}
  						if ( matches[ sel ] ) {
  							matches.push( handleObj );
  						}
  					}
  					if ( matches.length ) {
  						handlerQueue.push({ elem: cur, handlers: matches });
  					}
  				}
  			}
  		}

  		// Add the remaining (directly-bound) handlers
  		if ( delegateCount < handlers.length ) {
  			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
  		}

  		return handlerQueue;
  	},

  	// Includes some event props shared by KeyEvent and MouseEvent
  	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  	fixHooks: {},

  	keyHooks: {
  		props: "char charCode key keyCode".split(" "),
  		filter: function( event, original ) {

  			// Add which for key events
  			if ( event.which == null ) {
  				event.which = original.charCode != null ? original.charCode : original.keyCode;
  			}

  			return event;
  		}
  	},

  	mouseHooks: {
  		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
  		filter: function( event, original ) {
  			var eventDoc, doc, body,
  				button = original.button;

  			// Calculate pageX/Y if missing and clientX/Y available
  			if ( event.pageX == null && original.clientX != null ) {
  				eventDoc = event.target.ownerDocument || document;
  				doc = eventDoc.documentElement;
  				body = eventDoc.body;

  				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
  				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
  			}

  			// Add which for click: 1 === left; 2 === middle; 3 === right
  			// Note: button is not normalized, so don't use it
  			if ( !event.which && button !== undefined ) {
  				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
  			}

  			return event;
  		}
  	},

  	fix: function( event ) {
  		if ( event[ jQuery.expando ] ) {
  			return event;
  		}

  		// Create a writable copy of the event object and normalize some properties
  		var i, prop, copy,
  			type = event.type,
  			originalEvent = event,
  			fixHook = this.fixHooks[ type ];

  		if ( !fixHook ) {
  			this.fixHooks[ type ] = fixHook =
  				rmouseEvent.test( type ) ? this.mouseHooks :
  				rkeyEvent.test( type ) ? this.keyHooks :
  				{};
  		}
  		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

  		event = new jQuery.Event( originalEvent );

  		i = copy.length;
  		while ( i-- ) {
  			prop = copy[ i ];
  			event[ prop ] = originalEvent[ prop ];
  		}

  		// Support: Cordova 2.5 (WebKit) (#13255)
  		// All events should have a target; Cordova deviceready doesn't
  		if ( !event.target ) {
  			event.target = document;
  		}

  		// Support: Safari 6.0+, Chrome<28
  		// Target should not be a text node (#504, #13143)
  		if ( event.target.nodeType === 3 ) {
  			event.target = event.target.parentNode;
  		}

  		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
  	},

  	special: {
  		load: {
  			// Prevent triggered image.load events from bubbling to window.load
  			noBubble: true
  		},
  		focus: {
  			// Fire native event if possible so blur/focus sequence is correct
  			trigger: function() {
  				if ( this !== safeActiveElement() && this.focus ) {
  					this.focus();
  					return false;
  				}
  			},
  			delegateType: "focusin"
  		},
  		blur: {
  			trigger: function() {
  				if ( this === safeActiveElement() && this.blur ) {
  					this.blur();
  					return false;
  				}
  			},
  			delegateType: "focusout"
  		},
  		click: {
  			// For checkbox, fire native event so checked state will be right
  			trigger: function() {
  				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
  					this.click();
  					return false;
  				}
  			},

  			// For cross-browser consistency, don't fire native .click() on links
  			_default: function( event ) {
  				return jQuery.nodeName( event.target, "a" );
  			}
  		},

  		beforeunload: {
  			postDispatch: function( event ) {

  				// Support: Firefox 20+
  				// Firefox doesn't alert if the returnValue field is not set.
  				if ( event.result !== undefined && event.originalEvent ) {
  					event.originalEvent.returnValue = event.result;
  				}
  			}
  		}
  	},

  	simulate: function( type, elem, event, bubble ) {
  		// Piggyback on a donor event to simulate a different one.
  		// Fake originalEvent to avoid donor's stopPropagation, but if the
  		// simulated event prevents default then we do the same on the donor.
  		var e = jQuery.extend(
  			new jQuery.Event(),
  			event,
  			{
  				type: type,
  				isSimulated: true,
  				originalEvent: {}
  			}
  		);
  		if ( bubble ) {
  			jQuery.event.trigger( e, null, elem );
  		} else {
  			jQuery.event.dispatch.call( elem, e );
  		}
  		if ( e.isDefaultPrevented() ) {
  			event.preventDefault();
  		}
  	}
  };

  jQuery.removeEvent = function( elem, type, handle ) {
  	if ( elem.removeEventListener ) {
  		elem.removeEventListener( type, handle, false );
  	}
  };

  jQuery.Event = function( src, props ) {
  	// Allow instantiation without the 'new' keyword
  	if ( !(this instanceof jQuery.Event) ) {
  		return new jQuery.Event( src, props );
  	}

  	// Event object
  	if ( src && src.type ) {
  		this.originalEvent = src;
  		this.type = src.type;

  		// Events bubbling up the document may have been marked as prevented
  		// by a handler lower down the tree; reflect the correct value.
  		this.isDefaultPrevented = src.defaultPrevented ||
  				src.defaultPrevented === undefined &&
  				// Support: Android<4.0
  				src.returnValue === false ?
  			returnTrue :
  			returnFalse;

  	// Event type
  	} else {
  		this.type = src;
  	}

  	// Put explicitly provided properties onto the event object
  	if ( props ) {
  		jQuery.extend( this, props );
  	}

  	// Create a timestamp if incoming event doesn't have one
  	this.timeStamp = src && src.timeStamp || jQuery.now();

  	// Mark it as fixed
  	this[ jQuery.expando ] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
  	isDefaultPrevented: returnFalse,
  	isPropagationStopped: returnFalse,
  	isImmediatePropagationStopped: returnFalse,

  	preventDefault: function() {
  		var e = this.originalEvent;

  		this.isDefaultPrevented = returnTrue;

  		if ( e && e.preventDefault ) {
  			e.preventDefault();
  		}
  	},
  	stopPropagation: function() {
  		var e = this.originalEvent;

  		this.isPropagationStopped = returnTrue;

  		if ( e && e.stopPropagation ) {
  			e.stopPropagation();
  		}
  	},
  	stopImmediatePropagation: function() {
  		var e = this.originalEvent;

  		this.isImmediatePropagationStopped = returnTrue;

  		if ( e && e.stopImmediatePropagation ) {
  			e.stopImmediatePropagation();
  		}

  		this.stopPropagation();
  	}
  };

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // Support: Chrome 15+
  jQuery.each({
  	mouseenter: "mouseover",
  	mouseleave: "mouseout",
  	pointerenter: "pointerover",
  	pointerleave: "pointerout"
  }, function( orig, fix ) {
  	jQuery.event.special[ orig ] = {
  		delegateType: fix,
  		bindType: fix,

  		handle: function( event ) {
  			var ret,
  				target = this,
  				related = event.relatedTarget,
  				handleObj = event.handleObj;

  			// For mousenter/leave call the handler if related is outside the target.
  			// NB: No relatedTarget if the mouse left/entered the browser window
  			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
  				event.type = handleObj.origType;
  				ret = handleObj.handler.apply( this, arguments );
  				event.type = fix;
  			}
  			return ret;
  		}
  	};
  });

  // Support: Firefox, Chrome, Safari
  // Create "bubbling" focus and blur events
  if ( !support.focusinBubbles ) {
  	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

  		// Attach a single capturing handler on the document while someone wants focusin/focusout
  		var handler = function( event ) {
  				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
  			};

  		jQuery.event.special[ fix ] = {
  			setup: function() {
  				var doc = this.ownerDocument || this,
  					attaches = data_priv.access( doc, fix );

  				if ( !attaches ) {
  					doc.addEventListener( orig, handler, true );
  				}
  				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this,
  					attaches = data_priv.access( doc, fix ) - 1;

  				if ( !attaches ) {
  					doc.removeEventListener( orig, handler, true );
  					data_priv.remove( doc, fix );

  				} else {
  					data_priv.access( doc, fix, attaches );
  				}
  			}
  		};
  	});
  }

  jQuery.fn.extend({

  	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
  		var origFn, type;

  		// Types can be a map of types/handlers
  		if ( typeof types === "object" ) {
  			// ( types-Object, selector, data )
  			if ( typeof selector !== "string" ) {
  				// ( types-Object, data )
  				data = data || selector;
  				selector = undefined;
  			}
  			for ( type in types ) {
  				this.on( type, selector, data, types[ type ], one );
  			}
  			return this;
  		}

  		if ( data == null && fn == null ) {
  			// ( types, fn )
  			fn = selector;
  			data = selector = undefined;
  		} else if ( fn == null ) {
  			if ( typeof selector === "string" ) {
  				// ( types, selector, fn )
  				fn = data;
  				data = undefined;
  			} else {
  				// ( types, data, fn )
  				fn = data;
  				data = selector;
  				selector = undefined;
  			}
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		} else if ( !fn ) {
  			return this;
  		}

  		if ( one === 1 ) {
  			origFn = fn;
  			fn = function( event ) {
  				// Can use an empty set, since event contains the info
  				jQuery().off( event );
  				return origFn.apply( this, arguments );
  			};
  			// Use same guid so caller can remove using origFn
  			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  		}
  		return this.each( function() {
  			jQuery.event.add( this, types, fn, data, selector );
  		});
  	},
  	one: function( types, selector, data, fn ) {
  		return this.on( types, selector, data, fn, 1 );
  	},
  	off: function( types, selector, fn ) {
  		var handleObj, type;
  		if ( types && types.preventDefault && types.handleObj ) {
  			// ( event )  dispatched jQuery.Event
  			handleObj = types.handleObj;
  			jQuery( types.delegateTarget ).off(
  				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
  				handleObj.selector,
  				handleObj.handler
  			);
  			return this;
  		}
  		if ( typeof types === "object" ) {
  			// ( types-object [, selector] )
  			for ( type in types ) {
  				this.off( type, selector, types[ type ] );
  			}
  			return this;
  		}
  		if ( selector === false || typeof selector === "function" ) {
  			// ( types [, fn] )
  			fn = selector;
  			selector = undefined;
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		}
  		return this.each(function() {
  			jQuery.event.remove( this, types, fn, selector );
  		});
  	},

  	trigger: function( type, data ) {
  		return this.each(function() {
  			jQuery.event.trigger( type, data, this );
  		});
  	},
  	triggerHandler: function( type, data ) {
  		var elem = this[0];
  		if ( elem ) {
  			return jQuery.event.trigger( type, data, elem, true );
  		}
  	}
  });


  var
  	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
  	rtagName = /<([\w:]+)/,
  	rhtml = /<|&#?\w+;/,
  	rnoInnerhtml = /<(?:script|style|link)/i,
  	// checked="checked" or checked
  	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  	rscriptType = /^$|\/(?:java|ecma)script/i,
  	rscriptTypeMasked = /^true\/(.*)/,
  	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

  	// We have to close these tags to support XHTML (#13200)
  	wrapMap = {

  		// Support: IE9
  		option: [ 1, "<select multiple='multiple'>", "</select>" ],

  		thead: [ 1, "<table>", "</table>" ],
  		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  		_default: [ 0, "", "" ]
  	};

  // Support: IE9
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  // Support: 1.x compatibility
  // Manipulating tables requires a tbody
  function manipulationTarget( elem, content ) {
  	return jQuery.nodeName( elem, "table" ) &&
  		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

  		elem.getElementsByTagName("tbody")[0] ||
  			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
  		elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
  	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
  	return elem;
  }
  function restoreScript( elem ) {
  	var match = rscriptTypeMasked.exec( elem.type );

  	if ( match ) {
  		elem.type = match[ 1 ];
  	} else {
  		elem.removeAttribute("type");
  	}

  	return elem;
  }

  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
  	var i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		data_priv.set(
  			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
  		);
  	}
  }

  function cloneCopyEvent( src, dest ) {
  	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  	if ( dest.nodeType !== 1 ) {
  		return;
  	}

  	// 1. Copy private data: events, handlers, etc.
  	if ( data_priv.hasData( src ) ) {
  		pdataOld = data_priv.access( src );
  		pdataCur = data_priv.set( dest, pdataOld );
  		events = pdataOld.events;

  		if ( events ) {
  			delete pdataCur.handle;
  			pdataCur.events = {};

  			for ( type in events ) {
  				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  					jQuery.event.add( dest, type, events[ type ][ i ] );
  				}
  			}
  		}
  	}

  	// 2. Copy user data
  	if ( data_user.hasData( src ) ) {
  		udataOld = data_user.access( src );
  		udataCur = jQuery.extend( {}, udataOld );

  		data_user.set( dest, udataCur );
  	}
  }

  function getAll( context, tag ) {
  	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
  			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
  			[];

  	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
  		jQuery.merge( [ context ], ret ) :
  		ret;
  }

  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
  	var nodeName = dest.nodeName.toLowerCase();

  	// Fails to persist the checked state of a cloned checkbox or radio button.
  	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  		dest.checked = src.checked;

  	// Fails to return the selected option to the default selected state when cloning options
  	} else if ( nodeName === "input" || nodeName === "textarea" ) {
  		dest.defaultValue = src.defaultValue;
  	}
  }

  jQuery.extend({
  	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  		var i, l, srcElements, destElements,
  			clone = elem.cloneNode( true ),
  			inPage = jQuery.contains( elem.ownerDocument, elem );

  		// Fix IE cloning issues
  		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  				!jQuery.isXMLDoc( elem ) ) {

  			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
  			destElements = getAll( clone );
  			srcElements = getAll( elem );

  			for ( i = 0, l = srcElements.length; i < l; i++ ) {
  				fixInput( srcElements[ i ], destElements[ i ] );
  			}
  		}

  		// Copy the events from the original to the clone
  		if ( dataAndEvents ) {
  			if ( deepDataAndEvents ) {
  				srcElements = srcElements || getAll( elem );
  				destElements = destElements || getAll( clone );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  				}
  			} else {
  				cloneCopyEvent( elem, clone );
  			}
  		}

  		// Preserve script evaluation history
  		destElements = getAll( clone, "script" );
  		if ( destElements.length > 0 ) {
  			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  		}

  		// Return the cloned set
  		return clone;
  	},

  	buildFragment: function( elems, context, scripts, selection ) {
  		var elem, tmp, tag, wrap, contains, j,
  			fragment = context.createDocumentFragment(),
  			nodes = [],
  			i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			elem = elems[ i ];

  			if ( elem || elem === 0 ) {

  				// Add nodes directly
  				if ( jQuery.type( elem ) === "object" ) {
  					// Support: QtWebKit, PhantomJS
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  				// Convert non-html into a text node
  				} else if ( !rhtml.test( elem ) ) {
  					nodes.push( context.createTextNode( elem ) );

  				// Convert html into DOM nodes
  				} else {
  					tmp = tmp || fragment.appendChild( context.createElement("div") );

  					// Deserialize a standard representation
  					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  					wrap = wrapMap[ tag ] || wrapMap._default;
  					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

  					// Descend through wrappers to the right content
  					j = wrap[ 0 ];
  					while ( j-- ) {
  						tmp = tmp.lastChild;
  					}

  					// Support: QtWebKit, PhantomJS
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, tmp.childNodes );

  					// Remember the top-level container
  					tmp = fragment.firstChild;

  					// Ensure the created nodes are orphaned (#12392)
  					tmp.textContent = "";
  				}
  			}
  		}

  		// Remove wrapper from fragment
  		fragment.textContent = "";

  		i = 0;
  		while ( (elem = nodes[ i++ ]) ) {

  			// #4087 - If origin and destination elements are the same, and this is
  			// that element, do not do anything
  			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
  				continue;
  			}

  			contains = jQuery.contains( elem.ownerDocument, elem );

  			// Append to fragment
  			tmp = getAll( fragment.appendChild( elem ), "script" );

  			// Preserve script evaluation history
  			if ( contains ) {
  				setGlobalEval( tmp );
  			}

  			// Capture executables
  			if ( scripts ) {
  				j = 0;
  				while ( (elem = tmp[ j++ ]) ) {
  					if ( rscriptType.test( elem.type || "" ) ) {
  						scripts.push( elem );
  					}
  				}
  			}
  		}

  		return fragment;
  	},

  	cleanData: function( elems ) {
  		var data, elem, type, key,
  			special = jQuery.event.special,
  			i = 0;

  		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
  			if ( jQuery.acceptData( elem ) ) {
  				key = elem[ data_priv.expando ];

  				if ( key && (data = data_priv.cache[ key ]) ) {
  					if ( data.events ) {
  						for ( type in data.events ) {
  							if ( special[ type ] ) {
  								jQuery.event.remove( elem, type );

  							// This is a shortcut to avoid jQuery.event.remove's overhead
  							} else {
  								jQuery.removeEvent( elem, type, data.handle );
  							}
  						}
  					}
  					if ( data_priv.cache[ key ] ) {
  						// Discard any remaining `private` data
  						delete data_priv.cache[ key ];
  					}
  				}
  			}
  			// Discard any remaining `user` data
  			delete data_user.cache[ elem[ data_user.expando ] ];
  		}
  	}
  });

  jQuery.fn.extend({
  	text: function( value ) {
  		return access( this, function( value ) {
  			return value === undefined ?
  				jQuery.text( this ) :
  				this.empty().each(function() {
  					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  						this.textContent = value;
  					}
  				});
  		}, null, value, arguments.length );
  	},

  	append: function() {
  		return this.domManip( arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.appendChild( elem );
  			}
  		});
  	},

  	prepend: function() {
  		return this.domManip( arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.insertBefore( elem, target.firstChild );
  			}
  		});
  	},

  	before: function() {
  		return this.domManip( arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this );
  			}
  		});
  	},

  	after: function() {
  		return this.domManip( arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this.nextSibling );
  			}
  		});
  	},

  	remove: function( selector, keepData /* Internal Use Only */ ) {
  		var elem,
  			elems = selector ? jQuery.filter( selector, this ) : this,
  			i = 0;

  		for ( ; (elem = elems[i]) != null; i++ ) {
  			if ( !keepData && elem.nodeType === 1 ) {
  				jQuery.cleanData( getAll( elem ) );
  			}

  			if ( elem.parentNode ) {
  				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
  					setGlobalEval( getAll( elem, "script" ) );
  				}
  				elem.parentNode.removeChild( elem );
  			}
  		}

  		return this;
  	},

  	empty: function() {
  		var elem,
  			i = 0;

  		for ( ; (elem = this[i]) != null; i++ ) {
  			if ( elem.nodeType === 1 ) {

  				// Prevent memory leaks
  				jQuery.cleanData( getAll( elem, false ) );

  				// Remove any remaining nodes
  				elem.textContent = "";
  			}
  		}

  		return this;
  	},

  	clone: function( dataAndEvents, deepDataAndEvents ) {
  		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  		return this.map(function() {
  			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  		});
  	},

  	html: function( value ) {
  		return access( this, function( value ) {
  			var elem = this[ 0 ] || {},
  				i = 0,
  				l = this.length;

  			if ( value === undefined && elem.nodeType === 1 ) {
  				return elem.innerHTML;
  			}

  			// See if we can take a shortcut and just use innerHTML
  			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  				value = value.replace( rxhtmlTag, "<$1></$2>" );

  				try {
  					for ( ; i < l; i++ ) {
  						elem = this[ i ] || {};

  						// Remove element nodes and prevent memory leaks
  						if ( elem.nodeType === 1 ) {
  							jQuery.cleanData( getAll( elem, false ) );
  							elem.innerHTML = value;
  						}
  					}

  					elem = 0;

  				// If using innerHTML throws an exception, use the fallback method
  				} catch( e ) {}
  			}

  			if ( elem ) {
  				this.empty().append( value );
  			}
  		}, null, value, arguments.length );
  	},

  	replaceWith: function() {
  		var arg = arguments[ 0 ];

  		// Make the changes, replacing each context element with the new content
  		this.domManip( arguments, function( elem ) {
  			arg = this.parentNode;

  			jQuery.cleanData( getAll( this ) );

  			if ( arg ) {
  				arg.replaceChild( elem, this );
  			}
  		});

  		// Force removal if there was no new content (e.g., from empty arguments)
  		return arg && (arg.length || arg.nodeType) ? this : this.remove();
  	},

  	detach: function( selector ) {
  		return this.remove( selector, true );
  	},

  	domManip: function( args, callback ) {

  		// Flatten any nested arrays
  		args = concat.apply( [], args );

  		var fragment, first, scripts, hasScripts, node, doc,
  			i = 0,
  			l = this.length,
  			set = this,
  			iNoClone = l - 1,
  			value = args[ 0 ],
  			isFunction = jQuery.isFunction( value );

  		// We can't cloneNode fragments that contain checked, in WebKit
  		if ( isFunction ||
  				( l > 1 && typeof value === "string" &&
  					!support.checkClone && rchecked.test( value ) ) ) {
  			return this.each(function( index ) {
  				var self = set.eq( index );
  				if ( isFunction ) {
  					args[ 0 ] = value.call( this, index, self.html() );
  				}
  				self.domManip( args, callback );
  			});
  		}

  		if ( l ) {
  			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
  			first = fragment.firstChild;

  			if ( fragment.childNodes.length === 1 ) {
  				fragment = first;
  			}

  			if ( first ) {
  				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  				hasScripts = scripts.length;

  				// Use the original fragment for the last item instead of the first because it can end up
  				// being emptied incorrectly in certain situations (#8070).
  				for ( ; i < l; i++ ) {
  					node = fragment;

  					if ( i !== iNoClone ) {
  						node = jQuery.clone( node, true, true );

  						// Keep references to cloned scripts for later restoration
  						if ( hasScripts ) {
  							// Support: QtWebKit
  							// jQuery.merge because push.apply(_, arraylike) throws
  							jQuery.merge( scripts, getAll( node, "script" ) );
  						}
  					}

  					callback.call( this[ i ], node, i );
  				}

  				if ( hasScripts ) {
  					doc = scripts[ scripts.length - 1 ].ownerDocument;

  					// Reenable scripts
  					jQuery.map( scripts, restoreScript );

  					// Evaluate executable scripts on first document insertion
  					for ( i = 0; i < hasScripts; i++ ) {
  						node = scripts[ i ];
  						if ( rscriptType.test( node.type || "" ) &&
  							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

  							if ( node.src ) {
  								// Optional AJAX dependency, but won't run scripts if not present
  								if ( jQuery._evalUrl ) {
  									jQuery._evalUrl( node.src );
  								}
  							} else {
  								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
  							}
  						}
  					}
  				}
  			}
  		}

  		return this;
  	}
  });

  jQuery.each({
  	appendTo: "append",
  	prependTo: "prepend",
  	insertBefore: "before",
  	insertAfter: "after",
  	replaceAll: "replaceWith"
  }, function( name, original ) {
  	jQuery.fn[ name ] = function( selector ) {
  		var elems,
  			ret = [],
  			insert = jQuery( selector ),
  			last = insert.length - 1,
  			i = 0;

  		for ( ; i <= last; i++ ) {
  			elems = i === last ? this : this.clone( true );
  			jQuery( insert[ i ] )[ original ]( elems );

  			// Support: QtWebKit
  			// .get() because push.apply(_, arraylike) throws
  			push.apply( ret, elems.get() );
  		}

  		return this.pushStack( ret );
  	};
  });


  var iframe,
  	elemdisplay = {};

  /**
   * Retrieve the actual display of a element
   * @param {String} name nodeName of the element
   * @param {Object} doc Document object
   */
  // Called only from within defaultDisplay
  function actualDisplay( name, doc ) {
  	var style,
  		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

  		// getDefaultComputedStyle might be reliably used only on attached element
  		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

  			// Use of this method is a temporary fix (more like optimization) until something better comes along,
  			// since it was removed from specification and supported only in FF
  			style.display : jQuery.css( elem[ 0 ], "display" );

  	// We don't have any data stored on the element,
  	// so use "detach" method as fast way to get rid of the element
  	elem.detach();

  	return display;
  }

  /**
   * Try to determine the default display value of an element
   * @param {String} nodeName
   */
  function defaultDisplay( nodeName ) {
  	var doc = document,
  		display = elemdisplay[ nodeName ];

  	if ( !display ) {
  		display = actualDisplay( nodeName, doc );

  		// If the simple way fails, read from inside an iframe
  		if ( display === "none" || !display ) {

  			// Use the already-created iframe if possible
  			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

  			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
  			doc = iframe[ 0 ].contentDocument;

  			// Support: IE
  			doc.write();
  			doc.close();

  			display = actualDisplay( nodeName, doc );
  			iframe.detach();
  		}

  		// Store the correct default display
  		elemdisplay[ nodeName ] = display;
  	}

  	return display;
  }
  var rmargin = (/^margin/);

  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  var getStyles = function( elem ) {
  		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
  		// IE throws on elements created in popups
  		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  		if ( elem.ownerDocument.defaultView.opener ) {
  			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
  		}

  		return window.getComputedStyle( elem, null );
  	};



  function curCSS( elem, name, computed ) {
  	var width, minWidth, maxWidth, ret,
  		style = elem.style;

  	computed = computed || getStyles( elem );

  	// Support: IE9
  	// getPropertyValue is only needed for .css('filter') (#12537)
  	if ( computed ) {
  		ret = computed.getPropertyValue( name ) || computed[ name ];
  	}

  	if ( computed ) {

  		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
  			ret = jQuery.style( elem, name );
  		}

  		// Support: iOS < 6
  		// A tribute to the "awesome hack by Dean Edwards"
  		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
  		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
  		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

  			// Remember the original values
  			width = style.width;
  			minWidth = style.minWidth;
  			maxWidth = style.maxWidth;

  			// Put in the new values to get a computed value out
  			style.minWidth = style.maxWidth = style.width = ret;
  			ret = computed.width;

  			// Revert the changed values
  			style.width = width;
  			style.minWidth = minWidth;
  			style.maxWidth = maxWidth;
  		}
  	}

  	return ret !== undefined ?
  		// Support: IE
  		// IE returns zIndex value as an integer.
  		ret + "" :
  		ret;
  }


  function addGetHookIf( conditionFn, hookFn ) {
  	// Define the hook, we'll check on the first run if it's really needed.
  	return {
  		get: function() {
  			if ( conditionFn() ) {
  				// Hook not needed (or it's not possible to use it due
  				// to missing dependency), remove it.
  				delete this.get;
  				return;
  			}

  			// Hook needed; redefine it so that the support test is not executed again.
  			return (this.get = hookFn).apply( this, arguments );
  		}
  	};
  }


  (function() {
  	var pixelPositionVal, boxSizingReliableVal,
  		docElem = document.documentElement,
  		container = document.createElement( "div" ),
  		div = document.createElement( "div" );

  	if ( !div.style ) {
  		return;
  	}

  	// Support: IE9-11+
  	// Style of cloned element affects source element cloned (#8908)
  	div.style.backgroundClip = "content-box";
  	div.cloneNode( true ).style.backgroundClip = "";
  	support.clearCloneStyle = div.style.backgroundClip === "content-box";

  	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
  		"position:absolute";
  	container.appendChild( div );

  	// Executing both pixelPosition & boxSizingReliable tests require only one layout
  	// so they're executed at the same time to save the second computation.
  	function computePixelPositionAndBoxSizingReliable() {
  		div.style.cssText =
  			// Support: Firefox<29, Android 2.3
  			// Vendor-prefix box-sizing
  			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
  			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
  			"border:1px;padding:1px;width:4px;position:absolute";
  		div.innerHTML = "";
  		docElem.appendChild( container );

  		var divStyle = window.getComputedStyle( div, null );
  		pixelPositionVal = divStyle.top !== "1%";
  		boxSizingReliableVal = divStyle.width === "4px";

  		docElem.removeChild( container );
  	}

  	// Support: node.js jsdom
  	// Don't assume that getComputedStyle is a property of the global object
  	if ( window.getComputedStyle ) {
  		jQuery.extend( support, {
  			pixelPosition: function() {

  				// This test is executed only once but we still do memoizing
  				// since we can use the boxSizingReliable pre-computing.
  				// No need to check if the test was already performed, though.
  				computePixelPositionAndBoxSizingReliable();
  				return pixelPositionVal;
  			},
  			boxSizingReliable: function() {
  				if ( boxSizingReliableVal == null ) {
  					computePixelPositionAndBoxSizingReliable();
  				}
  				return boxSizingReliableVal;
  			},
  			reliableMarginRight: function() {

  				// Support: Android 2.3
  				// Check if div with explicit width and no margin-right incorrectly
  				// gets computed margin-right based on width of container. (#3333)
  				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
  				// This support function is only executed once so no memoizing is needed.
  				var ret,
  					marginDiv = div.appendChild( document.createElement( "div" ) );

  				// Reset CSS: box-sizing; display; margin; border; padding
  				marginDiv.style.cssText = div.style.cssText =
  					// Support: Firefox<29, Android 2.3
  					// Vendor-prefix box-sizing
  					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
  					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
  				marginDiv.style.marginRight = marginDiv.style.width = "0";
  				div.style.width = "1px";
  				docElem.appendChild( container );

  				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

  				docElem.removeChild( container );
  				div.removeChild( marginDiv );

  				return ret;
  			}
  		});
  	}
  })();


  // A method for quickly swapping in/out CSS properties to get correct calculations.
  jQuery.swap = function( elem, options, callback, args ) {
  	var ret, name,
  		old = {};

  	// Remember the old values, and insert the new ones
  	for ( name in options ) {
  		old[ name ] = elem.style[ name ];
  		elem.style[ name ] = options[ name ];
  	}

  	ret = callback.apply( elem, args || [] );

  	// Revert the old values
  	for ( name in options ) {
  		elem.style[ name ] = old[ name ];
  	}

  	return ret;
  };


  var
  	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
  	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

  	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  	cssNormalTransform = {
  		letterSpacing: "0",
  		fontWeight: "400"
  	},

  	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName( style, name ) {

  	// Shortcut for names that are not vendor prefixed
  	if ( name in style ) {
  		return name;
  	}

  	// Check for vendor prefixed names
  	var capName = name[0].toUpperCase() + name.slice(1),
  		origName = name,
  		i = cssPrefixes.length;

  	while ( i-- ) {
  		name = cssPrefixes[ i ] + capName;
  		if ( name in style ) {
  			return name;
  		}
  	}

  	return origName;
  }

  function setPositiveNumber( elem, value, subtract ) {
  	var matches = rnumsplit.exec( value );
  	return matches ?
  		// Guard against undefined "subtract", e.g., when used as in cssHooks
  		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
  		value;
  }

  function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
  	var i = extra === ( isBorderBox ? "border" : "content" ) ?
  		// If we already have the right measurement, avoid augmentation
  		4 :
  		// Otherwise initialize for horizontal or vertical properties
  		name === "width" ? 1 : 0,

  		val = 0;

  	for ( ; i < 4; i += 2 ) {
  		// Both box models exclude margin, so add it if we want it
  		if ( extra === "margin" ) {
  			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
  		}

  		if ( isBorderBox ) {
  			// border-box includes padding, so remove it if we want content
  			if ( extra === "content" ) {
  				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  			}

  			// At this point, extra isn't border nor margin, so remove border
  			if ( extra !== "margin" ) {
  				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		} else {
  			// At this point, extra isn't content, so add padding
  			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  			// At this point, extra isn't content nor padding, so add border
  			if ( extra !== "padding" ) {
  				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		}
  	}

  	return val;
  }

  function getWidthOrHeight( elem, name, extra ) {

  	// Start with offset property, which is equivalent to the border-box value
  	var valueIsBorderBox = true,
  		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
  		styles = getStyles( elem ),
  		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
  	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
  	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
  	if ( val <= 0 || val == null ) {
  		// Fall back to computed then uncomputed css if necessary
  		val = curCSS( elem, name, styles );
  		if ( val < 0 || val == null ) {
  			val = elem.style[ name ];
  		}

  		// Computed unit is not pixels. Stop here and return.
  		if ( rnumnonpx.test(val) ) {
  			return val;
  		}

  		// Check for style in case a browser which returns unreliable values
  		// for getComputedStyle silently falls back to the reliable elem.style
  		valueIsBorderBox = isBorderBox &&
  			( support.boxSizingReliable() || val === elem.style[ name ] );

  		// Normalize "", auto, and prepare for extra
  		val = parseFloat( val ) || 0;
  	}

  	// Use the active box-sizing model to add/subtract irrelevant styles
  	return ( val +
  		augmentWidthOrHeight(
  			elem,
  			name,
  			extra || ( isBorderBox ? "border" : "content" ),
  			valueIsBorderBox,
  			styles
  		)
  	) + "px";
  }

  function showHide( elements, show ) {
  	var display, elem, hidden,
  		values = [],
  		index = 0,
  		length = elements.length;

  	for ( ; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}

  		values[ index ] = data_priv.get( elem, "olddisplay" );
  		display = elem.style.display;
  		if ( show ) {
  			// Reset the inline display of this element to learn if it is
  			// being hidden by cascaded rules or not
  			if ( !values[ index ] && display === "none" ) {
  				elem.style.display = "";
  			}

  			// Set elements which have been overridden with display: none
  			// in a stylesheet to whatever the default browser style is
  			// for such an element
  			if ( elem.style.display === "" && isHidden( elem ) ) {
  				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
  			}
  		} else {
  			hidden = isHidden( elem );

  			if ( display !== "none" || !hidden ) {
  				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
  			}
  		}
  	}

  	// Set the display of most of the elements in a second loop
  	// to avoid the constant reflow
  	for ( index = 0; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}
  		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
  			elem.style.display = show ? values[ index ] || "" : "none";
  		}
  	}

  	return elements;
  }

  jQuery.extend({

  	// Add in style property hooks for overriding the default
  	// behavior of getting and setting a style property
  	cssHooks: {
  		opacity: {
  			get: function( elem, computed ) {
  				if ( computed ) {

  					// We should always get a number back from opacity
  					var ret = curCSS( elem, "opacity" );
  					return ret === "" ? "1" : ret;
  				}
  			}
  		}
  	},

  	// Don't automatically add "px" to these possibly-unitless properties
  	cssNumber: {
  		"columnCount": true,
  		"fillOpacity": true,
  		"flexGrow": true,
  		"flexShrink": true,
  		"fontWeight": true,
  		"lineHeight": true,
  		"opacity": true,
  		"order": true,
  		"orphans": true,
  		"widows": true,
  		"zIndex": true,
  		"zoom": true
  	},

  	// Add in properties whose names you wish to fix before
  	// setting or getting the value
  	cssProps: {
  		"float": "cssFloat"
  	},

  	// Get and set the style property on a DOM Node
  	style: function( elem, name, value, extra ) {

  		// Don't set styles on text and comment nodes
  		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  			return;
  		}

  		// Make sure that we're working with the right name
  		var ret, type, hooks,
  			origName = jQuery.camelCase( name ),
  			style = elem.style;

  		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

  		// Gets hook for the prefixed version, then unprefixed version
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// Check if we're setting a value
  		if ( value !== undefined ) {
  			type = typeof value;

  			// Convert "+=" or "-=" to relative numbers (#7345)
  			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
  				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
  				// Fixes bug #9237
  				type = "number";
  			}

  			// Make sure that null and NaN values aren't set (#7116)
  			if ( value == null || value !== value ) {
  				return;
  			}

  			// If a number, add 'px' to the (except for certain CSS properties)
  			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
  				value += "px";
  			}

  			// Support: IE9-11+
  			// background-* props affect original clone's values
  			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  				style[ name ] = "inherit";
  			}

  			// If a hook was provided, use that value, otherwise just set the specified value
  			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
  				style[ name ] = value;
  			}

  		} else {
  			// If a hook was provided get the non-computed value from there
  			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
  				return ret;
  			}

  			// Otherwise just get the value from the style object
  			return style[ name ];
  		}
  	},

  	css: function( elem, name, extra, styles ) {
  		var val, num, hooks,
  			origName = jQuery.camelCase( name );

  		// Make sure that we're working with the right name
  		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

  		// Try prefixed name followed by the unprefixed name
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// If a hook was provided get the computed value from there
  		if ( hooks && "get" in hooks ) {
  			val = hooks.get( elem, true, extra );
  		}

  		// Otherwise, if a way to get the computed value exists, use that
  		if ( val === undefined ) {
  			val = curCSS( elem, name, styles );
  		}

  		// Convert "normal" to computed value
  		if ( val === "normal" && name in cssNormalTransform ) {
  			val = cssNormalTransform[ name ];
  		}

  		// Make numeric if forced or a qualifier was provided and val looks numeric
  		if ( extra === "" || extra ) {
  			num = parseFloat( val );
  			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
  		}
  		return val;
  	}
  });

  jQuery.each([ "height", "width" ], function( i, name ) {
  	jQuery.cssHooks[ name ] = {
  		get: function( elem, computed, extra ) {
  			if ( computed ) {

  				// Certain elements can have dimension info if we invisibly show them
  				// but it must have a current display style that would benefit
  				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
  					jQuery.swap( elem, cssShow, function() {
  						return getWidthOrHeight( elem, name, extra );
  					}) :
  					getWidthOrHeight( elem, name, extra );
  			}
  		},

  		set: function( elem, value, extra ) {
  			var styles = extra && getStyles( elem );
  			return setPositiveNumber( elem, value, extra ?
  				augmentWidthOrHeight(
  					elem,
  					name,
  					extra,
  					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  					styles
  				) : 0
  			);
  		}
  	};
  });

  // Support: Android 2.3
  jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
  	function( elem, computed ) {
  		if ( computed ) {
  			return jQuery.swap( elem, { "display": "inline-block" },
  				curCSS, [ elem, "marginRight" ] );
  		}
  	}
  );

  // These hooks are used by animate to expand properties
  jQuery.each({
  	margin: "",
  	padding: "",
  	border: "Width"
  }, function( prefix, suffix ) {
  	jQuery.cssHooks[ prefix + suffix ] = {
  		expand: function( value ) {
  			var i = 0,
  				expanded = {},

  				// Assumes a single number if not a string
  				parts = typeof value === "string" ? value.split(" ") : [ value ];

  			for ( ; i < 4; i++ ) {
  				expanded[ prefix + cssExpand[ i ] + suffix ] =
  					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  			}

  			return expanded;
  		}
  	};

  	if ( !rmargin.test( prefix ) ) {
  		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  	}
  });

  jQuery.fn.extend({
  	css: function( name, value ) {
  		return access( this, function( elem, name, value ) {
  			var styles, len,
  				map = {},
  				i = 0;

  			if ( jQuery.isArray( name ) ) {
  				styles = getStyles( elem );
  				len = name.length;

  				for ( ; i < len; i++ ) {
  					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  				}

  				return map;
  			}

  			return value !== undefined ?
  				jQuery.style( elem, name, value ) :
  				jQuery.css( elem, name );
  		}, name, value, arguments.length > 1 );
  	},
  	show: function() {
  		return showHide( this, true );
  	},
  	hide: function() {
  		return showHide( this );
  	},
  	toggle: function( state ) {
  		if ( typeof state === "boolean" ) {
  			return state ? this.show() : this.hide();
  		}

  		return this.each(function() {
  			if ( isHidden( this ) ) {
  				jQuery( this ).show();
  			} else {
  				jQuery( this ).hide();
  			}
  		});
  	}
  });


  function Tween( elem, options, prop, end, easing ) {
  	return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
  	constructor: Tween,
  	init: function( elem, options, prop, end, easing, unit ) {
  		this.elem = elem;
  		this.prop = prop;
  		this.easing = easing || "swing";
  		this.options = options;
  		this.start = this.now = this.cur();
  		this.end = end;
  		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  	},
  	cur: function() {
  		var hooks = Tween.propHooks[ this.prop ];

  		return hooks && hooks.get ?
  			hooks.get( this ) :
  			Tween.propHooks._default.get( this );
  	},
  	run: function( percent ) {
  		var eased,
  			hooks = Tween.propHooks[ this.prop ];

  		if ( this.options.duration ) {
  			this.pos = eased = jQuery.easing[ this.easing ](
  				percent, this.options.duration * percent, 0, 1, this.options.duration
  			);
  		} else {
  			this.pos = eased = percent;
  		}
  		this.now = ( this.end - this.start ) * eased + this.start;

  		if ( this.options.step ) {
  			this.options.step.call( this.elem, this.now, this );
  		}

  		if ( hooks && hooks.set ) {
  			hooks.set( this );
  		} else {
  			Tween.propHooks._default.set( this );
  		}
  		return this;
  	}
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
  	_default: {
  		get: function( tween ) {
  			var result;

  			if ( tween.elem[ tween.prop ] != null &&
  				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
  				return tween.elem[ tween.prop ];
  			}

  			// Passing an empty string as a 3rd parameter to .css will automatically
  			// attempt a parseFloat and fallback to a string if the parse fails.
  			// Simple values such as "10px" are parsed to Float;
  			// complex values such as "rotate(1rad)" are returned as-is.
  			result = jQuery.css( tween.elem, tween.prop, "" );
  			// Empty strings, null, undefined and "auto" are converted to 0.
  			return !result || result === "auto" ? 0 : result;
  		},
  		set: function( tween ) {
  			// Use step hook for back compat.
  			// Use cssHook if its there.
  			// Use .style if available and use plain properties where available.
  			if ( jQuery.fx.step[ tween.prop ] ) {
  				jQuery.fx.step[ tween.prop ]( tween );
  			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
  				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  			} else {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	}
  };

  // Support: IE9
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  	set: function( tween ) {
  		if ( tween.elem.nodeType && tween.elem.parentNode ) {
  			tween.elem[ tween.prop ] = tween.now;
  		}
  	}
  };

  jQuery.easing = {
  	linear: function( p ) {
  		return p;
  	},
  	swing: function( p ) {
  		return 0.5 - Math.cos( p * Math.PI ) / 2;
  	}
  };

  jQuery.fx = Tween.prototype.init;

  // Back Compat <1.8 extension point
  jQuery.fx.step = {};




  var
  	fxNow, timerId,
  	rfxtypes = /^(?:toggle|show|hide)$/,
  	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
  	rrun = /queueHooks$/,
  	animationPrefilters = [ defaultPrefilter ],
  	tweeners = {
  		"*": [ function( prop, value ) {
  			var tween = this.createTween( prop, value ),
  				target = tween.cur(),
  				parts = rfxnum.exec( value ),
  				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  				// Starting value computation is required for potential unit mismatches
  				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
  					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
  				scale = 1,
  				maxIterations = 20;

  			if ( start && start[ 3 ] !== unit ) {
  				// Trust units reported by jQuery.css
  				unit = unit || start[ 3 ];

  				// Make sure we update the tween properties later on
  				parts = parts || [];

  				// Iteratively approximate from a nonzero starting point
  				start = +target || 1;

  				do {
  					// If previous iteration zeroed out, double until we get *something*.
  					// Use string for doubling so we don't accidentally see scale as unchanged below
  					scale = scale || ".5";

  					// Adjust and apply
  					start = start / scale;
  					jQuery.style( tween.elem, prop, start + unit );

  				// Update scale, tolerating zero or NaN from tween.cur(),
  				// break the loop if scale is unchanged or perfect, or if we've just had enough
  				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
  			}

  			// Update tween properties
  			if ( parts ) {
  				start = tween.start = +start || +target || 0;
  				tween.unit = unit;
  				// If a +=/-= token was provided, we're doing a relative animation
  				tween.end = parts[ 1 ] ?
  					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
  					+parts[ 2 ];
  			}

  			return tween;
  		} ]
  	};

  // Animations created synchronously will run synchronously
  function createFxNow() {
  	setTimeout(function() {
  		fxNow = undefined;
  	});
  	return ( fxNow = jQuery.now() );
  }

  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
  	var which,
  		i = 0,
  		attrs = { height: type };

  	// If we include width, step value is 1 to do all cssExpand values,
  	// otherwise step value is 2 to skip over Left and Right
  	includeWidth = includeWidth ? 1 : 0;
  	for ( ; i < 4 ; i += 2 - includeWidth ) {
  		which = cssExpand[ i ];
  		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  	}

  	if ( includeWidth ) {
  		attrs.opacity = attrs.width = type;
  	}

  	return attrs;
  }

  function createTween( value, prop, animation ) {
  	var tween,
  		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
  		index = 0,
  		length = collection.length;
  	for ( ; index < length; index++ ) {
  		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

  			// We're done with this property
  			return tween;
  		}
  	}
  }

  function defaultPrefilter( elem, props, opts ) {
  	/* jshint validthis: true */
  	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
  		anim = this,
  		orig = {},
  		style = elem.style,
  		hidden = elem.nodeType && isHidden( elem ),
  		dataShow = data_priv.get( elem, "fxshow" );

  	// Handle queue: false promises
  	if ( !opts.queue ) {
  		hooks = jQuery._queueHooks( elem, "fx" );
  		if ( hooks.unqueued == null ) {
  			hooks.unqueued = 0;
  			oldfire = hooks.empty.fire;
  			hooks.empty.fire = function() {
  				if ( !hooks.unqueued ) {
  					oldfire();
  				}
  			};
  		}
  		hooks.unqueued++;

  		anim.always(function() {
  			// Ensure the complete handler is called before this completes
  			anim.always(function() {
  				hooks.unqueued--;
  				if ( !jQuery.queue( elem, "fx" ).length ) {
  					hooks.empty.fire();
  				}
  			});
  		});
  	}

  	// Height/width overflow pass
  	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
  		// Make sure that nothing sneaks out
  		// Record all 3 overflow attributes because IE9-10 do not
  		// change the overflow attribute when overflowX and
  		// overflowY are set to the same value
  		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  		// Set display property to inline-block for height/width
  		// animations on inline elements that are having width/height animated
  		display = jQuery.css( elem, "display" );

  		// Test default display if display is currently "none"
  		checkDisplay = display === "none" ?
  			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

  		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
  			style.display = "inline-block";
  		}
  	}

  	if ( opts.overflow ) {
  		style.overflow = "hidden";
  		anim.always(function() {
  			style.overflow = opts.overflow[ 0 ];
  			style.overflowX = opts.overflow[ 1 ];
  			style.overflowY = opts.overflow[ 2 ];
  		});
  	}

  	// show/hide pass
  	for ( prop in props ) {
  		value = props[ prop ];
  		if ( rfxtypes.exec( value ) ) {
  			delete props[ prop ];
  			toggle = toggle || value === "toggle";
  			if ( value === ( hidden ? "hide" : "show" ) ) {

  				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
  				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  					hidden = true;
  				} else {
  					continue;
  				}
  			}
  			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

  		// Any non-fx value stops us from restoring the original display value
  		} else {
  			display = undefined;
  		}
  	}

  	if ( !jQuery.isEmptyObject( orig ) ) {
  		if ( dataShow ) {
  			if ( "hidden" in dataShow ) {
  				hidden = dataShow.hidden;
  			}
  		} else {
  			dataShow = data_priv.access( elem, "fxshow", {} );
  		}

  		// Store state if its toggle - enables .stop().toggle() to "reverse"
  		if ( toggle ) {
  			dataShow.hidden = !hidden;
  		}
  		if ( hidden ) {
  			jQuery( elem ).show();
  		} else {
  			anim.done(function() {
  				jQuery( elem ).hide();
  			});
  		}
  		anim.done(function() {
  			var prop;

  			data_priv.remove( elem, "fxshow" );
  			for ( prop in orig ) {
  				jQuery.style( elem, prop, orig[ prop ] );
  			}
  		});
  		for ( prop in orig ) {
  			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

  			if ( !( prop in dataShow ) ) {
  				dataShow[ prop ] = tween.start;
  				if ( hidden ) {
  					tween.end = tween.start;
  					tween.start = prop === "width" || prop === "height" ? 1 : 0;
  				}
  			}
  		}

  	// If this is a noop like .hide().hide(), restore an overwritten display value
  	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
  		style.display = display;
  	}
  }

  function propFilter( props, specialEasing ) {
  	var index, name, easing, value, hooks;

  	// camelCase, specialEasing and expand cssHook pass
  	for ( index in props ) {
  		name = jQuery.camelCase( index );
  		easing = specialEasing[ name ];
  		value = props[ index ];
  		if ( jQuery.isArray( value ) ) {
  			easing = value[ 1 ];
  			value = props[ index ] = value[ 0 ];
  		}

  		if ( index !== name ) {
  			props[ name ] = value;
  			delete props[ index ];
  		}

  		hooks = jQuery.cssHooks[ name ];
  		if ( hooks && "expand" in hooks ) {
  			value = hooks.expand( value );
  			delete props[ name ];

  			// Not quite $.extend, this won't overwrite existing keys.
  			// Reusing 'index' because we have the correct "name"
  			for ( index in value ) {
  				if ( !( index in props ) ) {
  					props[ index ] = value[ index ];
  					specialEasing[ index ] = easing;
  				}
  			}
  		} else {
  			specialEasing[ name ] = easing;
  		}
  	}
  }

  function Animation( elem, properties, options ) {
  	var result,
  		stopped,
  		index = 0,
  		length = animationPrefilters.length,
  		deferred = jQuery.Deferred().always( function() {
  			// Don't match elem in the :animated selector
  			delete tick.elem;
  		}),
  		tick = function() {
  			if ( stopped ) {
  				return false;
  			}
  			var currentTime = fxNow || createFxNow(),
  				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
  				// Support: Android 2.3
  				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
  				temp = remaining / animation.duration || 0,
  				percent = 1 - temp,
  				index = 0,
  				length = animation.tweens.length;

  			for ( ; index < length ; index++ ) {
  				animation.tweens[ index ].run( percent );
  			}

  			deferred.notifyWith( elem, [ animation, percent, remaining ]);

  			if ( percent < 1 && length ) {
  				return remaining;
  			} else {
  				deferred.resolveWith( elem, [ animation ] );
  				return false;
  			}
  		},
  		animation = deferred.promise({
  			elem: elem,
  			props: jQuery.extend( {}, properties ),
  			opts: jQuery.extend( true, { specialEasing: {} }, options ),
  			originalProperties: properties,
  			originalOptions: options,
  			startTime: fxNow || createFxNow(),
  			duration: options.duration,
  			tweens: [],
  			createTween: function( prop, end ) {
  				var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  				animation.tweens.push( tween );
  				return tween;
  			},
  			stop: function( gotoEnd ) {
  				var index = 0,
  					// If we are going to the end, we want to run all the tweens
  					// otherwise we skip this part
  					length = gotoEnd ? animation.tweens.length : 0;
  				if ( stopped ) {
  					return this;
  				}
  				stopped = true;
  				for ( ; index < length ; index++ ) {
  					animation.tweens[ index ].run( 1 );
  				}

  				// Resolve when we played the last frame; otherwise, reject
  				if ( gotoEnd ) {
  					deferred.resolveWith( elem, [ animation, gotoEnd ] );
  				} else {
  					deferred.rejectWith( elem, [ animation, gotoEnd ] );
  				}
  				return this;
  			}
  		}),
  		props = animation.props;

  	propFilter( props, animation.opts.specialEasing );

  	for ( ; index < length ; index++ ) {
  		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
  		if ( result ) {
  			return result;
  		}
  	}

  	jQuery.map( props, createTween, animation );

  	if ( jQuery.isFunction( animation.opts.start ) ) {
  		animation.opts.start.call( elem, animation );
  	}

  	jQuery.fx.timer(
  		jQuery.extend( tick, {
  			elem: elem,
  			anim: animation,
  			queue: animation.opts.queue
  		})
  	);

  	// attach callbacks from options
  	return animation.progress( animation.opts.progress )
  		.done( animation.opts.done, animation.opts.complete )
  		.fail( animation.opts.fail )
  		.always( animation.opts.always );
  }

  jQuery.Animation = jQuery.extend( Animation, {

  	tweener: function( props, callback ) {
  		if ( jQuery.isFunction( props ) ) {
  			callback = props;
  			props = [ "*" ];
  		} else {
  			props = props.split(" ");
  		}

  		var prop,
  			index = 0,
  			length = props.length;

  		for ( ; index < length ; index++ ) {
  			prop = props[ index ];
  			tweeners[ prop ] = tweeners[ prop ] || [];
  			tweeners[ prop ].unshift( callback );
  		}
  	},

  	prefilter: function( callback, prepend ) {
  		if ( prepend ) {
  			animationPrefilters.unshift( callback );
  		} else {
  			animationPrefilters.push( callback );
  		}
  	}
  });

  jQuery.speed = function( speed, easing, fn ) {
  	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  		complete: fn || !fn && easing ||
  			jQuery.isFunction( speed ) && speed,
  		duration: speed,
  		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
  	};

  	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
  		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

  	// Normalize opt.queue - true/undefined/null -> "fx"
  	if ( opt.queue == null || opt.queue === true ) {
  		opt.queue = "fx";
  	}

  	// Queueing
  	opt.old = opt.complete;

  	opt.complete = function() {
  		if ( jQuery.isFunction( opt.old ) ) {
  			opt.old.call( this );
  		}

  		if ( opt.queue ) {
  			jQuery.dequeue( this, opt.queue );
  		}
  	};

  	return opt;
  };

  jQuery.fn.extend({
  	fadeTo: function( speed, to, easing, callback ) {

  		// Show any hidden elements after setting opacity to 0
  		return this.filter( isHidden ).css( "opacity", 0 ).show()

  			// Animate to the value specified
  			.end().animate({ opacity: to }, speed, easing, callback );
  	},
  	animate: function( prop, speed, easing, callback ) {
  		var empty = jQuery.isEmptyObject( prop ),
  			optall = jQuery.speed( speed, easing, callback ),
  			doAnimation = function() {
  				// Operate on a copy of prop so per-property easing won't be lost
  				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  				// Empty animations, or finishing resolves immediately
  				if ( empty || data_priv.get( this, "finish" ) ) {
  					anim.stop( true );
  				}
  			};
  			doAnimation.finish = doAnimation;

  		return empty || optall.queue === false ?
  			this.each( doAnimation ) :
  			this.queue( optall.queue, doAnimation );
  	},
  	stop: function( type, clearQueue, gotoEnd ) {
  		var stopQueue = function( hooks ) {
  			var stop = hooks.stop;
  			delete hooks.stop;
  			stop( gotoEnd );
  		};

  		if ( typeof type !== "string" ) {
  			gotoEnd = clearQueue;
  			clearQueue = type;
  			type = undefined;
  		}
  		if ( clearQueue && type !== false ) {
  			this.queue( type || "fx", [] );
  		}

  		return this.each(function() {
  			var dequeue = true,
  				index = type != null && type + "queueHooks",
  				timers = jQuery.timers,
  				data = data_priv.get( this );

  			if ( index ) {
  				if ( data[ index ] && data[ index ].stop ) {
  					stopQueue( data[ index ] );
  				}
  			} else {
  				for ( index in data ) {
  					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  						stopQueue( data[ index ] );
  					}
  				}
  			}

  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
  					timers[ index ].anim.stop( gotoEnd );
  					dequeue = false;
  					timers.splice( index, 1 );
  				}
  			}

  			// Start the next in the queue if the last step wasn't forced.
  			// Timers currently will call their complete callbacks, which
  			// will dequeue but only if they were gotoEnd.
  			if ( dequeue || !gotoEnd ) {
  				jQuery.dequeue( this, type );
  			}
  		});
  	},
  	finish: function( type ) {
  		if ( type !== false ) {
  			type = type || "fx";
  		}
  		return this.each(function() {
  			var index,
  				data = data_priv.get( this ),
  				queue = data[ type + "queue" ],
  				hooks = data[ type + "queueHooks" ],
  				timers = jQuery.timers,
  				length = queue ? queue.length : 0;

  			// Enable finishing flag on private data
  			data.finish = true;

  			// Empty the queue first
  			jQuery.queue( this, type, [] );

  			if ( hooks && hooks.stop ) {
  				hooks.stop.call( this, true );
  			}

  			// Look for any active animations, and finish them
  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  					timers[ index ].anim.stop( true );
  					timers.splice( index, 1 );
  				}
  			}

  			// Look for any animations in the old queue and finish them
  			for ( index = 0; index < length; index++ ) {
  				if ( queue[ index ] && queue[ index ].finish ) {
  					queue[ index ].finish.call( this );
  				}
  			}

  			// Turn off finishing flag
  			delete data.finish;
  		});
  	}
  });

  jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
  	var cssFn = jQuery.fn[ name ];
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return speed == null || typeof speed === "boolean" ?
  			cssFn.apply( this, arguments ) :
  			this.animate( genFx( name, true ), speed, easing, callback );
  	};
  });

  // Generate shortcuts for custom animations
  jQuery.each({
  	slideDown: genFx("show"),
  	slideUp: genFx("hide"),
  	slideToggle: genFx("toggle"),
  	fadeIn: { opacity: "show" },
  	fadeOut: { opacity: "hide" },
  	fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return this.animate( props, speed, easing, callback );
  	};
  });

  jQuery.timers = [];
  jQuery.fx.tick = function() {
  	var timer,
  		i = 0,
  		timers = jQuery.timers;

  	fxNow = jQuery.now();

  	for ( ; i < timers.length; i++ ) {
  		timer = timers[ i ];
  		// Checks the timer has not already been removed
  		if ( !timer() && timers[ i ] === timer ) {
  			timers.splice( i--, 1 );
  		}
  	}

  	if ( !timers.length ) {
  		jQuery.fx.stop();
  	}
  	fxNow = undefined;
  };

  jQuery.fx.timer = function( timer ) {
  	jQuery.timers.push( timer );
  	if ( timer() ) {
  		jQuery.fx.start();
  	} else {
  		jQuery.timers.pop();
  	}
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function() {
  	if ( !timerId ) {
  		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
  	}
  };

  jQuery.fx.stop = function() {
  	clearInterval( timerId );
  	timerId = null;
  };

  jQuery.fx.speeds = {
  	slow: 600,
  	fast: 200,
  	// Default speed
  	_default: 400
  };


  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function( time, type ) {
  	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  	type = type || "fx";

  	return this.queue( type, function( next, hooks ) {
  		var timeout = setTimeout( next, time );
  		hooks.stop = function() {
  			clearTimeout( timeout );
  		};
  	});
  };


  (function() {
  	var input = document.createElement( "input" ),
  		select = document.createElement( "select" ),
  		opt = select.appendChild( document.createElement( "option" ) );

  	input.type = "checkbox";

  	// Support: iOS<=5.1, Android<=4.2+
  	// Default value for a checkbox should be "on"
  	support.checkOn = input.value !== "";

  	// Support: IE<=11+
  	// Must access selectedIndex to make default options select
  	support.optSelected = opt.selected;

  	// Support: Android<=2.3
  	// Options inside disabled selects are incorrectly marked as disabled
  	select.disabled = true;
  	support.optDisabled = !opt.disabled;

  	// Support: IE<=11+
  	// An input loses its value after becoming a radio
  	input = document.createElement( "input" );
  	input.value = "t";
  	input.type = "radio";
  	support.radioValue = input.value === "t";
  })();


  var nodeHook, boolHook,
  	attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend({
  	attr: function( name, value ) {
  		return access( this, jQuery.attr, name, value, arguments.length > 1 );
  	},

  	removeAttr: function( name ) {
  		return this.each(function() {
  			jQuery.removeAttr( this, name );
  		});
  	}
  });

  jQuery.extend({
  	attr: function( elem, name, value ) {
  		var hooks, ret,
  			nType = elem.nodeType;

  		// don't get/set attributes on text, comment and attribute nodes
  		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		// Fallback to prop when attributes are not supported
  		if ( typeof elem.getAttribute === strundefined ) {
  			return jQuery.prop( elem, name, value );
  		}

  		// All attributes are lowercase
  		// Grab necessary hook if one is defined
  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  			name = name.toLowerCase();
  			hooks = jQuery.attrHooks[ name ] ||
  				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
  		}

  		if ( value !== undefined ) {

  			if ( value === null ) {
  				jQuery.removeAttr( elem, name );

  			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
  				return ret;

  			} else {
  				elem.setAttribute( name, value + "" );
  				return value;
  			}

  		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
  			return ret;

  		} else {
  			ret = jQuery.find.attr( elem, name );

  			// Non-existent attributes return null, we normalize to undefined
  			return ret == null ?
  				undefined :
  				ret;
  		}
  	},

  	removeAttr: function( elem, value ) {
  		var name, propName,
  			i = 0,
  			attrNames = value && value.match( rnotwhite );

  		if ( attrNames && elem.nodeType === 1 ) {
  			while ( (name = attrNames[i++]) ) {
  				propName = jQuery.propFix[ name ] || name;

  				// Boolean attributes get special treatment (#10870)
  				if ( jQuery.expr.match.bool.test( name ) ) {
  					// Set corresponding property to false
  					elem[ propName ] = false;
  				}

  				elem.removeAttribute( name );
  			}
  		}
  	},

  	attrHooks: {
  		type: {
  			set: function( elem, value ) {
  				if ( !support.radioValue && value === "radio" &&
  					jQuery.nodeName( elem, "input" ) ) {
  					var val = elem.value;
  					elem.setAttribute( "type", value );
  					if ( val ) {
  						elem.value = val;
  					}
  					return value;
  				}
  			}
  		}
  	}
  });

  // Hooks for boolean attributes
  boolHook = {
  	set: function( elem, value, name ) {
  		if ( value === false ) {
  			// Remove boolean attributes when set to false
  			jQuery.removeAttr( elem, name );
  		} else {
  			elem.setAttribute( name, name );
  		}
  		return name;
  	}
  };
  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
  	var getter = attrHandle[ name ] || jQuery.find.attr;

  	attrHandle[ name ] = function( elem, name, isXML ) {
  		var ret, handle;
  		if ( !isXML ) {
  			// Avoid an infinite loop by temporarily removing this function from the getter
  			handle = attrHandle[ name ];
  			attrHandle[ name ] = ret;
  			ret = getter( elem, name, isXML ) != null ?
  				name.toLowerCase() :
  				null;
  			attrHandle[ name ] = handle;
  		}
  		return ret;
  	};
  });




  var rfocusable = /^(?:input|select|textarea|button)$/i;

  jQuery.fn.extend({
  	prop: function( name, value ) {
  		return access( this, jQuery.prop, name, value, arguments.length > 1 );
  	},

  	removeProp: function( name ) {
  		return this.each(function() {
  			delete this[ jQuery.propFix[ name ] || name ];
  		});
  	}
  });

  jQuery.extend({
  	propFix: {
  		"for": "htmlFor",
  		"class": "className"
  	},

  	prop: function( elem, name, value ) {
  		var ret, hooks, notxml,
  			nType = elem.nodeType;

  		// Don't get/set properties on text, comment and attribute nodes
  		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

  		if ( notxml ) {
  			// Fix name and attach hooks
  			name = jQuery.propFix[ name ] || name;
  			hooks = jQuery.propHooks[ name ];
  		}

  		if ( value !== undefined ) {
  			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
  				ret :
  				( elem[ name ] = value );

  		} else {
  			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
  				ret :
  				elem[ name ];
  		}
  	},

  	propHooks: {
  		tabIndex: {
  			get: function( elem ) {
  				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
  					elem.tabIndex :
  					-1;
  			}
  		}
  	}
  });

  if ( !support.optSelected ) {
  	jQuery.propHooks.selected = {
  		get: function( elem ) {
  			var parent = elem.parentNode;
  			if ( parent && parent.parentNode ) {
  				parent.parentNode.selectedIndex;
  			}
  			return null;
  		}
  	};
  }

  jQuery.each([
  	"tabIndex",
  	"readOnly",
  	"maxLength",
  	"cellSpacing",
  	"cellPadding",
  	"rowSpan",
  	"colSpan",
  	"useMap",
  	"frameBorder",
  	"contentEditable"
  ], function() {
  	jQuery.propFix[ this.toLowerCase() ] = this;
  });




  var rclass = /[\t\r\n\f]/g;

  jQuery.fn.extend({
  	addClass: function( value ) {
  		var classes, elem, cur, clazz, j, finalValue,
  			proceed = typeof value === "string" && value,
  			i = 0,
  			len = this.length;

  		if ( jQuery.isFunction( value ) ) {
  			return this.each(function( j ) {
  				jQuery( this ).addClass( value.call( this, j, this.className ) );
  			});
  		}

  		if ( proceed ) {
  			// The disjunction here is for better compressibility (see removeClass)
  			classes = ( value || "" ).match( rnotwhite ) || [];

  			for ( ; i < len; i++ ) {
  				elem = this[ i ];
  				cur = elem.nodeType === 1 && ( elem.className ?
  					( " " + elem.className + " " ).replace( rclass, " " ) :
  					" "
  				);

  				if ( cur ) {
  					j = 0;
  					while ( (clazz = classes[j++]) ) {
  						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
  							cur += clazz + " ";
  						}
  					}

  					// only assign if different to avoid unneeded rendering.
  					finalValue = jQuery.trim( cur );
  					if ( elem.className !== finalValue ) {
  						elem.className = finalValue;
  					}
  				}
  			}
  		}

  		return this;
  	},

  	removeClass: function( value ) {
  		var classes, elem, cur, clazz, j, finalValue,
  			proceed = arguments.length === 0 || typeof value === "string" && value,
  			i = 0,
  			len = this.length;

  		if ( jQuery.isFunction( value ) ) {
  			return this.each(function( j ) {
  				jQuery( this ).removeClass( value.call( this, j, this.className ) );
  			});
  		}
  		if ( proceed ) {
  			classes = ( value || "" ).match( rnotwhite ) || [];

  			for ( ; i < len; i++ ) {
  				elem = this[ i ];
  				// This expression is here for better compressibility (see addClass)
  				cur = elem.nodeType === 1 && ( elem.className ?
  					( " " + elem.className + " " ).replace( rclass, " " ) :
  					""
  				);

  				if ( cur ) {
  					j = 0;
  					while ( (clazz = classes[j++]) ) {
  						// Remove *all* instances
  						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
  							cur = cur.replace( " " + clazz + " ", " " );
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = value ? jQuery.trim( cur ) : "";
  					if ( elem.className !== finalValue ) {
  						elem.className = finalValue;
  					}
  				}
  			}
  		}

  		return this;
  	},

  	toggleClass: function( value, stateVal ) {
  		var type = typeof value;

  		if ( typeof stateVal === "boolean" && type === "string" ) {
  			return stateVal ? this.addClass( value ) : this.removeClass( value );
  		}

  		if ( jQuery.isFunction( value ) ) {
  			return this.each(function( i ) {
  				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
  			});
  		}

  		return this.each(function() {
  			if ( type === "string" ) {
  				// Toggle individual class names
  				var className,
  					i = 0,
  					self = jQuery( this ),
  					classNames = value.match( rnotwhite ) || [];

  				while ( (className = classNames[ i++ ]) ) {
  					// Check each className given, space separated list
  					if ( self.hasClass( className ) ) {
  						self.removeClass( className );
  					} else {
  						self.addClass( className );
  					}
  				}

  			// Toggle whole class name
  			} else if ( type === strundefined || type === "boolean" ) {
  				if ( this.className ) {
  					// store className if set
  					data_priv.set( this, "__className__", this.className );
  				}

  				// If the element has a class name or if we're passed `false`,
  				// then remove the whole classname (if there was one, the above saved it).
  				// Otherwise bring back whatever was previously saved (if anything),
  				// falling back to the empty string if nothing was stored.
  				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
  			}
  		});
  	},

  	hasClass: function( selector ) {
  		var className = " " + selector + " ",
  			i = 0,
  			l = this.length;
  		for ( ; i < l; i++ ) {
  			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
  				return true;
  			}
  		}

  		return false;
  	}
  });




  var rreturn = /\r/g;

  jQuery.fn.extend({
  	val: function( value ) {
  		var hooks, ret, isFunction,
  			elem = this[0];

  		if ( !arguments.length ) {
  			if ( elem ) {
  				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
  					return ret;
  				}

  				ret = elem.value;

  				return typeof ret === "string" ?
  					// Handle most common string cases
  					ret.replace(rreturn, "") :
  					// Handle cases where value is null/undef or number
  					ret == null ? "" : ret;
  			}

  			return;
  		}

  		isFunction = jQuery.isFunction( value );

  		return this.each(function( i ) {
  			var val;

  			if ( this.nodeType !== 1 ) {
  				return;
  			}

  			if ( isFunction ) {
  				val = value.call( this, i, jQuery( this ).val() );
  			} else {
  				val = value;
  			}

  			// Treat null/undefined as ""; convert numbers to string
  			if ( val == null ) {
  				val = "";

  			} else if ( typeof val === "number" ) {
  				val += "";

  			} else if ( jQuery.isArray( val ) ) {
  				val = jQuery.map( val, function( value ) {
  					return value == null ? "" : value + "";
  				});
  			}

  			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  			// If set returns undefined, fall back to normal setting
  			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
  				this.value = val;
  			}
  		});
  	}
  });

  jQuery.extend({
  	valHooks: {
  		option: {
  			get: function( elem ) {
  				var val = jQuery.find.attr( elem, "value" );
  				return val != null ?
  					val :
  					// Support: IE10-11+
  					// option.text throws exceptions (#14686, #14858)
  					jQuery.trim( jQuery.text( elem ) );
  			}
  		},
  		select: {
  			get: function( elem ) {
  				var value, option,
  					options = elem.options,
  					index = elem.selectedIndex,
  					one = elem.type === "select-one" || index < 0,
  					values = one ? null : [],
  					max = one ? index + 1 : options.length,
  					i = index < 0 ?
  						max :
  						one ? index : 0;

  				// Loop through all the selected options
  				for ( ; i < max; i++ ) {
  					option = options[ i ];

  					// IE6-9 doesn't update selected after form reset (#2551)
  					if ( ( option.selected || i === index ) &&
  							// Don't return options that are disabled or in a disabled optgroup
  							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
  							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

  						// Get the specific value for the option
  						value = jQuery( option ).val();

  						// We don't need an array for one selects
  						if ( one ) {
  							return value;
  						}

  						// Multi-Selects return an array
  						values.push( value );
  					}
  				}

  				return values;
  			},

  			set: function( elem, value ) {
  				var optionSet, option,
  					options = elem.options,
  					values = jQuery.makeArray( value ),
  					i = options.length;

  				while ( i-- ) {
  					option = options[ i ];
  					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
  						optionSet = true;
  					}
  				}

  				// Force browsers to behave consistently when non-matching value is set
  				if ( !optionSet ) {
  					elem.selectedIndex = -1;
  				}
  				return values;
  			}
  		}
  	}
  });

  // Radios and checkboxes getter/setter
  jQuery.each([ "radio", "checkbox" ], function() {
  	jQuery.valHooks[ this ] = {
  		set: function( elem, value ) {
  			if ( jQuery.isArray( value ) ) {
  				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
  			}
  		}
  	};
  	if ( !support.checkOn ) {
  		jQuery.valHooks[ this ].get = function( elem ) {
  			return elem.getAttribute("value") === null ? "on" : elem.value;
  		};
  	}
  });




  // Return jQuery for attributes-only inclusion


  jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  	// Handle event binding
  	jQuery.fn[ name ] = function( data, fn ) {
  		return arguments.length > 0 ?
  			this.on( name, null, data, fn ) :
  			this.trigger( name );
  	};
  });

  jQuery.fn.extend({
  	hover: function( fnOver, fnOut ) {
  		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  	},

  	bind: function( types, data, fn ) {
  		return this.on( types, null, data, fn );
  	},
  	unbind: function( types, fn ) {
  		return this.off( types, null, fn );
  	},

  	delegate: function( selector, types, data, fn ) {
  		return this.on( types, selector, data, fn );
  	},
  	undelegate: function( selector, types, fn ) {
  		// ( namespace ) or ( selector, types [, fn] )
  		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
  	}
  });


  var nonce = jQuery.now();

  var rquery = (/\?/);



  // Support: Android 2.3
  // Workaround failure to string-cast null input
  jQuery.parseJSON = function( data ) {
  	return JSON.parse( data + "" );
  };


  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
  	var xml, tmp;
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}

  	// Support: IE9
  	try {
  		tmp = new DOMParser();
  		xml = tmp.parseFromString( data, "text/xml" );
  	} catch ( e ) {
  		xml = undefined;
  	}

  	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
  		jQuery.error( "Invalid XML: " + data );
  	}
  	return xml;
  };


  var
  	rhash = /#.*$/,
  	rts = /([?&])_=[^&]*/,
  	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
  	// #7653, #8125, #8152: local protocol detection
  	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  	rnoContent = /^(?:GET|HEAD)$/,
  	rprotocol = /^\/\//,
  	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

  	/* Prefilters
  	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  	 * 2) These are called:
  	 *    - BEFORE asking for a transport
  	 *    - AFTER param serialization (s.data is a string if s.processData is true)
  	 * 3) key is the dataType
  	 * 4) the catchall symbol "*" can be used
  	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  	 */
  	prefilters = {},

  	/* Transports bindings
  	 * 1) key is the dataType
  	 * 2) the catchall symbol "*" can be used
  	 * 3) selection will start with transport dataType and THEN go to "*" if needed
  	 */
  	transports = {},

  	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  	allTypes = "*/".concat( "*" ),

  	// Document location
  	ajaxLocation = window.location.href,

  	// Segment location into parts
  	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {

  	// dataTypeExpression is optional and defaults to "*"
  	return function( dataTypeExpression, func ) {

  		if ( typeof dataTypeExpression !== "string" ) {
  			func = dataTypeExpression;
  			dataTypeExpression = "*";
  		}

  		var dataType,
  			i = 0,
  			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

  		if ( jQuery.isFunction( func ) ) {
  			// For each dataType in the dataTypeExpression
  			while ( (dataType = dataTypes[i++]) ) {
  				// Prepend if requested
  				if ( dataType[0] === "+" ) {
  					dataType = dataType.slice( 1 ) || "*";
  					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

  				// Otherwise append
  				} else {
  					(structure[ dataType ] = structure[ dataType ] || []).push( func );
  				}
  			}
  		}
  	};
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  	var inspected = {},
  		seekingTransport = ( structure === transports );

  	function inspect( dataType ) {
  		var selected;
  		inspected[ dataType ] = true;
  		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
  				options.dataTypes.unshift( dataTypeOrTransport );
  				inspect( dataTypeOrTransport );
  				return false;
  			} else if ( seekingTransport ) {
  				return !( selected = dataTypeOrTransport );
  			}
  		});
  		return selected;
  	}

  	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend( target, src ) {
  	var key, deep,
  		flatOptions = jQuery.ajaxSettings.flatOptions || {};

  	for ( key in src ) {
  		if ( src[ key ] !== undefined ) {
  			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
  		}
  	}
  	if ( deep ) {
  		jQuery.extend( true, target, deep );
  	}

  	return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {

  	var ct, type, finalDataType, firstDataType,
  		contents = s.contents,
  		dataTypes = s.dataTypes;

  	// Remove auto dataType and get content-type in the process
  	while ( dataTypes[ 0 ] === "*" ) {
  		dataTypes.shift();
  		if ( ct === undefined ) {
  			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
  		}
  	}

  	// Check if we're dealing with a known content-type
  	if ( ct ) {
  		for ( type in contents ) {
  			if ( contents[ type ] && contents[ type ].test( ct ) ) {
  				dataTypes.unshift( type );
  				break;
  			}
  		}
  	}

  	// Check to see if we have a response for the expected dataType
  	if ( dataTypes[ 0 ] in responses ) {
  		finalDataType = dataTypes[ 0 ];
  	} else {
  		// Try convertible dataTypes
  		for ( type in responses ) {
  			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
  				finalDataType = type;
  				break;
  			}
  			if ( !firstDataType ) {
  				firstDataType = type;
  			}
  		}
  		// Or just use first one
  		finalDataType = finalDataType || firstDataType;
  	}

  	// If we found a dataType
  	// We add the dataType to the list if needed
  	// and return the corresponding response
  	if ( finalDataType ) {
  		if ( finalDataType !== dataTypes[ 0 ] ) {
  			dataTypes.unshift( finalDataType );
  		}
  		return responses[ finalDataType ];
  	}
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
  	var conv2, current, conv, tmp, prev,
  		converters = {},
  		// Work with a copy of dataTypes in case we need to modify it for conversion
  		dataTypes = s.dataTypes.slice();

  	// Create converters map with lowercased keys
  	if ( dataTypes[ 1 ] ) {
  		for ( conv in s.converters ) {
  			converters[ conv.toLowerCase() ] = s.converters[ conv ];
  		}
  	}

  	current = dataTypes.shift();

  	// Convert to each sequential dataType
  	while ( current ) {

  		if ( s.responseFields[ current ] ) {
  			jqXHR[ s.responseFields[ current ] ] = response;
  		}

  		// Apply the dataFilter if provided
  		if ( !prev && isSuccess && s.dataFilter ) {
  			response = s.dataFilter( response, s.dataType );
  		}

  		prev = current;
  		current = dataTypes.shift();

  		if ( current ) {

  		// There's only work to do if current dataType is non-auto
  			if ( current === "*" ) {

  				current = prev;

  			// Convert response if prev dataType is non-auto and differs from current
  			} else if ( prev !== "*" && prev !== current ) {

  				// Seek a direct converter
  				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  				// If none found, seek a pair
  				if ( !conv ) {
  					for ( conv2 in converters ) {

  						// If conv2 outputs current
  						tmp = conv2.split( " " );
  						if ( tmp[ 1 ] === current ) {

  							// If prev can be converted to accepted input
  							conv = converters[ prev + " " + tmp[ 0 ] ] ||
  								converters[ "* " + tmp[ 0 ] ];
  							if ( conv ) {
  								// Condense equivalence converters
  								if ( conv === true ) {
  									conv = converters[ conv2 ];

  								// Otherwise, insert the intermediate dataType
  								} else if ( converters[ conv2 ] !== true ) {
  									current = tmp[ 0 ];
  									dataTypes.unshift( tmp[ 1 ] );
  								}
  								break;
  							}
  						}
  					}
  				}

  				// Apply converter (if not an equivalence)
  				if ( conv !== true ) {

  					// Unless errors are allowed to bubble, catch and return them
  					if ( conv && s[ "throws" ] ) {
  						response = conv( response );
  					} else {
  						try {
  							response = conv( response );
  						} catch ( e ) {
  							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
  						}
  					}
  				}
  			}
  		}
  	}

  	return { state: "success", data: response };
  }

  jQuery.extend({

  	// Counter for holding the number of active queries
  	active: 0,

  	// Last-Modified header cache for next request
  	lastModified: {},
  	etag: {},

  	ajaxSettings: {
  		url: ajaxLocation,
  		type: "GET",
  		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
  		global: true,
  		processData: true,
  		async: true,
  		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
  		/*
  		timeout: 0,
  		data: null,
  		dataType: null,
  		username: null,
  		password: null,
  		cache: null,
  		throws: false,
  		traditional: false,
  		headers: {},
  		*/

  		accepts: {
  			"*": allTypes,
  			text: "text/plain",
  			html: "text/html",
  			xml: "application/xml, text/xml",
  			json: "application/json, text/javascript"
  		},

  		contents: {
  			xml: /xml/,
  			html: /html/,
  			json: /json/
  		},

  		responseFields: {
  			xml: "responseXML",
  			text: "responseText",
  			json: "responseJSON"
  		},

  		// Data converters
  		// Keys separate source (or catchall "*") and destination types with a single space
  		converters: {

  			// Convert anything to text
  			"* text": String,

  			// Text to html (true = no transformation)
  			"text html": true,

  			// Evaluate text as a json expression
  			"text json": jQuery.parseJSON,

  			// Parse text as xml
  			"text xml": jQuery.parseXML
  		},

  		// For options that shouldn't be deep extended:
  		// you can add your own custom options here if
  		// and when you create one that shouldn't be
  		// deep extended (see ajaxExtend)
  		flatOptions: {
  			url: true,
  			context: true
  		}
  	},

  	// Creates a full fledged settings object into target
  	// with both ajaxSettings and settings fields.
  	// If target is omitted, writes into ajaxSettings.
  	ajaxSetup: function( target, settings ) {
  		return settings ?

  			// Building a settings object
  			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  			// Extending ajaxSettings
  			ajaxExtend( jQuery.ajaxSettings, target );
  	},

  	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  	ajaxTransport: addToPrefiltersOrTransports( transports ),

  	// Main method
  	ajax: function( url, options ) {

  		// If url is an object, simulate pre-1.5 signature
  		if ( typeof url === "object" ) {
  			options = url;
  			url = undefined;
  		}

  		// Force options to be an object
  		options = options || {};

  		var transport,
  			// URL without anti-cache param
  			cacheURL,
  			// Response headers
  			responseHeadersString,
  			responseHeaders,
  			// timeout handle
  			timeoutTimer,
  			// Cross-domain detection vars
  			parts,
  			// To know if global events are to be dispatched
  			fireGlobals,
  			// Loop variable
  			i,
  			// Create the final options object
  			s = jQuery.ajaxSetup( {}, options ),
  			// Callbacks context
  			callbackContext = s.context || s,
  			// Context for global events is callbackContext if it is a DOM node or jQuery collection
  			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
  				jQuery( callbackContext ) :
  				jQuery.event,
  			// Deferreds
  			deferred = jQuery.Deferred(),
  			completeDeferred = jQuery.Callbacks("once memory"),
  			// Status-dependent callbacks
  			statusCode = s.statusCode || {},
  			// Headers (they are sent all at once)
  			requestHeaders = {},
  			requestHeadersNames = {},
  			// The jqXHR state
  			state = 0,
  			// Default abort message
  			strAbort = "canceled",
  			// Fake xhr
  			jqXHR = {
  				readyState: 0,

  				// Builds headers hashtable if needed
  				getResponseHeader: function( key ) {
  					var match;
  					if ( state === 2 ) {
  						if ( !responseHeaders ) {
  							responseHeaders = {};
  							while ( (match = rheaders.exec( responseHeadersString )) ) {
  								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
  							}
  						}
  						match = responseHeaders[ key.toLowerCase() ];
  					}
  					return match == null ? null : match;
  				},

  				// Raw string
  				getAllResponseHeaders: function() {
  					return state === 2 ? responseHeadersString : null;
  				},

  				// Caches the header
  				setRequestHeader: function( name, value ) {
  					var lname = name.toLowerCase();
  					if ( !state ) {
  						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
  						requestHeaders[ name ] = value;
  					}
  					return this;
  				},

  				// Overrides response content-type header
  				overrideMimeType: function( type ) {
  					if ( !state ) {
  						s.mimeType = type;
  					}
  					return this;
  				},

  				// Status-dependent callbacks
  				statusCode: function( map ) {
  					var code;
  					if ( map ) {
  						if ( state < 2 ) {
  							for ( code in map ) {
  								// Lazy-add the new callback in a way that preserves old ones
  								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  							}
  						} else {
  							// Execute the appropriate callbacks
  							jqXHR.always( map[ jqXHR.status ] );
  						}
  					}
  					return this;
  				},

  				// Cancel the request
  				abort: function( statusText ) {
  					var finalText = statusText || strAbort;
  					if ( transport ) {
  						transport.abort( finalText );
  					}
  					done( 0, finalText );
  					return this;
  				}
  			};

  		// Attach deferreds
  		deferred.promise( jqXHR ).complete = completeDeferred.add;
  		jqXHR.success = jqXHR.done;
  		jqXHR.error = jqXHR.fail;

  		// Remove hash character (#7531: and string promotion)
  		// Add protocol if not provided (prefilters might expect it)
  		// Handle falsy url in the settings object (#10093: consistency with old signature)
  		// We also use the url parameter if available
  		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
  			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

  		// Alias method option to type as per ticket #12004
  		s.type = options.method || options.type || s.method || s.type;

  		// Extract dataTypes list
  		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

  		// A cross-domain request is in order when we have a protocol:host:port mismatch
  		if ( s.crossDomain == null ) {
  			parts = rurl.exec( s.url.toLowerCase() );
  			s.crossDomain = !!( parts &&
  				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
  					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
  						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
  			);
  		}

  		// Convert data if not already a string
  		if ( s.data && s.processData && typeof s.data !== "string" ) {
  			s.data = jQuery.param( s.data, s.traditional );
  		}

  		// Apply prefilters
  		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  		// If request was aborted inside a prefilter, stop there
  		if ( state === 2 ) {
  			return jqXHR;
  		}

  		// We can fire global events as of now if asked to
  		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
  		fireGlobals = jQuery.event && s.global;

  		// Watch for a new set of requests
  		if ( fireGlobals && jQuery.active++ === 0 ) {
  			jQuery.event.trigger("ajaxStart");
  		}

  		// Uppercase the type
  		s.type = s.type.toUpperCase();

  		// Determine if request has content
  		s.hasContent = !rnoContent.test( s.type );

  		// Save the URL in case we're toying with the If-Modified-Since
  		// and/or If-None-Match header later on
  		cacheURL = s.url;

  		// More options handling for requests with no content
  		if ( !s.hasContent ) {

  			// If data is available, append data to url
  			if ( s.data ) {
  				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
  				// #9682: remove data so that it's not used in an eventual retry
  				delete s.data;
  			}

  			// Add anti-cache in url if needed
  			if ( s.cache === false ) {
  				s.url = rts.test( cacheURL ) ?

  					// If there is already a '_' parameter, set its value
  					cacheURL.replace( rts, "$1_=" + nonce++ ) :

  					// Otherwise add one to the end
  					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
  			}
  		}

  		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  		if ( s.ifModified ) {
  			if ( jQuery.lastModified[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  			}
  			if ( jQuery.etag[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  			}
  		}

  		// Set the correct header, if data is being sent
  		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  			jqXHR.setRequestHeader( "Content-Type", s.contentType );
  		}

  		// Set the Accepts header for the server, depending on the dataType
  		jqXHR.setRequestHeader(
  			"Accept",
  			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
  				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  				s.accepts[ "*" ]
  		);

  		// Check for headers option
  		for ( i in s.headers ) {
  			jqXHR.setRequestHeader( i, s.headers[ i ] );
  		}

  		// Allow custom headers/mimetypes and early abort
  		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
  			// Abort if not done already and return
  			return jqXHR.abort();
  		}

  		// Aborting is no longer a cancellation
  		strAbort = "abort";

  		// Install callbacks on deferreds
  		for ( i in { success: 1, error: 1, complete: 1 } ) {
  			jqXHR[ i ]( s[ i ] );
  		}

  		// Get transport
  		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  		// If no transport, we auto-abort
  		if ( !transport ) {
  			done( -1, "No Transport" );
  		} else {
  			jqXHR.readyState = 1;

  			// Send global event
  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  			}
  			// Timeout
  			if ( s.async && s.timeout > 0 ) {
  				timeoutTimer = setTimeout(function() {
  					jqXHR.abort("timeout");
  				}, s.timeout );
  			}

  			try {
  				state = 1;
  				transport.send( requestHeaders, done );
  			} catch ( e ) {
  				// Propagate exception as error if not done
  				if ( state < 2 ) {
  					done( -1, e );
  				// Simply rethrow otherwise
  				} else {
  					throw e;
  				}
  			}
  		}

  		// Callback for when everything is done
  		function done( status, nativeStatusText, responses, headers ) {
  			var isSuccess, success, error, response, modified,
  				statusText = nativeStatusText;

  			// Called once
  			if ( state === 2 ) {
  				return;
  			}

  			// State is "done" now
  			state = 2;

  			// Clear timeout if it exists
  			if ( timeoutTimer ) {
  				clearTimeout( timeoutTimer );
  			}

  			// Dereference transport for early garbage collection
  			// (no matter how long the jqXHR object will be used)
  			transport = undefined;

  			// Cache response headers
  			responseHeadersString = headers || "";

  			// Set readyState
  			jqXHR.readyState = status > 0 ? 4 : 0;

  			// Determine if successful
  			isSuccess = status >= 200 && status < 300 || status === 304;

  			// Get response data
  			if ( responses ) {
  				response = ajaxHandleResponses( s, jqXHR, responses );
  			}

  			// Convert no matter what (that way responseXXX fields are always set)
  			response = ajaxConvert( s, response, jqXHR, isSuccess );

  			// If successful, handle type chaining
  			if ( isSuccess ) {

  				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  				if ( s.ifModified ) {
  					modified = jqXHR.getResponseHeader("Last-Modified");
  					if ( modified ) {
  						jQuery.lastModified[ cacheURL ] = modified;
  					}
  					modified = jqXHR.getResponseHeader("etag");
  					if ( modified ) {
  						jQuery.etag[ cacheURL ] = modified;
  					}
  				}

  				// if no content
  				if ( status === 204 || s.type === "HEAD" ) {
  					statusText = "nocontent";

  				// if not modified
  				} else if ( status === 304 ) {
  					statusText = "notmodified";

  				// If we have data, let's convert it
  				} else {
  					statusText = response.state;
  					success = response.data;
  					error = response.error;
  					isSuccess = !error;
  				}
  			} else {
  				// Extract error from statusText and normalize for non-aborts
  				error = statusText;
  				if ( status || !statusText ) {
  					statusText = "error";
  					if ( status < 0 ) {
  						status = 0;
  					}
  				}
  			}

  			// Set data for the fake xhr object
  			jqXHR.status = status;
  			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  			// Success/Error
  			if ( isSuccess ) {
  				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  			} else {
  				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  			}

  			// Status-dependent callbacks
  			jqXHR.statusCode( statusCode );
  			statusCode = undefined;

  			if ( fireGlobals ) {
  				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  					[ jqXHR, s, isSuccess ? success : error ] );
  			}

  			// Complete
  			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
  				// Handle the global AJAX counter
  				if ( !( --jQuery.active ) ) {
  					jQuery.event.trigger("ajaxStop");
  				}
  			}
  		}

  		return jqXHR;
  	},

  	getJSON: function( url, data, callback ) {
  		return jQuery.get( url, data, callback, "json" );
  	},

  	getScript: function( url, callback ) {
  		return jQuery.get( url, undefined, callback, "script" );
  	}
  });

  jQuery.each( [ "get", "post" ], function( i, method ) {
  	jQuery[ method ] = function( url, data, callback, type ) {
  		// Shift arguments if data argument was omitted
  		if ( jQuery.isFunction( data ) ) {
  			type = type || callback;
  			callback = data;
  			data = undefined;
  		}

  		return jQuery.ajax({
  			url: url,
  			type: method,
  			dataType: type,
  			data: data,
  			success: callback
  		});
  	};
  });


  jQuery._evalUrl = function( url ) {
  	return jQuery.ajax({
  		url: url,
  		type: "GET",
  		dataType: "script",
  		async: false,
  		global: false,
  		"throws": true
  	});
  };


  jQuery.fn.extend({
  	wrapAll: function( html ) {
  		var wrap;

  		if ( jQuery.isFunction( html ) ) {
  			return this.each(function( i ) {
  				jQuery( this ).wrapAll( html.call(this, i) );
  			});
  		}

  		if ( this[ 0 ] ) {

  			// The elements to wrap the target around
  			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  			if ( this[ 0 ].parentNode ) {
  				wrap.insertBefore( this[ 0 ] );
  			}

  			wrap.map(function() {
  				var elem = this;

  				while ( elem.firstElementChild ) {
  					elem = elem.firstElementChild;
  				}

  				return elem;
  			}).append( this );
  		}

  		return this;
  	},

  	wrapInner: function( html ) {
  		if ( jQuery.isFunction( html ) ) {
  			return this.each(function( i ) {
  				jQuery( this ).wrapInner( html.call(this, i) );
  			});
  		}

  		return this.each(function() {
  			var self = jQuery( this ),
  				contents = self.contents();

  			if ( contents.length ) {
  				contents.wrapAll( html );

  			} else {
  				self.append( html );
  			}
  		});
  	},

  	wrap: function( html ) {
  		var isFunction = jQuery.isFunction( html );

  		return this.each(function( i ) {
  			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
  		});
  	},

  	unwrap: function() {
  		return this.parent().each(function() {
  			if ( !jQuery.nodeName( this, "body" ) ) {
  				jQuery( this ).replaceWith( this.childNodes );
  			}
  		}).end();
  	}
  });


  jQuery.expr.filters.hidden = function( elem ) {
  	// Support: Opera <= 12.12
  	// Opera reports offsetWidths and offsetHeights less than zero on some elements
  	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function( elem ) {
  	return !jQuery.expr.filters.hidden( elem );
  };




  var r20 = /%20/g,
  	rbracket = /\[\]$/,
  	rCRLF = /\r?\n/g,
  	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  	rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams( prefix, obj, traditional, add ) {
  	var name;

  	if ( jQuery.isArray( obj ) ) {
  		// Serialize array item.
  		jQuery.each( obj, function( i, v ) {
  			if ( traditional || rbracket.test( prefix ) ) {
  				// Treat each array item as a scalar.
  				add( prefix, v );

  			} else {
  				// Item is non-scalar (array or object), encode its numeric index.
  				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
  			}
  		});

  	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
  		// Serialize object item.
  		for ( name in obj ) {
  			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  		}

  	} else {
  		// Serialize scalar item.
  		add( prefix, obj );
  	}
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
  	var prefix,
  		s = [],
  		add = function( key, value ) {
  			// If value is a function, invoke it and return its value
  			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
  			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
  		};

  	// Set traditional to true for jQuery <= 1.3.2 behavior.
  	if ( traditional === undefined ) {
  		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
  	}

  	// If an array was passed in, assume that it is an array of form elements.
  	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
  		// Serialize the form elements
  		jQuery.each( a, function() {
  			add( this.name, this.value );
  		});

  	} else {
  		// If traditional, encode the "old" way (the way 1.3.2 or older
  		// did it), otherwise encode params recursively.
  		for ( prefix in a ) {
  			buildParams( prefix, a[ prefix ], traditional, add );
  		}
  	}

  	// Return the resulting serialization
  	return s.join( "&" ).replace( r20, "+" );
  };

  jQuery.fn.extend({
  	serialize: function() {
  		return jQuery.param( this.serializeArray() );
  	},
  	serializeArray: function() {
  		return this.map(function() {
  			// Can add propHook for "elements" to filter or add form elements
  			var elements = jQuery.prop( this, "elements" );
  			return elements ? jQuery.makeArray( elements ) : this;
  		})
  		.filter(function() {
  			var type = this.type;

  			// Use .is( ":disabled" ) so that fieldset[disabled] works
  			return this.name && !jQuery( this ).is( ":disabled" ) &&
  				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  				( this.checked || !rcheckableType.test( type ) );
  		})
  		.map(function( i, elem ) {
  			var val = jQuery( this ).val();

  			return val == null ?
  				null :
  				jQuery.isArray( val ) ?
  					jQuery.map( val, function( val ) {
  						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  					}) :
  					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  		}).get();
  	}
  });


  jQuery.ajaxSettings.xhr = function() {
  	try {
  		return new XMLHttpRequest();
  	} catch( e ) {}
  };

  var xhrId = 0,
  	xhrCallbacks = {},
  	xhrSuccessStatus = {
  		// file protocol always yields status code 0, assume 200
  		0: 200,
  		// Support: IE9
  		// #1450: sometimes IE returns 1223 when it should be 204
  		1223: 204
  	},
  	xhrSupported = jQuery.ajaxSettings.xhr();

  // Support: IE9
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info
  if ( window.attachEvent ) {
  	window.attachEvent( "onunload", function() {
  		for ( var key in xhrCallbacks ) {
  			xhrCallbacks[ key ]();
  		}
  	});
  }

  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport(function( options ) {
  	var callback;

  	// Cross domain only allowed if supported through XMLHttpRequest
  	if ( support.cors || xhrSupported && !options.crossDomain ) {
  		return {
  			send: function( headers, complete ) {
  				var i,
  					xhr = options.xhr(),
  					id = ++xhrId;

  				xhr.open( options.type, options.url, options.async, options.username, options.password );

  				// Apply custom fields if provided
  				if ( options.xhrFields ) {
  					for ( i in options.xhrFields ) {
  						xhr[ i ] = options.xhrFields[ i ];
  					}
  				}

  				// Override mime type if needed
  				if ( options.mimeType && xhr.overrideMimeType ) {
  					xhr.overrideMimeType( options.mimeType );
  				}

  				// X-Requested-With header
  				// For cross-domain requests, seeing as conditions for a preflight are
  				// akin to a jigsaw puzzle, we simply never set it to be sure.
  				// (it can always be set on a per-request basis or even using ajaxSetup)
  				// For same-domain requests, won't change header if already provided.
  				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
  					headers["X-Requested-With"] = "XMLHttpRequest";
  				}

  				// Set headers
  				for ( i in headers ) {
  					xhr.setRequestHeader( i, headers[ i ] );
  				}

  				// Callback
  				callback = function( type ) {
  					return function() {
  						if ( callback ) {
  							delete xhrCallbacks[ id ];
  							callback = xhr.onload = xhr.onerror = null;

  							if ( type === "abort" ) {
  								xhr.abort();
  							} else if ( type === "error" ) {
  								complete(
  									// file: protocol always yields status 0; see #8605, #14207
  									xhr.status,
  									xhr.statusText
  								);
  							} else {
  								complete(
  									xhrSuccessStatus[ xhr.status ] || xhr.status,
  									xhr.statusText,
  									// Support: IE9
  									// Accessing binary-data responseText throws an exception
  									// (#11426)
  									typeof xhr.responseText === "string" ? {
  										text: xhr.responseText
  									} : undefined,
  									xhr.getAllResponseHeaders()
  								);
  							}
  						}
  					};
  				};

  				// Listen to events
  				xhr.onload = callback();
  				xhr.onerror = callback("error");

  				// Create the abort callback
  				callback = xhrCallbacks[ id ] = callback("abort");

  				try {
  					// Do send the request (this may raise an exception)
  					xhr.send( options.hasContent && options.data || null );
  				} catch ( e ) {
  					// #14683: Only rethrow if this hasn't been notified as an error yet
  					if ( callback ) {
  						throw e;
  					}
  				}
  			},

  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  });




  // Install script dataType
  jQuery.ajaxSetup({
  	accepts: {
  		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  	},
  	contents: {
  		script: /(?:java|ecma)script/
  	},
  	converters: {
  		"text script": function( text ) {
  			jQuery.globalEval( text );
  			return text;
  		}
  	}
  });

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter( "script", function( s ) {
  	if ( s.cache === undefined ) {
  		s.cache = false;
  	}
  	if ( s.crossDomain ) {
  		s.type = "GET";
  	}
  });

  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {
  	// This transport only deals with cross domain requests
  	if ( s.crossDomain ) {
  		var script, callback;
  		return {
  			send: function( _, complete ) {
  				script = jQuery("<script>").prop({
  					async: true,
  					charset: s.scriptCharset,
  					src: s.url
  				}).on(
  					"load error",
  					callback = function( evt ) {
  						script.remove();
  						callback = null;
  						if ( evt ) {
  							complete( evt.type === "error" ? 404 : 200, evt.type );
  						}
  					}
  				);
  				document.head.appendChild( script[ 0 ] );
  			},
  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  });




  var oldCallbacks = [],
  	rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup({
  	jsonp: "callback",
  	jsonpCallback: function() {
  		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
  		this[ callback ] = true;
  		return callback;
  	}
  });

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  	var callbackName, overwritten, responseContainer,
  		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  			"url" :
  			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
  		);

  	// Handle iff the expected data type is "jsonp" or we have a parameter to set
  	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  		// Get callback name, remembering preexisting value associated with it
  		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
  			s.jsonpCallback() :
  			s.jsonpCallback;

  		// Insert callback into url or form data
  		if ( jsonProp ) {
  			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  		} else if ( s.jsonp !== false ) {
  			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  		}

  		// Use data converter to retrieve json after script execution
  		s.converters["script json"] = function() {
  			if ( !responseContainer ) {
  				jQuery.error( callbackName + " was not called" );
  			}
  			return responseContainer[ 0 ];
  		};

  		// force json dataType
  		s.dataTypes[ 0 ] = "json";

  		// Install callback
  		overwritten = window[ callbackName ];
  		window[ callbackName ] = function() {
  			responseContainer = arguments;
  		};

  		// Clean-up function (fires after converters)
  		jqXHR.always(function() {
  			// Restore preexisting value
  			window[ callbackName ] = overwritten;

  			// Save back as free
  			if ( s[ callbackName ] ) {
  				// make sure that re-using the options doesn't screw things around
  				s.jsonpCallback = originalSettings.jsonpCallback;

  				// save the callback name for future use
  				oldCallbacks.push( callbackName );
  			}

  			// Call if it was a function and we have a response
  			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
  				overwritten( responseContainer[ 0 ] );
  			}

  			responseContainer = overwritten = undefined;
  		});

  		// Delegate to script
  		return "script";
  	}
  });




  // data: string of html
  // context (optional): If specified, the fragment will be created in this context, defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}
  	if ( typeof context === "boolean" ) {
  		keepScripts = context;
  		context = false;
  	}
  	context = context || document;

  	var parsed = rsingleTag.exec( data ),
  		scripts = !keepScripts && [];

  	// Single tag
  	if ( parsed ) {
  		return [ context.createElement( parsed[1] ) ];
  	}

  	parsed = jQuery.buildFragment( [ data ], context, scripts );

  	if ( scripts && scripts.length ) {
  		jQuery( scripts ).remove();
  	}

  	return jQuery.merge( [], parsed.childNodes );
  };


  // Keep a copy of the old load method
  var _load = jQuery.fn.load;

  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
  	if ( typeof url !== "string" && _load ) {
  		return _load.apply( this, arguments );
  	}

  	var selector, type, response,
  		self = this,
  		off = url.indexOf(" ");

  	if ( off >= 0 ) {
  		selector = jQuery.trim( url.slice( off ) );
  		url = url.slice( 0, off );
  	}

  	// If it's a function
  	if ( jQuery.isFunction( params ) ) {

  		// We assume that it's the callback
  		callback = params;
  		params = undefined;

  	// Otherwise, build a param string
  	} else if ( params && typeof params === "object" ) {
  		type = "POST";
  	}

  	// If we have elements to modify, make the request
  	if ( self.length > 0 ) {
  		jQuery.ajax({
  			url: url,

  			// if "type" variable is undefined, then "GET" method will be used
  			type: type,
  			dataType: "html",
  			data: params
  		}).done(function( responseText ) {

  			// Save response for use in complete callback
  			response = arguments;

  			self.html( selector ?

  				// If a selector was specified, locate the right elements in a dummy div
  				// Exclude scripts to avoid IE 'Permission Denied' errors
  				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

  				// Otherwise use the full result
  				responseText );

  		}).complete( callback && function( jqXHR, status ) {
  			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
  		});
  	}

  	return this;
  };




  // Attach a bunch of functions for handling common AJAX events
  jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
  	jQuery.fn[ type ] = function( fn ) {
  		return this.on( type, fn );
  	};
  });




  jQuery.expr.filters.animated = function( elem ) {
  	return jQuery.grep(jQuery.timers, function( fn ) {
  		return elem === fn.elem;
  	}).length;
  };




  var docElem = window.document.documentElement;

  /**
   * Gets a window from an element
   */
  function getWindow( elem ) {
  	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
  }

  jQuery.offset = {
  	setOffset: function( elem, options, i ) {
  		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  			position = jQuery.css( elem, "position" ),
  			curElem = jQuery( elem ),
  			props = {};

  		// Set position first, in-case top/left are set even on static elem
  		if ( position === "static" ) {
  			elem.style.position = "relative";
  		}

  		curOffset = curElem.offset();
  		curCSSTop = jQuery.css( elem, "top" );
  		curCSSLeft = jQuery.css( elem, "left" );
  		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

  		// Need to be able to calculate position if either
  		// top or left is auto and position is either absolute or fixed
  		if ( calculatePosition ) {
  			curPosition = curElem.position();
  			curTop = curPosition.top;
  			curLeft = curPosition.left;

  		} else {
  			curTop = parseFloat( curCSSTop ) || 0;
  			curLeft = parseFloat( curCSSLeft ) || 0;
  		}

  		if ( jQuery.isFunction( options ) ) {
  			options = options.call( elem, i, curOffset );
  		}

  		if ( options.top != null ) {
  			props.top = ( options.top - curOffset.top ) + curTop;
  		}
  		if ( options.left != null ) {
  			props.left = ( options.left - curOffset.left ) + curLeft;
  		}

  		if ( "using" in options ) {
  			options.using.call( elem, props );

  		} else {
  			curElem.css( props );
  		}
  	}
  };

  jQuery.fn.extend({
  	offset: function( options ) {
  		if ( arguments.length ) {
  			return options === undefined ?
  				this :
  				this.each(function( i ) {
  					jQuery.offset.setOffset( this, options, i );
  				});
  		}

  		var docElem, win,
  			elem = this[ 0 ],
  			box = { top: 0, left: 0 },
  			doc = elem && elem.ownerDocument;

  		if ( !doc ) {
  			return;
  		}

  		docElem = doc.documentElement;

  		// Make sure it's not a disconnected DOM node
  		if ( !jQuery.contains( docElem, elem ) ) {
  			return box;
  		}

  		// Support: BlackBerry 5, iOS 3 (original iPhone)
  		// If we don't have gBCR, just use 0,0 rather than error
  		if ( typeof elem.getBoundingClientRect !== strundefined ) {
  			box = elem.getBoundingClientRect();
  		}
  		win = getWindow( doc );
  		return {
  			top: box.top + win.pageYOffset - docElem.clientTop,
  			left: box.left + win.pageXOffset - docElem.clientLeft
  		};
  	},

  	position: function() {
  		if ( !this[ 0 ] ) {
  			return;
  		}

  		var offsetParent, offset,
  			elem = this[ 0 ],
  			parentOffset = { top: 0, left: 0 };

  		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
  		if ( jQuery.css( elem, "position" ) === "fixed" ) {
  			// Assume getBoundingClientRect is there when computed position is fixed
  			offset = elem.getBoundingClientRect();

  		} else {
  			// Get *real* offsetParent
  			offsetParent = this.offsetParent();

  			// Get correct offsets
  			offset = this.offset();
  			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
  				parentOffset = offsetParent.offset();
  			}

  			// Add offsetParent borders
  			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
  			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
  		}

  		// Subtract parent offsets and element margins
  		return {
  			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  		};
  	},

  	offsetParent: function() {
  		return this.map(function() {
  			var offsetParent = this.offsetParent || docElem;

  			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
  				offsetParent = offsetParent.offsetParent;
  			}

  			return offsetParent || docElem;
  		});
  	}
  });

  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  	var top = "pageYOffset" === prop;

  	jQuery.fn[ method ] = function( val ) {
  		return access( this, function( elem, method, val ) {
  			var win = getWindow( elem );

  			if ( val === undefined ) {
  				return win ? win[ prop ] : elem[ method ];
  			}

  			if ( win ) {
  				win.scrollTo(
  					!top ? val : window.pageXOffset,
  					top ? val : window.pageYOffset
  				);

  			} else {
  				elem[ method ] = val;
  			}
  		}, method, val, arguments.length, null );
  	};
  });

  // Support: Safari<7+, Chrome<37+
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( i, prop ) {
  	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  		function( elem, computed ) {
  			if ( computed ) {
  				computed = curCSS( elem, prop );
  				// If curCSS returns percentage, fallback to offset
  				return rnumnonpx.test( computed ) ?
  					jQuery( elem ).position()[ prop ] + "px" :
  					computed;
  			}
  		}
  	);
  });


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
  		// Margin is only for outerHeight, outerWidth
  		jQuery.fn[ funcName ] = function( margin, value ) {
  			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  			return access( this, function( elem, type, value ) {
  				var doc;

  				if ( jQuery.isWindow( elem ) ) {
  					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
  					// isn't a whole lot we can do. See pull request at this URL for discussion:
  					// https://github.com/jquery/jquery/pull/764
  					return elem.document.documentElement[ "client" + name ];
  				}

  				// Get document width or height
  				if ( elem.nodeType === 9 ) {
  					doc = elem.documentElement;

  					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  					// whichever is greatest
  					return Math.max(
  						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  						elem.body[ "offset" + name ], doc[ "offset" + name ],
  						doc[ "client" + name ]
  					);
  				}

  				return value === undefined ?
  					// Get width or height on the element, requesting but not forcing parseFloat
  					jQuery.css( elem, type, extra ) :

  					// Set width or height on the element
  					jQuery.style( elem, type, value, extra );
  			}, type, chainable ? margin : undefined, chainable, null );
  		};
  	});
  });


  // The number of elements contained in the matched element set
  jQuery.fn.size = function() {
  	return this.length;
  };

  jQuery.fn.andSelf = jQuery.fn.addBack;




  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if ( typeof define === "function" && define.amd ) {
  	define.modules.jquery = (function(){
  		return jQuery;
  	})();
  }




  var
  	// Map over jQuery in case of overwrite
  	_jQuery = window.jQuery,

  	// Map over the $ in case of overwrite
  	_$ = window.$;

  jQuery.noConflict = function( deep ) {
  	if ( window.$ === jQuery ) {
  		window.$ = _$;
  	}

  	if ( deep && window.jQuery === jQuery ) {
  		window.jQuery = _jQuery;
  	}

  	return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if ( typeof noGlobal === strundefined ) {
  	window.jQuery = window.$ = jQuery;
  }




  return jQuery;

  }));

  /**
   * @module sync/transports/xhr
   * @requires module:util/errors
   * @requires module:lodash
   * @requires module:jquery
   */
  define.modules['lib/sync/transports/xhr'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Errors = define.modules['lib/util/errors'];
      var Transport = define.modules['lib/sync/transport'];

      var _ = define.modules.lodash;
      var $ = define.modules.jquery;

      var Xhr = Transport.extend({
        isAvailable: function() {
          return navigator.onLine;
        },

        constructor: function(options) {
          Xhr.super("constructor", this, arguments);

          // Ensure we have an adapter to initialize.
          if (!this.options.adapter) {
            throw new Errors.MissingAdapter();
          }
        },

        request: function(options) {
          options = _.defaults({}, options, this.options);

          options.model = this.model;
          options.method = this.method;

          // Pass the options along to the adapter constructor.
          options.currentAdapter = options.adapter.create(options);

          var type = options.type;

          // Default JSON-request options.
          var params = {type: type, dataType: 'json', url: options.url};

          // If no URL is present, throw a URL error.
          if (!params.url) {
            params.url = _.result(this.model, 'url');

            if (!params.url) {
              throw new Errors.Url();
            }
          }

          // For older servers, emulate JSON by encoding the request into an HTML-form.
          if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = options.data ? {model: options.data} : {};
          }

          // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
          // And an `X-HTTP-Method-Override` header.
          if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
              xhr.setRequestHeader('X-HTTP-Method-Override', type);
              if (beforeSend) return beforeSend.apply(this, arguments);
            };
          }

          // Don't process data on a non-GET request.
          if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
          }

          // A reference to the `request` function, used for comparison.
          var request = Xhr.prototype.request;

          // Save a reference to the jQuery ajax method.
          var ajax = $.ajax;

          // Maintain compatibility with Backbone's ability to override `ajax`.
          if (typeof Backbone !== "undefined" && Backbone.ajax !== request) {
            ajax = Backbone.ajax;
          }

          // Create a new connection, overriding any additional options.
          var jqXHR = ajax(_.extend({}, options, params));

          // Publish fetched and parsed data to a passed channel.
          if (this.channel) {
            jqXHR.done(function(data) {
              this.channel.publish({ data: data });
            }.bind(this));
          }

          // Return the connection.
          return jqXHR;
        }
      });

      module.exports = Xhr;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/sync'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var RestAdapter = define.modules['lib/sync/adapters/rest'];
      var XhrTransport = define.modules['lib/sync/transports/xhr'];

      var _ = define.modules.lodash;

      var noXhrPatch = typeof window !== "undefined" && !!window.ActiveXObject &&
        !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

      var Sync = function(method, model, options) {
        options = options || {};

        // Backbone compatability.
        if (typeof Backbone !== "undefined") {
          options.emulateHTTP = typeof options.emulateHTTP !== "boolean" ?
            Backbone.emulateHTTP : options.emulateHTTP;

          options.emulateJSON = typeof options.emulateJSON !== "boolean" ?
            Backbone.emulateJSON : options.emulateJSON;
        }

        // Set the default options.
        options = _.defaults(options, {
          // Overridable transport and adapter defaults.
          transport: XhrTransport,
          adapter: RestAdapter,

          // Backbone support for older browsers.
          emulateHTTP: options.emulateHTTP,
          emulateJSON: options.emulateJSON,

          // Default to the Model/Collection's URL.
          url: options.url || _.result(model, "url")
        });

        // Pass along `textStatus` and `errorThrown` from jQuery.
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error) error.apply(this, arguments);
        };

        // If no transport was set, default to Xhr.
        var transport = options.transport.create({
          method: method,
          model: model,
          options: options
        });

        options.currentTransport = transport;

        // Make the request, allowing the user to override any Ajax options.
        var req = transport.request();
        model.trigger("request", model, req, options);

        // Assign to `xhr` property, for Backbone compatibility.
        options.xhr = req;

        return req;
      };

      module.exports = Sync;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/util/wrap_error'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      /**
       * Wrap an optional error callback with a fallback error event.
       *
       * @param {Object} model - The model or collection to wrap.
       * @param {Object} options - An optional object to forward.
       */
      function wrapError(model, options) {
        var error = options.error;

        options.error = function(resp) {
          if (error) {
            error(model, resp, options);
          }

          model.trigger("error", model, resp, options);
        };
      }

      module.exports = wrapError;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/util/url_error'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      /**
       * Throw an error when a URL is needed, and none is supplied.
       */
      function urlError() {
        throw new Error("A \"url\" property or function must be specified");
      }

      module.exports = urlError;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/model'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];
      var Sync = define.modules['lib/sync'];
      var wrapError = define.modules['lib/util/wrap_error'];
      var urlError = define.modules['lib/util/url_error'];

      var _ = define.modules.lodash;

      // FIXME
      var array = [];
      var push = array.push;
      var slice = array.slice;
      var splice = array.splice;

      // Backbone.Model
      // --------------

      // Backbone **Models** are the basic data object in the framework --
      // frequently representing a row in a table in a database on your server.
      // A discrete chunk of data and a bunch of useful, related methods for
      // performing computations and transformations on that data.

      // A list of options to be attached directly to the model, if provided.
      var modelOptions = ['url', 'urlRoot', 'collection'];

      // Create a new model with the specified attributes. A client id (`cid`)
      // is automatically generated and assigned for you.
      var Model = Class.extend({
        constructor: function(attributes, options) {
          var attrs = attributes || {};
          options = options || {};

          this.cid = _.uniqueId('c');
          this.attributes = {};
          if (options && options.collection) this.collection = options.collection;
          if (options && options.parse) attrs = this.parse(attrs, options) || {};
          attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
          this.set(attrs, options);
          this.changed = {};
          this.initialize.apply(this, arguments);

          // Set up custom Model handler logic for the channel.
          if (this.channel) {
            // Whenever new data comes in, update the internal data store unless it's
            // already changed.
            this.channel.subscribe(function(value, path) {
              if (this.get(path) !== value) {
                this.set(path, value);
              }
            }, this);

            // Whenever this internal data changes, update.
            this.on("change", function() {
              this.channel.publish(this.changed);
            }, this);
          }
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function(){},

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return _.clone(this.attributes);
        },

        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          // Backbone compatibility.
          var _sync = typeof Backbone !== "undefined" ? Backbone.sync : Sync;
          return _sync.apply(this, arguments);
        },

        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
          return _.escape(this.get(attr));
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          var attr, attrs, unset, changes, silent, changing, prev, current;
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          unset           = options.unset;
          silent          = options.silent;
          changes         = [];
          changing        = this._changing;
          this._changing  = true;

          if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
          }
          current = this.attributes, prev = this._previousAttributes;

          // Check for changes of `id`.
          if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

          // For each `set` attribute, update or delete the current value.
          for (attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val)) changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
              this.changed[attr] = val;
            } else {
              delete this.changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0, l = changes.length; i < l; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, _.extend({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !_.isEmpty(this.changed);
          return _.has(this.changed, attr);
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
          var val, changed = false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          for (var attr in diff) {
            if (_.isEqual(old[attr], (val = diff[attr]))) continue;
            (changed || (changed = {}))[attr] = val;
          }
          return changed;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return _.clone(this._previousAttributes);
        },

        // Fetch the model from the server. If the server's representation of the
        // model differs from its current attributes, they will be overridden,
        // triggering a `"change"` event.
        fetch: function(options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0) options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            if (!model.set(model.parse(resp, options), options)) return false;
            if (success) success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },

        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
          var attrs, method, xhr, attributes = this.attributes;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          if (key == null || typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options = _.extend({validate: true}, options);

          // If we're not waiting and attributes exist, save acts as
          // `set(attr).save(null, opts)` with validation. Otherwise, check if
          // the model will be valid when the attributes, if any, are set.
          if (attrs && !options.wait) {
            if (!this.set(attrs, options)) return false;
          } else {
            if (!this._validate(attrs, options)) return false;
          }

          // Set temporary attributes if `{wait: true}`.
          if (attrs && options.wait) {
            this.attributes = _.extend({}, attributes, attrs);
          }

          // After a successful server-side save, the client is (optionally)
          // updated with the server-side state.
          if (options.parse === void 0) options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            // Ensure attributes are restored during synchronous saves.
            model.attributes = attributes;
            var serverAttrs = model.parse(resp, options);
            if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
            if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
              return false;
            }
            if (success) success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);

          method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
          if (method === 'patch' && !options.attrs) options.attrs = attrs;
          xhr = this.sync(method, this, options);

          // Restore attributes.
          if (attrs && options.wait) this.attributes = attributes;

          return xhr;
        },

        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
          options = options ? _.clone(options) : {};
          var model = this;
          var success = options.success;

          var destroy = function() {
            model.trigger('destroy', model, model.collection, options);
          };

          options.success = function(resp) {
            if (options.wait || model.isNew()) destroy();
            if (success) success(model, resp, options);
            if (!model.isNew()) model.trigger('sync', model, resp, options);
          };

          if (this.isNew()) {
            options.success();
            return false;
          }
          wrapError(this, options);

          var xhr = this.sync('delete', this, options);
          if (!options.wait) destroy();
          return xhr;
        },

        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
          var base =
            _.result(this, 'urlRoot') ||
            _.result(this.collection, 'url') ||
            urlError();
          if (this.isNew()) return base;
          return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
        },

        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
          return resp;
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          var model = new Model(this.attributes);
          model.cid = this.cid;
          model.id = this.id;
          return model;
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return this.id == null;
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, _.extend(options || {}, { validate: true }));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = _.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
          return false;
        }

      });

      // Underscore methods that we want to implement on the Model.
      var modelMethods = {
        "keys": _.keys,
        "values": _.values,
        "pairs": _.pairs,
        "invert": _.invert,
        "pick": _.pick,
        "omit": _.omit,
        "chain": _.chain
      };

      // Mix in each Underscore method as a proxy to `Model#attributes`.
      _.each(modelMethods, function(func, method) {
        Model.prototype[method] = function() {
          var args = slice.call(arguments);
          args.unshift(this.attributes);
          return func.apply(_, args);
        };
      });

      module.exports = Model;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/collection'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];
      var Model = define.modules['lib/model'];
      var Sync = define.modules['lib/sync'];
      var wrapError = define.modules['lib/util/wrap_error'];
      var urlError = define.modules['lib/util/url_error'];

      var _ = define.modules.lodash;


      // Default options for `Collection#set`.
      var setOptions = {add: true, remove: true, merge: true};
      var addOptions = {add: true, remove: false};

      // FIXME
      var array = [];
      var push = array.push;
      var slice = array.slice;
      var splice = array.splice;

      // Backbone.Collection
      // -------------------

      // If models tend to represent a single row of data, a Backbone Collection is
      // more analagous to a table full of data ... or a small slice or page of that
      // table, or a collection of rows that belong together for a particular reason
      // -- all of the messages in this particular folder, all of the documents
      // belonging to this particular author, and so on. Collections maintain
      // indexes of their models, both in order, and for lookup by `id`.

      // Create a new **Collection**, perhaps to contain a specific type of `model`.
      // If a `comparator` is specified, the Collection will maintain
      // its models in sort order, as they're added and removed.
      var Collection = Class.extend({
        constructor: function(models, options) {
          options || (options = {});
          if (options.model) this.model = options.model;
          if (options.comparator !== void 0) this.comparator = options.comparator;
          this._reset();
          this.initialize.apply(this, arguments);
          if (models) this.reset(models, _.extend({silent: true}, options));
        },

        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function(){},

        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model){ return model.toJSON(options); });
        },

        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          // Backbone compatibility.
          var _sync = typeof Backbone !== "undefined" ? Backbone.sync : Sync;
          return _sync.apply(this, arguments);
        },

        // Add a model, or list of models to the set.
        add: function(models, options) {
          return this.set(models, _.extend({merge: false}, options, addOptions));
        },

        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          var singular = !_.isArray(models);
          models = singular ? [models] : _.clone(models);
          options || (options = {});
          var i, l, index, model;
          for (i = 0, l = models.length; i < l; i++) {
            model = models[i] = this.get(models[i]);
            if (!model) continue;
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            delete this._byId[model.cid];
            index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            if (!options.silent) {
              options.index = index;
              model.trigger('remove', model, this, options);
            }
            this._removeReference(model, options);
          }
          return singular ? models[0] : models;
        },

        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          options = _.defaults({}, options, setOptions);
          if (options.parse) models = this.parse(models, options);
          var singular = !_.isArray(models);
          models = singular ? (models ? [models] : []) : _.clone(models);
          var i, l, id, model, attrs, existing, sort;
          var at = options.at;
          var targetModel = this.model;
          var sortable = this.comparator && (at == null) && options.sort !== false;
          var sortAttr = _.isString(this.comparator) ? this.comparator : null;
          var toAdd = [], toRemove = [], modelMap = {};
          var add = options.add, merge = options.merge, remove = options.remove;
          var order = !sortable && add && remove ? [] : false;

          // Turn bare objects into model references, and prevent invalid models
          // from being added.
          for (i = 0, l = models.length; i < l; i++) {
            attrs = models[i] || {};
            if (attrs instanceof Model) {
              id = model = attrs;
            } else {
              id = attrs[targetModel.prototype.idAttribute || 'id'];
            }

            // If a duplicate is found, prevent it from being added and
            // optionally merge it into the existing model.
            if (existing = this.get(id)) {
              if (remove) modelMap[existing.cid] = true;
              if (merge) {
                attrs = attrs === model ? model.attributes : attrs;
                if (options.parse) attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
              }
              models[i] = existing;

            // If this is a new, valid model, push it to the `toAdd` list.
            } else if (add) {
              model = models[i] = this._prepareModel(attrs, options);
              if (!model) continue;
              toAdd.push(model);
              this._addReference(model, options);
            }

            // Do not add multiple models with the same `id`.
            model = existing || model;
            if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
            modelMap[model.id] = true;
          }

          // Remove nonexistent models if appropriate.
          if (remove) {
            for (i = 0, l = this.length; i < l; ++i) {
              if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
            }
            if (toRemove.length) this.remove(toRemove, options);
          }

          // See if sorting is needed, update `length` and splice in new models.
          if (toAdd.length || (order && order.length)) {
            if (sortable) sort = true;
            this.length += toAdd.length;
            if (at != null) {
              for (i = 0, l = toAdd.length; i < l; i++) {
                this.models.splice(at + i, 0, toAdd[i]);
              }
            } else {
              if (order) this.models.length = 0;
              var orderedModels = order || toAdd;
              for (i = 0, l = orderedModels.length; i < l; i++) {
                this.models.push(orderedModels[i]);
              }
            }
          }

          // Silently sort the collection if appropriate.
          if (sort) this.sort({silent: true});

          // Unless silenced, it's time to fire all appropriate add/sort events.
          if (!options.silent) {
            for (i = 0, l = toAdd.length; i < l; i++) {
              (model = toAdd[i]).trigger('add', model, this, options);
            }
            if (sort || (order && order.length)) this.trigger('sort', this, options);
          }

          // Return the added (or merged) model (or models).
          return singular ? models[0] : models;
        },

        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options = options ? _.clone(options) : {};
          for (var i = 0, l = this.models.length; i < l; i++) {
            this._removeReference(this.models[i]);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _.extend({silent: true}, options));
          if (!options.silent) this.trigger('reset', this, options);
          return models;
        },

        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, _.extend({at: this.length}, options));
        },

        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          this.remove(model, options);
          return model;
        },

        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, _.extend({at: 0}, options));
        },

        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          this.remove(model, options);
          return model;
        },

        // Slice out a sub-array of models from the collection.
        slice: function() {
          return slice.apply(this.models, arguments);
        },

        // Get a model from the set by id.
        get: function(obj) {
          if (obj == null) return void 0;
          return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
        },

        // Get the model at the given index.
        at: function(index) {
          if (index < 0) {
            index += this.length;
          }

          return this.models[index];
        },

        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first) {
          if (_.isEmpty(attrs)) return first ? void 0 : [];
          return this[first ? 'find' : 'filter'](function(model) {
            for (var key in attrs) {
              if (attrs[key] !== model.get(key)) return false;
            }
            return true;
          });
        },

        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },

        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
          options || (options = {});

          // Run sort based on type of `comparator`.
          if (_.isString(this.comparator) || this.comparator.length === 1) {
            this.models = this.sortBy(this.comparator, this);
          } else {
            this.models.sort(_.bind(this.comparator, this));
          }

          if (!options.silent) this.trigger('sort', this, options);
          return this;
        },

        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
          return _.invoke(this.models, 'get', attr);
        },

        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0) options.parse = true;
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? 'reset' : 'set';
            collection[method](resp, options);
            if (success) success(collection, resp, options);
            collection.trigger('sync', collection, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },

        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
          options = options ? _.clone(options) : {};
          if (!(model = this._prepareModel(model, options))) return false;
          if (!options.wait) this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(model, resp, options) {
            if (options.wait) collection.add(model, options);
            if (success) success(model, resp, options);
          };
          model.save(null, options);
          return model;
        },

        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
          return resp;
        },

        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models);
        },

        // Define how to uniquely identify models in the collection.
        modelId: function (attrs) {
          return attrs[this.model.prototype.idAttribute || 'id'];
        },

        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId  = {};
        },

        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (attrs instanceof Model) return attrs;
          options = options ? _.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError) return model;
          this.trigger('invalid', this, model.validationError, options);
          return false;
        },

        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function (model) {
          return model instanceof Model;
        },

        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
          if (!model.collection) model.collection = this;
          model.on('all', this._onModelEvent, this);
        },

        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model) {
          if (this === model.collection) delete model.collection;
          model.off('all', this._onModelEvent, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if ((event === 'add' || event === 'remove') && collection !== this) return;
          if (event === 'destroy') this.remove(model, options);
          if (event === 'change') {
            var prevId = this.modelId(model.previousAttributes());
            var id = this.modelId(model.attributes);
            if (prevId !== id) {
              if (prevId != null) delete this._byId[prevId];
              if (id != null) this._byId[id] = model;
            }
          }
          this.trigger.apply(this, arguments);
        }
      });

      // Underscore methods that we want to implement on the Collection.
      // 90% of the core usefulness of Backbone Collections is actually implemented
      // right here:
      var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
        'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
        'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
        'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
        'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'indexBy', 'sample', 'shuffle',
        'lastIndexOf', 'isEmpty', 'chain'];

      // Mix in each Underscore method as a proxy to `Collection#models`.
      _.each(methods, function(method) {
        Collection.prototype[method] = function() {
          var args = slice.call(arguments);
          args.unshift(this.models);
          return _[method].apply(_, args);
        };
      });

      // Underscore methods that take a property name as an argument.
      var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

      // Use attributes instead of properties.
      _.each(attributeMethods, function(method) {
        Collection.prototype[method] = function(value, context) {
          var iterator = _.isFunction(value) ? value : function(model) {
            return model.get(value);
          };
          return _[method](this.models, iterator, context);
        };
      });

      module.exports = Collection;
    })(null, module.exports, module);

    return module.exports;
  })();

  //     Underscore.js 1.7.0
  //     http://underscorejs.org
  //     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.7.0';

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    var createCallback = function(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        case 2: return function(value, other) {
          return func.call(context, value, other);
        };
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };

    // A mostly-internal function to generate callbacks that can be applied
    // to each element in a collection, returning the desired result — either
    // identity, an arbitrary callback, a property matcher, or a property accessor.
    _.iteratee = function(value, context, argCount) {
      if (value == null) return _.identity;
      if (_.isFunction(value)) return createCallback(value, context, argCount);
      if (_.isObject(value)) return _.matches(value);
      return _.property(value);
    };

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    _.each = _.forEach = function(obj, iteratee, context) {
      if (obj == null) return obj;
      iteratee = createCallback(iteratee, context);
      var i, length = obj.length;
      if (length === +length) {
        for (i = 0; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };

    // Return the results of applying the iteratee to each element.
    _.map = _.collect = function(obj, iteratee, context) {
      if (obj == null) return [];
      iteratee = _.iteratee(iteratee, context);
      var keys = obj.length !== +obj.length && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length),
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
      if (obj == null) obj = [];
      iteratee = createCallback(iteratee, context, 4);
      var keys = obj.length !== +obj.length && _.keys(obj),
          length = (keys || obj).length,
          index = 0, currentKey;
      if (arguments.length < 3) {
        if (!length) throw new TypeError(reduceError);
        memo = obj[keys ? keys[index++] : index++];
      }
      for (; index < length; index++) {
        currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
      if (obj == null) obj = [];
      iteratee = createCallback(iteratee, context, 4);
      var keys = obj.length !== + obj.length && _.keys(obj),
          index = (keys || obj).length,
          currentKey;
      if (arguments.length < 3) {
        if (!index) throw new TypeError(reduceError);
        memo = obj[keys ? keys[--index] : --index];
      }
      while (index--) {
        currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, predicate, context) {
      var result;
      predicate = _.iteratee(predicate, context);
      _.some(obj, function(value, index, list) {
        if (predicate(value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Aliased as `select`.
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      if (obj == null) return results;
      predicate = _.iteratee(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(_.iteratee(predicate)), context);
    };

    // Determine whether all of the elements match a truth test.
    // Aliased as `all`.
    _.every = _.all = function(obj, predicate, context) {
      if (obj == null) return true;
      predicate = _.iteratee(predicate, context);
      var keys = obj.length !== +obj.length && _.keys(obj),
          length = (keys || obj).length,
          index, currentKey;
      for (index = 0; index < length; index++) {
        currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    };

    // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.
    _.some = _.any = function(obj, predicate, context) {
      if (obj == null) return false;
      predicate = _.iteratee(predicate, context);
      var keys = obj.length !== +obj.length && _.keys(obj),
          length = (keys || obj).length,
          index, currentKey;
      for (index = 0; index < length; index++) {
        currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
      if (obj == null) return false;
      if (obj.length !== +obj.length) obj = _.values(obj);
      return _.indexOf(obj, target) >= 0;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        return (isFunc ? method : value[method]).apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matches(attrs));
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matches(attrs));
    };

    // Return the maximum element (or element-based computation).
    _.max = function(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null && obj != null) {
        obj = obj.length === +obj.length ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value > result) {
            result = value;
          }
        }
      } else {
        iteratee = _.iteratee(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null && obj != null) {
        obj = obj.length === +obj.length ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value < result) {
            result = value;
          }
        }
      } else {
        iteratee = _.iteratee(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Shuffle a collection, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
      var set = obj && obj.length === +obj.length ? obj : _.values(obj);
      var length = set.length;
      var shuffled = Array(length);
      for (var index = 0, rand; index < length; index++) {
        rand = _.random(0, index);
        if (rand !== index) shuffled[index] = shuffled[rand];
        shuffled[rand] = set[index];
      }
      return shuffled;
    };

    // Sample **n** random values from a collection.
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (obj.length !== +obj.length) obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // Sort the object's values by a criterion produced by an iteratee.
    _.sortBy = function(obj, iteratee, context) {
      iteratee = _.iteratee(iteratee, context);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iteratee(value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, iteratee, context) {
        var result = {};
        iteratee = _.iteratee(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, value, key) {
      if (_.has(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, value, key) {
      if (_.has(result, key)) result[key]++; else result[key] = 1;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = _.iteratee(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = array.length;
      while (low < high) {
        var mid = low + high >>> 1;
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    };

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return obj.length === +obj.length ? obj.length : _.keys(obj).length;
    };

    // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.
    _.partition = function(obj, predicate, context) {
      predicate = _.iteratee(predicate, context);
      var pass = [], fail = [];
      _.each(obj, function(value, key, obj) {
        (predicate(value, key, obj) ? pass : fail).push(value);
      });
      return [pass, fail];
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      if (n == null || guard) return array[0];
      if (n < 0) return [];
      return slice.call(array, 0, n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if (n == null || guard) return array[array.length - 1];
      return slice.call(array, Math.max(array.length - n, 0));
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, strict, output) {
      if (shallow && _.every(input, _.isArray)) {
        return concat.apply(output, input);
      }
      for (var i = 0, length = input.length; i < length; i++) {
        var value = input[i];
        if (!_.isArray(value) && !_.isArguments(value)) {
          if (!strict) output.push(value);
        } else if (shallow) {
          push.apply(output, value);
        } else {
          flatten(value, shallow, strict, output);
        }
      }
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (array == null) return [];
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = _.iteratee(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = array.length; i < length; i++) {
        var value = array[i];
        if (isSorted) {
          if (!i || seen !== value) result.push(value);
          seen = value;
        } else if (iteratee) {
          var computed = iteratee(value, i, array);
          if (_.indexOf(seen, computed) < 0) {
            seen.push(computed);
            result.push(value);
          }
        } else if (_.indexOf(result, value) < 0) {
          result.push(value);
        }
      }
      return result;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(flatten(arguments, true, true, []));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      if (array == null) return [];
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = array.length; i < length; i++) {
        var item = array[i];
        if (_.contains(result, item)) continue;
        for (var j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = flatten(slice.call(arguments, 1), true, true, []);
      return _.filter(array, function(value){
        return !_.contains(rest, value);
      });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function(array) {
      if (array == null) return [];
      var length = _.max(arguments, 'length').length;
      var results = Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(arguments, i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      if (list == null) return {};
      var result = {};
      for (var i = 0, length = list.length; i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
      if (array == null) return -1;
      var i = 0, length = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      for (; i < length; i++) if (array[i] === item) return i;
      return -1;
    };

    _.lastIndexOf = function(array, item, from) {
      if (array == null) return -1;
      var idx = array.length;
      if (typeof from == 'number') {
        idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
      }
      while (--idx >= 0) if (array[idx] === item) return idx;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = step || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var Ctor = function(){};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      var args, bound;
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
      args = slice.call(arguments, 2);
      bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        Ctor.prototype = func.prototype;
        var self = new Ctor;
        Ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (_.isObject(result)) return result;
        return self;
      };
      return bound;
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder, allowing any combination of arguments to be pre-filled.
    _.partial = function(func) {
      var boundArgs = slice.call(arguments, 1);
      return function() {
        var position = 0;
        var args = boundArgs.slice();
        for (var i = 0, length = args.length; i < length; i++) {
          if (args[i] === _) args[i] = arguments[position++];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return func.apply(this, args);
      };
    };

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    _.bindAll = function(obj) {
      var i, length = arguments.length, key;
      if (length <= 1) throw new Error('bindAll must be passed function names');
      for (i = 1; i < length; i++) {
        key = arguments[i];
        obj[key] = _.bind(obj[key], obj);
      }
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = hasher ? hasher.apply(this, arguments) : key;
        if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){
        return func.apply(null, args);
      }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      if (!options) options = {};
      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };
      return function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;

      var later = function() {
        var last = _.now() - timestamp;

        if (last < wait && last > 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          }
        }
      };

      return function() {
        context = this;
        args = arguments;
        timestamp = _.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };

    // Returns a negated version of the passed-in predicate.
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Returns a function that will only be executed before being called N times.
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        } else {
          func = null;
        }
        return memo;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = _.partial(_.before, 2);

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = function(obj) {
      if (!_.isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      if (!_.isObject(obj)) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          if (hasOwnProperty.call(source, prop)) {
              obj[prop] = source[prop];
          }
        }
      }
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj, iteratee, context) {
      var result = {}, key;
      if (obj == null) return result;
      if (_.isFunction(iteratee)) {
        iteratee = createCallback(iteratee, context);
        for (key in obj) {
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
      } else {
        var keys = concat.apply([], slice.call(arguments, 1));
        obj = new Object(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (key in obj) result[key] = obj[key];
        }
      }
      return result;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj, iteratee, context) {
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
      } else {
        var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      if (!_.isObject(obj)) return obj;
      for (var i = 1, length = arguments.length; i < length; i++) {
        var source = arguments[i];
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (
        aCtor !== bCtor &&
        // Handle Object.create(x) cases
        'constructor' in a && 'constructor' in b &&
        !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
          _.isFunction(bCtor) && bCtor instanceof bCtor)
      ) {
        return false;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size, result;
      // Recursively compare objects and arrays.
      if (className === '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size === b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Deep compare objects.
        var keys = _.keys(a), key;
        size = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        result = _.keys(b).length === size;
        if (result) {
          while (size--) {
            // Deep compare each member
            key = keys[size];
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return _.has(obj, 'callee');
      };
    }

    // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
    if (typeof /./ !== 'function') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj !== +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iteratees.
    _.identity = function(value) {
      return value;
    };

    _.constant = function(value) {
      return function() {
        return value;
      };
    };

    _.noop = function(){};

    _.property = function(key) {
      return function(obj) {
        return obj[key];
      };
    };

    // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
    _.matches = function(attrs) {
      var pairs = _.pairs(attrs), length = pairs.length;
      return function(obj) {
        if (obj == null) return !length;
        obj = new Object(obj);
        for (var i = 0; i < length; i++) {
          var pair = pairs[i], key = pair[0];
          if (pair[1] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
    };

    // Run a function **n** times.
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = createCallback(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // A (possibly faster) way to get the current timestamp as an integer.
    _.now = Date.now || function() {
      return new Date().getTime();
    };

     // List of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property) {
      if (object == null) return void 0;
      var value = object[property];
      return _.isFunction(value) ? object[property]() : value;
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escaper, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offest.
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      try {
        var render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled source as a convenience for precompilation.
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function. Start chaining a wrapped Underscore object.
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result.call(this, method.apply(this._wrapped, arguments));
      };
    });

    // Extracts the result from a wrapped and chained object.
    _.prototype.value = function() {
      return this._wrapped;
    };

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (typeof define === 'function' && define.amd) {
      define.modules.underscore = (function(){
        return _;
      })();
    }
  }.call(this));

  define.modules['lib/view'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // Normalize Window for Node environments.
      var win = typeof global === "object" ? global : window;

      var Class = define.modules['lib/class'];
      var Model = define.modules['lib/model'];
      var Collection = define.modules['lib/collection'];

      // Utilities.
      var _ = define.modules.underscore;

      // jQuery methods.
      var $ = define.modules.jquery;

      // Cached regex to split keys for `delegate`.
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;

      // Cache these methods for performance.
      var aPush = Array.prototype.push;
      var aConcat = Array.prototype.concat;
      var aSplice = Array.prototype.splice;
      var trim = String.prototype.trim ?
        _.bind(String.prototype.trim.call, String.prototype.trim) :
        $.trim;

      var View = Class.extend({
        // All Views are mangaed.
        manage: true,

        _render: function() {
          // Keep the view consistent between callbacks and deferreds.
          var view = this;
          // Shorthand the manager.
          var manager = view.__manager__;
          // Cache these properties.
          var beforeRender = view.beforeRender;
          // Create a deferred instead of going off
          var def = view.deferred();

          // Ensure all nested Views are properly scrubbed if re-rendering.
          if (view.hasRendered) {
            view._removeViews();
          }

          // This continues the render flow after `beforeRender` has completed.
          manager.callback = function() {
            // Clean up asynchronous manager properties.
            delete manager.isAsync;
            delete manager.callback;

            // Always emit a beforeRender event.
            view.trigger("beforeRender", view);

            // Render!
            view._viewRender(manager).render().then(function() {
              // Complete this deferred once resolved.
              def.resolve();
            });
          };

          // If a beforeRender function is defined, call it.
          if (beforeRender) {
            beforeRender.call(view, view);
          }

          if (!manager.isAsync) {
            manager.callback();
          }

          // Return this intermediary promise.
          return def.promise();
        },

        // This function is responsible for pairing the rendered template into the
        // DOM element.
        _applyTemplate: function(rendered, manager, def) {
          // Actually put the rendered contents into the element.
          if (_.isString(rendered)) {
            // If no container is specified, we must replace the content.
            if (manager.noel) {
              rendered = $.parseHTML(rendered, true);

              // Remove extra root elements.
              this.$el.slice(1).remove();

              // Swap out the View on the first top level element to avoid
              // duplication.
              this.$el.replaceWith(rendered);

              // Don't delegate events here - we'll do that in resolve()
              this.setElement(rendered, false);
            } else {
              this.html(this.$el, rendered);
            }
          }

          // Resolve only after fetch and render have succeeded.
          def.resolveWith(this, [this]);
        },

        // Creates a deferred and returns a function to call when finished.
        // This gets passed to all _render methods.  The `root` value here is passed
        // from the `manage(this).render()` line in the `_render` function
        _viewRender: function(manager) {
          var url, contents, def;
          var root = this;

          // Once the template is successfully fetched, use its contents to proceed.
          // Context argument is first, since it is bound for partial application
          // reasons.
          function done(context, template) {
            // Store the rendered template someplace so it can be re-assignable.
            var rendered;

            // Trigger this once the render method has completed.
            manager.callback = function(rendered) {
              // Clean up asynchronous manager properties.
              delete manager.isAsync;
              delete manager.callback;

              root._applyTemplate(rendered, manager, def);
            };

            // Ensure the cache is up-to-date.
            View.cache(url, template);

            // Render the View into the el property.
            if (template) {
              rendered = root.renderTemplate.call(root, template, context);
            }

            // If the function was synchronous, continue execution.
            if (!manager.isAsync) {
              root._applyTemplate(rendered, manager, def);
            }
          }

          return {
            // This `render` function is what gets called inside of the View render,
            // when `manage(this).render` is called.  Returns a promise that can be
            // used to know when the element has been rendered into its parent.
            render: function() {
              var context = root.serialize;
              var template = root.template;

              // Create a deferred specifically for fetching.
              def = root.deferred();

              // If data is a function, immediately call it.
              if (_.isFunction(context)) {
                context = context.call(root);
              }

              // Set the internal callback to trigger once the asynchronous or
              // synchronous behavior has completed.
              manager.callback = function(contents) {
                // Clean up asynchronous manager properties.
                delete manager.isAsync;
                delete manager.callback;

                done(context, contents);
              };

              // Set the url to the prefix + the view's template property.
              if (typeof template === "string") {
                url = root.prefix + template;
              }

              // Check if contents are already cached and if they are, simply process
              // the template with the correct data.
              if (contents = View.cache(url)) {
                done(context, contents, url);

                return def;
              }

              // Fetch layout and template contents.
              if (typeof template === "string") {
                contents = root.fetchTemplate.call(root, root.prefix +
                  template);
              // If the template is already a function, simply call it.
              } else if (typeof template === "function") {
                contents = template;
              // If its not a string and not undefined, pass the value to `fetch`.
              } else if (template != null) {
                contents = root.fetchTemplate.call(root, template);
              }

              // If the function was synchronous, continue execution.
              if (!manager.isAsync) {
                done(context, contents);
              }

              return def;
            }
          };
        },

        // This method is used within specific methods to indicate that they should
        // be treated as asynchronous.  This method should only be used within the
        // render chain, otherwise unexpected behavior may occur.
        async: function() {
          var manager = this.__manager__;

          // Set this View's action to be asynchronous.
          manager.isAsync = true;

          // Return the callback.
          return manager.callback;
        },

        promise: function() {
          return this.__manager__.renderDeferred.promise();
        },

        // Proxy `then` for easier invocation.
        then: function() {
          return this.promise().then.apply(this, arguments);
        },

        // Sometimes it's desirable to only render the child views under the parent.
        // This is typical for a layout that does not change.  This method will
        // iterate over the provided views or delegate to `getViews` to fetch child
        // Views and aggregate all render promises and return the parent View.
        // The internal `promise()` method will return the aggregate promise that
        // resolves once all children have completed their render.
        renderViews: function(views) {
          var root = this;
          var manager = root.__manager__;
          var newDeferred = root.deferred();

          // If the caller provided an array of views then render those, otherwise
          // delegate to getViews.
          if (views && _.isArray(views)) {
            views = _.chain(views);
          } else {
            views = root.getViews(views);
          }

          // Collect all promises from rendering the child views and wait till they
          // all complete.
          var promises = views.map(function(view) {
            return view.render().__manager__.renderDeferred;
          }).value();

          // Simulate a parent render to remain consistent.
          manager.renderDeferred = newDeferred.promise();

          // Once all child views have completed rendering, resolve parent deferred
          // with the correct context.
          root.when(promises).then(function() {
            newDeferred.resolveWith(root, [root]);
          });

          // Allow this method to be chained.
          return root;
        },

        // Shorthand to `setView` function with the `insert` flag set.
        insertView: function(selector, view) {
          // If the `view` argument exists, then a selector was passed in.  This code
          // path will forward the selector on to `setView`.
          if (view) {
            return this.setView(selector, view, true);
          }

          // If no `view` argument is defined, then assume the first argument is the
          // View, somewhat now confusingly named `selector`.
          return this.setView(selector, true);
        },

        // Iterate over an object and ensure every value is wrapped in an array to
        // ensure they will be inserted, then pass that object to `setViews`.
        insertViews: function(views) {
          // If an array of views was passed it should be inserted into the
          // root view. Much like calling insertView without a selector.
          if (_.isArray(views)) {
            return this.setViews({ "": views });
          }

          _.each(views, function(view, selector) {
            views[selector] = _.isArray(view) ? view : [view];
          });

          return this.setViews(views);
        },

        // Returns the View that matches the `getViews` filter function.
        getView: function(fn) {
          // If `getView` is invoked with undefined as the first argument, then the
          // second argument will be used instead.  This is to allow
          // `getViews(undefined, fn)` to work as `getViews(fn)`.  Useful for when
          // you are allowing an optional selector.
          if (fn == null) {
            fn = arguments[1];
          }

          return this.getViews(fn).first().value();
        },

        // Provide a filter function to get a flattened array of all the subviews.
        // If the filter function is omitted it will return all subviews.  If a
        // String is passed instead, it will return the Views for that selector.
        getViews: function(fn) {
          var views;

          // If the filter argument is a String, then return a chained Version of the
          // elements. The value at the specified filter may be undefined, a single
          // view, or an array of views; in all cases, chain on a flat array.
          if (typeof fn === "string") {
            fn = this.sections[fn] || fn;
            views = this.views[fn] || [];

            // If Views is undefined you are concatenating an `undefined` to an array
            // resulting in a value being returned.  Defaulting to an array prevents
            // this.
            //return _.chain([].concat(views || []));
            return _.chain([].concat(views));
          }

          // Generate an array of all top level (no deeply nested) Views flattened.
          views = _.chain(this.views).map(function(view) {
            return _.isArray(view) ? view : [view];
          }, this).flatten();

          // If the argument passed is an Object, then pass it to `_.where`.
          if (typeof fn === "object") {
            return views.where(fn);
          }

          // If a filter function is provided, run it on all Views and return a
          // wrapped chain. Otherwise, simply return a wrapped chain of all Views.
          return typeof fn === "function" ? views.filter(fn) : views;
        },

        // Use this to remove Views, internally uses `getViews` so you can pass the
        // same argument here as you would to that method.
        removeView: function(fn) {
          // Allow an optional selector or function to find the right model and
          // remove nested Views based off the results of the selector or filter.
          return this.getViews(fn).each(function(nestedView) {
            nestedView.remove();
          });
        },

        // This takes in a partial name and view instance and assigns them to the
        // internal collection of views.  If a view is not a LayoutManager
        // instance, then mix in the LayoutManager prototype.  This ensures all
        // Views can be used successfully.
        //
        // Must definitely wrap any render method passed in or defaults to a
        // typical render function `return layout(this).render()`.
        setView: function(name, view, insert) {
          var manager, selector;
          // Parent view, the one you are setting a View on.
          var root = this;

          // If no name was passed, use an empty string and shift all arguments.
          if (typeof name !== "string") {
            insert = view;
            view = name;
            name = "";
          }

          // Shorthand the `__manager__` property.
          manager = view.__manager__;

          // If the View has not been properly set up, throw an Error message
          // indicating that the View needs `manage: true` set.
          if (!manager) {
            throw new Error("The argument associated with selector '" + name +
              "' is defined and a View.  Set `manage` property to true for " +
              "Backbone.View instances.");
          }

          // Add reference to the parentView.
          manager.parent = root;

          // Add reference to the placement selector used.
          selector = manager.selector = root.sections[name] || name;

          // Code path is less complex for Views that are not being inserted.
          // Simply remove existing Views and bail out with the assignment.
          if (!insert) {
            // Ensure remove is called only when swapping in a new view (when the
            // view is the same, it does not need to be removed or cleaned up).
            if (root.getView(name) !== view) {
              root.removeView(name);
            }

            // Assign to main views object and return for chainability.
            return root.views[selector] = view;
          }

          // Ensure this.views[selector] is an array and push this View to
          // the end.
          root.views[selector] = aConcat.call([], root.views[name] || [], view);

          // Put the parent view into `insert` mode.
          root.__manager__.insert = true;

          return view;
        },

        // Allows the setting of multiple views instead of a single view.
        setViews: function(views) {
          // Iterate over all the views and use the View's view method to assign.
          _.each(views, function(view, name) {
            // If the view is an array put all views into insert mode.
            if (_.isArray(view)) {
              return _.each(view, function(view) {
                this.insertView(name, view);
              }, this);
            }

            // Assign each view using the view function.
            this.setView(name, view);
          }, this);

          // Allow for chaining
          return this;
        },

        // By default this should find all nested views and render them into
        // the this.el and call done once all of them have successfully been
        // resolved.
        //
        // This function returns a promise that can be chained to determine
        // once all subviews and main view have been rendered into the view.el.
        render: function() {
          var root = this;
          var manager = root.__manager__;
          var parent = manager.parent;
          var rentManager = parent && parent.__manager__;
          var def = root.deferred();

          // Triggered once the render has succeeded.
          function resolve() {

            // Insert all subViews into the parent at once.
            _.each(root.views, function(views, selector) {
              // Fragments aren't used on arrays of subviews.
              if (_.isArray(views)) {
                root.htmlBatch(root, views, selector);
              }
            });

            // If there is a parent and we weren't attached to it via the previous
            // method (single view), attach.
            if (parent && !manager.insertedViaFragment) {
              if (!root.contains(parent.el, root.el)) {
                // Apply the partial using parent's html() method.
                parent.partial(parent.$el, root.$el, rentManager, manager);
              }
            }

            // Ensure events are always correctly bound after rendering.
            root.delegateEvents();

            // Set this View as successfully rendered.
            root.hasRendered = true;
            manager.renderInProgress = false;

            // Clear triggeredByRAF flag.
            delete manager.triggeredByRAF;

            // Only process the queue if it exists.
            if (manager.queue && manager.queue.length) {
              // Ensure that the next render is only called after all other
              // `done` handlers have completed.  This will prevent `render`
              // callbacks from firing out of order.
              (manager.queue.shift())();
            } else {
              // Once the queue is depleted, remove it, the render process has
              // completed.
              delete manager.queue;
            }

            // Reusable function for triggering the afterRender callback and event.
            function completeRender() {
              var console = window.console;
              var afterRender = root.afterRender;

              if (afterRender) {
                afterRender.call(root, root);
              }

              // Always emit an afterRender event.
              root.trigger("afterRender", root);

              // If there are multiple top level elements and `el: false` is used,
              // display a warning message and a stack trace.
              if (manager.noel && root.$el.length > 1) {
                // Do not display a warning while testing or if warning suppression
                // is enabled.
                if (_.isFunction(console.warn) && !root.suppressWarnings) {
                  console.warn("`el: false` with multiple top level elements is " +
                    "not supported.");

                  // Provide a stack trace if available to aid with debugging.
                  if (_.isFunction(console.trace)) {
                    console.trace();
                  }
                }
              }
            }

            // If the parent is currently rendering, wait until it has completed
            // until calling the nested View's `afterRender`.
            if (rentManager && (rentManager.renderInProgress || rentManager.queue)) {
              // Wait until the parent View has finished rendering, which could be
              // asynchronous, and trigger afterRender on this View once it has
              // completed.
              parent.once("afterRender", completeRender);
            } else {
              // This View and its parent have both rendered.
              completeRender();
            }

            return def.resolveWith(root, [root]);
          }

          // Actually facilitate a render.
          function actuallyRender() {

            // The `_viewRender` method is broken out to abstract away from having
            // too much code in `actuallyRender`.
            root._render().done(function() {
              // If there are no children to worry about, complete the render
              // instantly.
              if (!_.keys(root.views).length) {
                return resolve();
              }

              // Create a list of promises to wait on until rendering is done.
              // Since this method will run on all children as well, its sufficient
              // for a full hierarchical.
              var promises = _.map(root.views, function(view) {
                var insert = _.isArray(view);

                // If items are being inserted, they will be in a non-zero length
                // Array.
                if (insert && view.length) {
                  // Mark each subview's manager so they don't attempt to attach by
                  // themselves.  Return a single promise representing the entire
                  // render.
                  return root.when(_.map(view, function(subView) {
                    subView.__manager__.insertedViaFragment = true;
                    return subView.render().__manager__.renderDeferred;
                  }));
                }

                // Only return the fetch deferred, resolve the main deferred after
                // the element has been attached to it's parent.
                return !insert ? view.render().__manager__.renderDeferred : view;
              });

              // Once all nested Views have been rendered, resolve this View's
              // deferred.
              root.when(promises).done(resolve);
            });
          }

          // Mark this render as in progress. This will prevent
          // afterRender from being fired until the entire chain has rendered.
          manager.renderInProgress = true;

          // Start the render.
          // Register this request & cancel any that conflict.
          root._registerWithRAF(actuallyRender, def);

          // Put the deferred inside of the `__manager__` object, since we don't want
          // end users accessing this directly anymore in favor of the `afterRender`
          // event.  So instead of doing `render().then(...` do
          // `render().once("afterRender", ...`.
          // FIXME: I think we need to move back to promises so that we don't
          // miss events, regardless of sync/async (useRAF setting)
          manager.renderDeferred = def;

          // Return the actual View for chainability purposes.
          return root;
        },

        // Ensure the cleanup function is called whenever remove is called.
        remove: function() {
          // Force remove itself from its parent.
          View._removeView(this, true);
        },

        // Register a view render with RAF.
        _registerWithRAF: function(callback, deferred) {
          var root = this;
          var manager = root.__manager__;
          var rentManager = manager.parent && manager.parent.__manager__;

          // Allow RAF processing to be shut off using `useRAF`:false.
          if (this.useRAF === false) {
            if (manager.queue) {
              aPush.call(manager.queue, callback);
            } else {
              manager.queue = [];
              callback();
            }
            return;
          }

          // Keep track of all deferreds so we can resolve them.
          manager.deferreds = manager.deferreds || [];
          manager.deferreds.push(deferred);

          // Schedule resolving all deferreds that are waiting.
          deferred.done(resolveDeferreds);

          // Cancel any other renders on this view that are queued to execute.
          this._cancelQueuedRAFRender();

          // Trigger immediately if the parent was triggered by RAF.
          // The flag propagates downward so this view's children are also
          // rendered immediately.
          if (rentManager && rentManager.triggeredByRAF) {
            return finish();
          }

          // Register this request with requestAnimationFrame.
          manager.rafID = root.requestAnimationFrame(finish);

          function finish() {
            // Remove this ID as it is no longer valid.
            manager.rafID = null;

            // Set flag (will propagate to children) so they render
            // without waiting for RAF.
            manager.triggeredByRAF = true;

            // Call original cb.
            callback();
          }

          // Resolve all deferreds that were cancelled previously, if any.
          // This allows the user to bind callbacks to any render callback,
          // even if it was cancelled above.
          function resolveDeferreds() {
            for (var i = 0; i < manager.deferreds.length; i++){
              manager.deferreds[i].resolveWith(root, [root]);
            }
            manager.deferreds = [];
          }
        },

        // Cancel any queued render requests.
        _cancelQueuedRAFRender: function() {
          var root = this;
          var manager = root.__manager__;
          if (manager.rafID != null) {
            root.cancelAnimationFrame(manager.rafID);
          }
        },

        // Simply pass along the options to configure this new instance.
        constructor: function(options) {
          var noel;

          // Ensure options is always an object.
          options = options || {};

          // Remove the container element provided by Backbone.
          if ("el" in options ? options.el === false : this.el === false) {
            noel = true;
          }

          // Backbone compatibility.
          this.cid = _.uniqueId("view");

          // Set up this View.
          View.setupView(this, options);

          // Assign the `noel` property once we're sure the View we're working with
          // is managed by LayoutManager.
          if (this.__manager__) {
            this.__manager__.noel = noel;
            this.__manager__.suppressWarnings = options.suppressWarnings;
          }

          // Backbone compatibility.
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }

          var events = _.result(options, "events") || _.result(this, "events");

          this.delegateEvents(events);
        },

        // Get a model from the set by id.
        get: function(obj) {
          if (obj == null) return void 0;
          var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
          return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
        },

        // Default the scope to the View instance.
        serialize: function() {
          return this;
        },
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be prefered to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },

        // Clean up and then set a new element.
        setElement: function(element) {
          if (this.$el) {
            this.undelegateEvents();
          }

          if (element) {
            // If an element was immediately provided, give that highest
            // precedence.
            this.$el = element instanceof View.$ ? element : View.$(element);

            // Backbone compatibility.
            this.el = this.$el.get()[0];

            // Bind new events.
            this.delegateEvents();

            return this;
          }

          // Assemble a master list of attributes.
          var attrs = _.extend({}, {
            // Attach an id if it exists.
            id: _.result(this, "id"),

            // Attach classes if they were added.
            class: _.result(this, "className")
          }, _.result(this, "attributes"));

          // If neither an element was provided nor derived from the `el` property,
          // then craft an element from the `tagName` property.  Defaults to `div`.
          this.$el = View.$("<" + _.result(this, "tagName") + ">");

          // Configure the element.
          this.$el.attr(attrs);

          // Backbone compatibility.
          this.el = this.$el.get()[0];

          // Bind new events.
          this.delegateEvents();

          return this;
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events) {
          if (!(events || (events = _.result(this, 'events')))) return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method)) method = this[events[key]];
            if (!method) continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], _.bind(method, this));
          }
          return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
          if (this.$el) this.$el.off('.delegateEvents' + this.cid);
          return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
        },
      });

      // This are 'Class-level' properties that shouldn't be associated with any
      // specific View.
      View.mixin({
        // Expose jQuery.
        $: $,

        // Clearable cache.
        _cache: {},

        // Remove all nested Views.
        _removeViews: function(root, force) {
          // Shift arguments around.
          if (typeof root === "boolean") {
            force = root;
            root = this;
          }

          // Allow removeView to be called on instances.
          root = root || this;

          // Iterate over all of the nested View's and remove.
          root.getViews().each(function(view) {
            // Force doesn't care about if a View has rendered or not.
            if (view.hasRendered || force) {
              View._removeView(view, force);
            }
          });
        },

        // Remove a single nested View.
        _removeView: function(view, force) {
          var parentViews;
          // Shorthand the managers for easier access.
          var manager = view.__manager__;
          var rentManager = manager.parent && manager.parent.__manager__;
          // Test for keep.
          var keep = typeof view.keep === "boolean" ? view.keep : view.options.keep;

          // In insert mode, remove views that do not have `keep` attribute set,
          // unless the force flag is set.
          if ((!keep && rentManager && rentManager.insert === true) || force) {
            // Clean out the events.
            View.cleanViews(view);

            // Since we are removing this view, force subviews to remove
            view._removeViews(true);

            // Remove the View completely.
            view.$el.remove();

            // Cancel any pending renders, if present.
            view._cancelQueuedRAFRender();

            // Bail out early if no parent exists.
            if (!manager.parent) { return; }

            // Assign (if they exist) the sibling Views to a property.
            parentViews = manager.parent.views[manager.selector];

            // If this is an array of items remove items that are not marked to
            // keep.
            if (_.isArray(parentViews)) {
              // Remove duplicate Views.
              _.each(_.clone(parentViews), function(view, i) {
                // If the managers match, splice off this View.
                if (view && view.__manager__ === manager) {
                  aSplice.call(parentViews, i, 1);
                }
              });
              if (_.isEmpty(parentViews)) {
                manager.parent.trigger("empty", manager.selector);
              }
              return;
            }

            // Otherwise delete the parent selector.
            delete manager.parent.views[manager.selector];
            manager.parent.trigger("empty", manager.selector);
          }
        },

        // Cache templates into LayoutManager._cache.
        cache: function(path, contents) {
          // If template path is found in the cache, return the contents.
          if (path in this._cache && contents == null) {
            return this._cache[path];
          // Ensure path and contents aren't undefined.
          } else if (path != null && contents != null) {
            return this._cache[path] = contents;
          }

          // If the template is not in the cache, return undefined.
        },

        // Accept either a single view or an array of views to clean of all DOM
        // events internal model and collection references and all Backbone.Events.
        cleanViews: function(views) {
          // Clear out all existing views.
          _.each(aConcat.call([], views), function(view) {
            // Remove all custom events attached to this View.
            view.unbind();

            // Automatically unbind `model`.
            if (view.model instanceof Model) {
              view.model.off(null, null, view);
            }

            // Automatically unbind `collection`.
            if (view.collection instanceof Collection) {
              view.collection.off(null, null, view);
            }

            // Automatically unbind events bound to this View.
            view.stopListening();

            // If a custom cleanup method was provided on the view, call it after
            // the initial cleanup is done
            if (_.isFunction(view.cleanup)) {
              view.cleanup();
            }
          });
        },

        // This static method allows for global configuration of LayoutManager.
        configure: function(options) {
          _.extend(View.prototype, options);
        },

        // Configure a View to work with the LayoutManager plugin.
        setupView: function(views, options) {
          // Ensure that options is always an object, and clone it so that
          // changes to the original object don't screw up this view.
          options = _.extend({}, options);

          // Set up all Views passed.
          _.each(aConcat.call([], views), function(view) {
            // If the View has already been setup, no need to do it again.
            if (view.__manager__) {
              return;
            }

            var views, declaredViews;

            // Ensure necessary properties are set.
            _.defaults(view, {
              // Ensure a view always has a views object.
              views: {},

              // Ensure a view always has a sections object.
              sections: {},

              // Internal state object used to store whether or not a View has been
              // taken over by layout manager and if it has been rendered into the
              // DOM.
              __manager__: {},

              // Add the ability to remove all Views.
              _removeViews: View._removeViews,

              // Add the ability to remove itself.
              _removeView: View._removeView
            });

            // Assign passed options.
            view.options = options;

            // Merge the View options into the View.
            _.extend(view, options);

            // Attach the element.
            view.setElement(_.result(view, "el"));

            // Normalize views to exist on either instance or options, default to
            // options.
            views = view.views;

            // Set the internal views, only if selectors have been provided.
            if (_.keys(views).length) {
              // Keep original object declared containing Views.
              declaredViews = views;

              // Reset the property to avoid duplication or overwritting.
              view.views = {};

              // If any declared view is wrapped in a function, invoke it.
              _.each(declaredViews, function(declaredView, key) {
                if (typeof declaredView === "function") {
                  declaredViews[key] = declaredView.call(view, view);
                }
              });

              // Set the declared Views.
              view.setViews(declaredViews);
            }
          });
        }
      });

      // Default options.
      View.configure({
        // Default nodeName to use.
        tagName: "div",

        // Prefix template/layout paths.
        prefix: "",

        // By default enable the use of `documentFragment`s to speed up the rendering
        // of nested Views.
        useRAF: true,

        // Can be used to supply a different deferred implementation.
        deferred: function() {
          return View.$.Deferred();
        },

        // Fetch is passed a path and is expected to return template contents as a
        // function or string.
        fetchTemplate: function(path) {
          return _.template(View.$(path).html());
        },

        // By default, render using underscore's templating.
        renderTemplate: function(template, context) {
          return trim(template.call(this, context));
        },

        // This is the most common way you will want to partially apply a view into
        // a layout.
        partial: function($root, $el, rentManager, manager) {
          var $filtered;

          // If selector is specified, attempt to find it.
          if (manager.selector) {
            if (rentManager.noel) {
              $filtered = $root.filter(manager.selector);
              $root = $filtered.length ? $filtered : $root.find(manager.selector);
            } else {
              $root = $root.find(manager.selector);
            }
          }

          // Use the insert method if the parent's `insert` argument is true.
          if (rentManager.insert) {
            this.insert($root, $el);
          } else {
            this.html($root, $el);
          }
        },

        // Override this with a custom HTML method, passed a root element and content
        // (a jQuery collection or a string) to replace the innerHTML with.
        html: function($root, content) {
          $root.empty().append(content);
        },

        // Used for inserting subViews in a single batch.  This gives a small
        // performance boost as we write to a disconnected fragment instead of to the
        // DOM directly. Smarter browsers like Chrome will batch writes internally
        // and layout as seldom as possible, but even in that case this provides a
        // decent boost.  jQuery will use a DocumentFragment for the batch update,
        // but Cheerio in Node will not.
        htmlBatch: function(rootView, subViews, selector) {
          // Shorthand the parent manager object.
          var rentManager = rootView.__manager__;
          // Create a simplified manager object that tells partial() where
          // place the elements.
          var manager = { selector: selector };

          // Get the elements to be inserted into the root view.
          var els = _.reduce(subViews, function(memo, sub) {
            // Check if keep is present - do boolean check in case the user
            // has created a `keep` function.
            var keep = typeof sub.keep === "boolean" ? sub.keep : sub.options.keep;
            // If a subView is present, don't push it.  This can only happen if
            // `keep: true`.  We do the keep check for speed as $.contains is not
            // cheap.
            var exists = keep && $.contains(rootView.el, sub.el);

            // If there is an element and it doesn't already exist in our structure
            // attach it.
            if (sub.el && !exists) {
              memo.push(sub.el);
            }

            return memo;
          }, []);

          // Use partial to apply the elements. Wrap els in jQ obj for cheerio.
          return this.partial(rootView.$el, $(els), rentManager, manager);
        },

        // Very similar to HTML except this one will appendChild by default.
        insert: function($root, $el) {
          $root.append($el);
        },

        // Return a deferred for when all promises resolve/reject.
        when: function(promises) {
          return View.$.when.apply(null, promises);
        },

        // A method to determine if a View contains another.
        contains: function(parent, child) {
          return View.$.contains(parent, child);
        },

        // Based on:
        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and
        // Tino Zijdel.
        requestAnimationFrame: (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          var requestAnimationFrame = win.requestAnimationFrame;

          for (var i = 0; i < vendors.length && !win.requestAnimationFrame; ++i) {
            requestAnimationFrame = win[vendors[i] + "RequestAnimationFrame"];
          }

          if (!requestAnimationFrame){
            requestAnimationFrame = function(callback) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = win.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          }

          return _.bind(requestAnimationFrame, win);
        })(),

        cancelAnimationFrame: (function() {
          var vendors = ["ms", "moz", "webkit", "o"];
          var cancelAnimationFrame = win.cancelAnimationFrame;

          for (var i = 0; i < vendors.length && !win.requestAnimationFrame; ++i) {
            cancelAnimationFrame =
              win[vendors[i] + "CancelAnimationFrame"] ||
              win[vendors[i] + "CancelRequestAnimationFrame"];
          }

          if (!cancelAnimationFrame) {
            cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
          }

          return _.bind(cancelAnimationFrame, win);
        })()
      });

      module.exports = View;
    })(null, module.exports, module);

    return module.exports;
  })();

  !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define("scopedcss", [],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.ScopedCSS=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
  'use strict';
  var CssRule = function (cssRule, index) {
      this.rule = cssRule;
      this.index = index;
  };
  CssRule.prototype.formatSelector = function (prefix, selector) {
      return selector.split(', ').map(function (part) {
          return prefix + ' ' + part;
      }).join(', ');
  };
  CssRule.prototype.formatCssText = function (prefix, cssText) {
      var flip = 0;
      return cssText.split(/ }\s?{/).map(function (selector) {
          return ++flip % 2 ? this.formatSelector(prefix, selector) : selector;
      }, this).join(' }{');
  };
  CssRule.prototype.applyPrefix = function (prefix) {
      var selectorText = this.rule.selectorText;
      var parentStyleSheet = this.rule.parentStyleSheet;
      var cssText = this.rule.cssText;
      selectorText = selectorText ? selectorText.replace(/\"/g, '\'') : '';
      if (selectorText.indexOf(prefix) !== 0) {
          this.rule.selectorText = this.formatSelector(prefix, selectorText);
          if (this.rule.selectorText === selectorText) {
              cssText = this.formatCssText(prefix, cssText);
              parentStyleSheet.deleteRule(this.index);
              parentStyleSheet.insertRule(cssText, this.index);
          }
      }
  };
  module.exports = CssRule;
  },{}],2:[function(_dereq_,module,exports){
  var StyleSheet = _dereq_('./styleSheet');
  'use strict';
  var ScopedCss = function (prefix, cssText, styleTag) {
      this.prefix = prefix;
      this.cssText = cssText;
      this.styleTag = styleTag || document.createElement('style');
  };
  ScopedCss.defaultSelector = ':not([data-scopedcss]) style[scoped]';
  ScopedCss.VERSION = '0.1.4';
  ScopedCss.prototype.prepare = function (cssText) {
      return cssText.replace(/:host/g, this.prefix);
  };
  ScopedCss.prototype.process = function (prefix) {
      if (prefix) {
          this.prefix = prefix;
      }
      var cssText = this.cssText || this.styleTag.innerHTML;
      var styleText = document.createTextNode(this.prepare(cssText));
      this.styleTag.innerHTML = '';
      this.styleTag.appendChild(styleText);
      var styleSheet = new StyleSheet(this.styleTag);
      var cssRules = styleSheet.cssRules();
      if (this.prefix) {
          cssRules.forEach(function (rule) {
              rule.applyPrefix(this.prefix);
          }, this);
      }
  };
  ScopedCss.applyTo = function (hostElement) {
      hostElement = hostElement || document.body;
      var elements = hostElement.querySelectorAll(this.defaultSelector);
      Array.prototype.slice.call(elements).forEach(function (element) {
          var id = (new Date() * Math.random()).toString(16);
          element.parentNode.setAttribute('data-scopedcss', id);
          new ScopedCss('[data-scopedcss=\'' + id + '\']', null, element).process();
      });
  };
  module.exports = ScopedCss;
  },{"./styleSheet":3}],3:[function(_dereq_,module,exports){
  var CssRule = _dereq_('./cssRule');
  'use strict';
  var StyleSheet = function (styleTag) {
      this.styleTag = styleTag;
      if (!this.styleTag.parentNode) {
          document.head.appendChild(this.styleTag);
      }
  };
  StyleSheet.prototype.getStyleSheet = function () {
      return this.styleTag.sheet;
  };
  StyleSheet.prototype.cssRules = function () {
      var rules = Array.prototype.slice.call(this.getStyleSheet().cssRules);
      return rules.map(function (rule, index) {
          return new CssRule(rule, index);
      });
  };
  module.exports = StyleSheet;
  },{"./cssRule":1}]},{},[2])
  (2)
  });
  define.modules['lib/component'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var View = define.modules['lib/view'];
      var Channel = define.modules['lib/channel'];

      var _ = define.modules.lodash;
      var $ = define.modules.jquery;
      var ScopedCss = define.modules.scopedcss;

      // The View base class for the Component.
      var Component = View.extend({
        constructor: function(options) {
          // Ensure the View is correctly set up.
          Component.super("constructor", this, arguments);

          // Attach the dataset.
          this.dataset = this.$el.data();

          // Always create a channel.
          this.channel = Channel.create(this.channels);

          // Maintain the dataset.
          this.channel.subscribe(function(value, key) {
            this.dataset[key] = value;
          }, this);
        },

        // Default to data found in the DOM.
        serialize: function() {
          return this.dataset;
        },

        afterRender: function() {
          // Seek out nested components and render them.
          Component.activateAll(this);

          // Also activate all scoped stylesheets.
          ScopedCss.applyTo(this.$el[0]);
        }
      });

      Component.configure({
        // Convert into a Lo-Dash template.
        fetchTemplate: _.template
      });

      Component.mixin({
        components: {},

        register: function(Component, identifier) {
          // Allow a manual override of the selector to use.
          identifier = identifier || Component.prototype.selector;

          // Register a Component constructor, not an instance.
          this.components[identifier] = {
            ctor: Component,
            instances: []
          };

          var cssText = Component.prototype.styles;

          if (cssText) {
            // Create the scoped object outside of the fetch.
            document.body.appendChild(new ScopedCss(identifier, cssText).styleTag);
          }

          // Save a pointer for easier lookup.
          Component.__pointer__ = this.components[identifier];

          return Component;
        },

        unregister: function(identifier) {
          delete this.components[identifier];
        },

        augment: function(cb) {
          _.each(this.__pointer__.instances, function(instance) {
            cb.call(instance, instance);
          });
        },

        activate: function($el, instances) {
          var CurrentComponent = this;

          // Convert all attributes on the Element into View properties.
          var attrs = _.reduce($el[0].attributes, function(attrs, attr) {
            // Optionally consume data attributes.
            if (attr.name.indexOf("data-") === 0) {
              attr.name = attr.name.slice(5);
            }

            attrs[attr.name] = attr.value;

            return attrs;
          }, {});

          // Associate the element as well.
          attrs.el = $el;

          // Create a new Component.
          var component = new CurrentComponent(attrs);

          // Trigger the standard `createdCallback`.
          if (typeof component.createdCallback === "function") {
            component.createdCallback();
          }

          // Add to the internal cache.
          instances.push(component);

          // By default use the template property provided, otherwise pull the
          // template contents from the DOM.
          if (!component.template) {
            component.template = _.template(_.unescape($el.html()));
          }

          // Render and apply to the Document.
          component.render();
        },

        activateAll: function(component) {
          var el = component ? component.el : document.body;

          _.each(this.components, function(Component, selector) {
            $(el).find(selector).each(function() {
              Component.ctor.activate($(this), Component.instances);
            });
          });
        }
      });

      module.exports = Component;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/history'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];

      var _ = define.modules.lodash;
      var $ = define.modules.jquery;

      // Cached regex for stripping a leading hash/slash and trailing space.
      var routeStripper = /^[#\/]|\s+$/g;

      // Cached regex for stripping leading and trailing slashes.
      var rootStripper = /^\/+|\/+$/g;

      // Cached regex for detecting MSIE.
      var isExplorer = /msie [\w.]+/;

      // Cached regex for removing a trailing slash.
      var trailingSlash = /\/$/;

      // Cached regex for stripping urls of hash.
      var pathStripper = /#.*$/;

      // Backbone.History
      // ----------------

      // Handles cross-browser history management, based on either
      // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
      // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
      // and URL fragments. If the browser supports neither (old IE, natch),
      // falls back to polling.
      var History = Class.extend({
        constructor: function() {
          this.handlers = [];
          _.bindAll(this, 'checkUrl');

          // Ensure that `History` can be used outside of the browser.
          if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
          }
        },

        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,

        // Are we at the app root?
        atRoot: function() {
          var path = this.location.pathname.replace(/[^\/]$/, '$&/');
          return path === this.root && !this.getSearch();
        },

        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
          return match ? match[0] : '';
        },

        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window) {
          var match = (window || this).location.href.match(/#(.*)$/);
          return match ? match[1] : '';
        },

        // Get the pathname and search params, without the root.
        getPath: function() {
          var path = decodeURI(this.location.pathname + this.getSearch());
          var root = this.root.slice(0, -1);
          if (!path.indexOf(root)) path = path.slice(root.length);
          return path.charAt(0) === '/' ? path.slice(1) : path;
        },

        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment, forcePushState) {
          if (fragment == null) {
            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
              fragment = decodeURI(this.location.pathname + this.location.search);
              var root = this.root.replace(trailingSlash, '');
              if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, '');
        },

        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
          if (History.started) throw new Error("Backbone.history has already been started");
          History.started = true;

          // Figure out the initial configuration. Do we need an iframe?
          // Is pushState desired ... is it available?
          this.options          = _.extend({root: '/'}, this.options, options);
          this.root             = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._wantsPushState  = !!this.options.pushState;
          this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
          var fragment          = this.getFragment();
          var docMode           = document.documentMode;
          var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

          // Normalize root to always include a leading and trailing slash.
          this.root = ('/' + this.root + '/').replace(rootStripper, '/');

          if (oldIE && this._wantsHashChange) {
            var frame = $('<iframe src="javascript:0" tabindex="-1">');
            this.iframe = frame.hide().appendTo('body')[0].contentWindow;
            this.navigate(fragment);
          }

          // Depending on whether we're using pushState or hashes, and whether
          // 'onhashchange' is supported, determine how we check the URL state.
          if (this._hasPushState) {
            $(window).on('popstate', this.checkUrl);
          } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
            $(window).on('hashchange', this.checkUrl);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }

          // Determine if we need to change the base url, for a pushState link
          // opened by a non-pushState browser.
          this.fragment = fragment;
          var loc = this.location;

          // Transition from hashChange to pushState or vice versa if both are
          // requested.
          if (this._wantsHashChange && this._wantsPushState) {

            // If we've started off with a route from a `pushState`-enabled
            // browser, but we're currently in a browser that doesn't support it...
            if (!this._hasPushState && !this.atRoot()) {
              this.fragment = this.getFragment(null, true);
              this.location.replace(this.root + '#' + this.fragment);
              // Return immediately as browser will do redirect to new url
              return true;

            // Or if we've started out with a hash-based route, but we're currently
            // in a browser where it could be `pushState`-based instead...
            } else if (this._hasPushState && this.atRoot() && loc.hash) {
              this.fragment = this.getHash().replace(routeStripper, '');
              this.history.replaceState({}, document.title, this.root + this.fragment);
            }

          }

          if (!this.options.silent) return this.loadUrl();
        },

        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
          // Add a cross-platform `removeEventListener` shim for older browsers.
          var removeEventListener = window.removeEventListener || function (eventName, listener) {
            return detachEvent('on' + eventName, listener);
          };

          // Remove window listeners.
          if (this._hasPushState) {
            removeEventListener('popstate', this.checkUrl, false);
          } else if (this._wantsHashChange && this._hasHashChange && !this.iframe) {
            removeEventListener('hashchange', this.checkUrl, false);
          }

          // Clean up the iframe if necessary.
          if (this.iframe) {
            document.body.removeChild(this.iframe.frameElement);
            this.iframe = null;
          }

          // Some environments will throw when clearing an undefined interval.
          if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
          History.started = false;
        },

        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
          this.handlers.unshift({route: route, callback: callback});
        },

        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e) {
          var current = this.getFragment();

          // If the user pressed the back button, the iframe's hash will have
          // changed and we should use that for comparison.
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe);
          }

          if (current === this.fragment) return false;
          if (this.iframe) this.navigate(current);
          this.loadUrl();
        },

        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
          fragment = this.fragment = this.getFragment(fragment);
          return _.any(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },

        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
          if (!History.started) return false;
          if (!options || options === true) options = {trigger: !!options};

          var url = this.root + (fragment = this.getFragment(fragment || ''));

          // Strip the hash for matching.
          fragment = fragment.replace(pathStripper, '');

          if (this.fragment === fragment) return;
          this.fragment = fragment;

          // Don't include a trailing slash on the root.
          if (fragment === '' && url !== '/') url = url.slice(0, -1);

          // If pushState is available, we use it to set the fragment as a real URL.
          if (this._hasPushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

          // If hash changes haven't been explicitly disabled, update the hash
          // fragment to store history.
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
              // Opening and closing the iframe tricks IE7 and earlier to push a
              // history entry on hash-tag change.  When replace is true, we don't
              // want this.
              if(!options.replace) this.iframe.document.open().close();
              this._updateHash(this.iframe.location, fragment, options.replace);
            }

          // If you've told us that you explicitly don't want fallback hashchange-
          // based history, then `navigate` becomes a page refresh.
          } else {
            return this.location.assign(url);
          }
          if (options.trigger) return this.loadUrl(fragment);
        },

        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location, fragment, replace) {
          if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, '');
            location.replace(href + '#' + fragment);
          } else {
            // Some browsers require that `hash` contains a leading #.
            location.hash = '#' + fragment;
          }
        }
      });

      // Has the history handling already been started?
      History.started = false;

      module.exports = History;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/router'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Class = define.modules['lib/class'];
      var _ = define.modules.lodash;

      // Cached regular expressions for matching named param parts and splatted
      // parts of route strings.
      var optionalParam = /\((.*?)\)/g;
      var namedParam    = /(\(\?)?:\w+/g;
      var splatParam    = /\*\w+/g;
      var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

      // Routers map faux-URLs to actions, and fire events when routes are
      // matched. Creating a new one sets its `routes` hash, if not set statically.
      var Router = Class.extend({
        constructor: function(options) {
          Router.super("constructor", this, arguments);

          options = _.extend(this, options);

          // Useful for nested functions.
          var root = this;
          // Use for normal routes.
          var routes = {};
          // Use for attached routers.
          var routers = this.routers = {};
          // Router attached routes, normalized.
          var normalizedRoutes = this.routes;

          // Iterate and augment the routes hash to accept Routers.
          _.each(normalizedRoutes, function(action, route) {
            var parent, router, SubRouter, originalRoute;
            var prefix = root.prefix;

            // Prefix is optional, set to empty string if not passed.
            if (!prefix) {
              prefix = route || "";
            }

            // Allow for optionally omitting trailing /.  Since base routes do not
            // trigger with a trailing / this is actually kind of important =).
            if (prefix.charAt(prefix.length-1) === "/") {
              prefix = prefix.substr(0, prefix.length-1);
            }

            // SubRouter constructors need to be augmented to allow for filters, they
            // are also attached to a special property on the RouteManager for
            // easy accessibility and event binding.
            if (action.prototype instanceof Router) {
              // Maintain a reference to the user-supplied constructor.
              parent = action.prototype.constructor;

              // Extend the SubRouter to override the constructor function.
              SubRouter = action.extend({
                constructor: function(options) {
                  var ctor = Router.prototype.constructor;

                  // keep routes in a separate hash or IE<9 reloop over new object index
                  var tempRoutes = {};

                  // Make sure to prefix all routes.
                  _.each(_.clone(this.routes), function(method, route) {
                    delete this.routes[route];

                    route = route ? prefix + "/" + route : prefix;

                    // Replace the route with the override.
                    tempRoutes[route] = method;
                    this[method] = Router.handleRoute.call(this, this[method],
                      route);
                  }, this);

                  this.routes = tempRoutes;

                  return ctor.apply(this, arguments);
                },

                // Overrideable options.
                options: Router.prototype.options
              });

              // Initialize the Router inside the collection.
              router = routers[route] = new SubRouter();

              // Give the router state!
              route._state = {};

              // Internal object cache for special RouteManager functionality.
              router.__manager__ = {
                // Used to avoid multiple lookups for router+prefix.
                prefix: prefix,
                // Necessary to know the top level Router.
                root: root
              };

              // If there is a custom constructor function provided by the user;
              // make sure to be a good samaritan.
              if (_.isFunction(parent)) {
                parent.call(router);
              }

              // No need to delete from this.routes, since the entire object is
              // replaced anyways.

            // If it is not a Backbone.Router, then its a normal route, assuming
            // the action and route are strings.
            } else if (_.isString(action) && _.isString(route)) {
              // Reset this here, since we don't want duplicate routes
              prefix = root.prefix ? root.prefix : "";

              // Add the route callbacks to the instance, since they are
              // currently inside the options object.
              root[action] = Router.handleRoute.call(root, root[action], route);

              // Add route to collection of "normal" routes, ensure prefixing.
              if (route) {
                return routes[prefix + route] = action;
              }

              // If the path is "" just set to prefix, this is to comply
              // with how Backbone expects base paths to look gallery vs gallery/.
              routes[prefix] = action;
            }
          });

          // Add the manager routes.
          this.routes = routes;
          this._bindRoutes();
          this.initialize.apply(this, arguments);
        },

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function(){},

        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
          if (!_.isRegExp(route)) route = this._routeToRegExp(route);
          if (_.isFunction(name)) {
            callback = name;
            name = '';
          }
          if (!callback) callback = this[name];
          var router = this;
          Router.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name) !== false) {
              router.trigger.apply(router, ['route:' + name].concat(args));
              router.trigger('route', name, args);
              Router.history.trigger('route', router, name, args);
            }
          });
          return this;
        },

        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name) {
          if (callback) callback.apply(this, args);
        },

        // Simple proxy to `Router.history` to save a fragment into the history.
        navigate: function(fragment, options) {
          Router.history.navigate(fragment, options);
          return this;
        },

        // Bind all defined routes to `Router.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
          if (!this.routes) return;
          this.routes = _.result(this, 'routes');
          var route, routes = _.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },

        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp, '\\$&')
                       .replace(optionalParam, '(?:$1)?')
                       .replace(namedParam, function(match, optional) {
                         return optional ? match : '([^/?]+)';
                       })
                       .replace(splatParam, '([^?]*?)');
          return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _.map(params, function(param, i) {
            // Don't decode the search params.
            if (i === params.length - 1) return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        },

        __manager__: { prefix: "" }
      });

      Router.mixin({
        // This static method allows for global configuration of RouteManager.
        configure: function(options) {
          var existing = Router.prototype.options;

          // Without this check the application would react strangely to a foreign
          // input.
          if (_.isObject(options)) {
            return _.extend(existing, options);
          }
        },

        // Wraps a route and provides the before/after filters and params object.
        handleRoute: function(original, route) {
          var fragment, routeName;
          var router = this;
          var options = router.options;

          // Detect the identifiers out of the route.
          var identifiers = _.map(route.match(/:(\w+)|\*(\w+)/g), function(arg) {
            return arg.slice(1);
          });

          // Replace the route function with the wrapped version.
          return function() {
            var args = arguments;

            // Its possible this function's context will be set to pull the wrong
            // router, ensure the correct property is selected.
            var router = this;

            // Set the fragment, as detected by Backbone.
            fragment = Router.history.fragment;

            // Reduce the arguments to the names inside the params object.
            this.params = _.reduce(identifiers, function(memo, arg, i) {
              memo[arg] = args[i];
            }, {});

            // Navigate the original route and then call the after callbacks.
            if (_.isFunction(original)) {
              original.apply(this, args);
            }
          };
        }
      });

      module.exports = Router;
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module component/view
   * @requires module:component
   */
  define.modules['lib/component/view'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // WebApp internals.
      var Component = define.modules['lib/component'];

      /**
       * A default view, `<webapp-view>`, that can be used in markup.
       *
       * @public
       * @memberOf module:component/view
       */
      var ViewComponent = Component.extend({
        selector: "webapp-view",

        constructor: function() {
          ViewComponent.super("constructor", this, arguments);
          this.channel.subscribe(this.render, this);
        }
      });

      module.exports = ViewComponent;
    })(null, module.exports, module);

    return module.exports;
  })();

  define.modules['lib/sync/resource'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      var Model = define.modules['lib/model'];
      var RestAdapter = define.modules['lib/sync/adapters/rest'];
      var XhrTransport = define.modules['lib/sync/transports/xhr'];

      var _ = define.modules.lodash;
      var $ = define.modules.jquery;

      var Resource = Model.extend({
        filter: function() {
          throw "Method not implemented.";
        },

        search: function() {
          throw "Method not implemented.";
        },

        sortBy: function() {
          throw "Method not implemented.";
        },

        update: function(objects) {
          // Save the full representation from the server.
          this.raw = objects;

          // A Lo-Dash wrapped version of the data.
          this.dataset = _.chain(objects);
        },

        syncUpdate: function(options) {
          options = _.extend({}, this.options, options);

          // Attach the resource reference.
          options.model = this;

          var transport = options.transport || this.transport;

          // The following method will choke if we have not previously fetched and
          // set a `last_modified` value.
          if (this.get("last_modified")) {
            transport.requestIfModified(options);
          }
        },

        // Only publically expose the promise.
        promise: function() {
          return this._def.promise();
        },

        url: "Property not implemented.",

        syncAll: function(options) {
          options = _.extend({}, this.options, options);

          // Attach the resource reference.
          options.model = this;
          this.unset("last_modified");

          // Pipe through the identical sync method.
          return this.sync("GET", this, options);
        },

        updateNotify: function(newObjects) {
          var currentObjects = this.adapter.get();
          var currentLength = currentObjects.length;

          _.each(newObjects, function(object) {
            var found = _.findWhere(currentObjects, { id: object.id });

            if (found) {
              _.extend(found, object);
            } else {
              currentObjects.push(object);
            }
          });

          var isAdded = (currentLength !== currentObjects.length);

          this.adapter.set(currentObjects);

          if (isAdded) {
            // This is only an add event
            this.trigger("updateCalculations");
          } else {
            // Add & modify -- everything must be refreshed
            this.update(currentObjects);
          }
        },

        // The transport handler for a Resource is transport agnostic, so long as
        // the transport follows the same conventions as the default attached
        // class.
        sync: function(method, model, options) {
          var req = Resource.super('sync', this, arguments);
          var resource = this;
          var def = this._def;

          req.then(function(resp) {
            if (resource.channel) {
              resource.channel.publish('classes', resp);
            }
          });

          // Once the request has completed, set the cache.
          //req.then(function(resp) {
          //  adapter.set(resp);

          //  // Store in the state object.
          //  resource.update(resp);
          //});

          // No matter what, always resolve, even if failure occurs.
          //req.always(function() {
          //  // Resolve the internal deferred.
          //  def.resolveWith(this, [adapter.get()]);
          //});

          // Pipe the progress to the notify.
          req.progress(def.notify.bind(this));

          // Return an immutable promise.
          return req;
        },

        initialize: function(options, attributes) {
          // This is used internally to track the state of this resource.
          this._def = $.Deferred();

          // Save this for later mixin.
          this.options = options;

          // Set the name for `where` lookups.
          this.set("name", options.name, { silent: true });

          // By default use RESTful requests.
          this.adapter = RestAdapter;

          // By default use XHR.
          this.transport = XhrTransport;

          this.on("update", this.updateNotify);

          // Defaults.
          this.raw = [];
          this.dataset = _.chain(this.raw);

          // Merge in the additional properties.
          _.extend(this, options);
        }
      });

      module.exports = Resource;
    })(null, module.exports, module);

    return module.exports;
  })();

  /**
   * @module webapp
   * @requires module:channel
   * @requires module:class
   * @requires module:collection
   * @requires module:component
   * @requires module:events
   * @requires module:history
   * @requires module:inheritance
   * @requires module:model
   * @requires module:router
   * @requires module:view
   * @requires module:component/view
   * @requires module:sync
   * @requires module:sync/transports/xhr
   * @requires module:scopedcss
   * @requires module:jquery
   */
  define.modules['lib/index'] = (function() {
    var module = { exports: {} };

    (function(require, exports, module) {
      "use strict";

      // WebApp internals.
      var Channel = define.modules['lib/channel'];
      var Class = define.modules['lib/class'];
      var Collection = define.modules['lib/collection'];
      var Component = define.modules['lib/component'];
      var Events = define.modules['lib/events'];
      var History = define.modules['lib/history'];
      var Inheritance = define.modules['lib/inheritance'];
      var Model = define.modules['lib/model'];
      var Router = define.modules['lib/router'];
      var View = define.modules['lib/view'];
      var ViewComponent = define.modules['lib/component/view'];
      var Sync = define.modules['lib/sync'];
      var SyncResource = define.modules['lib/sync/resource'];
      var XhrTransport = define.modules['lib/sync/transports/xhr'];

      // Third-party dependencies.
      var ScopedCss = define.modules.scopedcss;
      var $ = define.modules.jquery;
      var _ = define.modules.underscore;

      // Automatically register the default View component.
      Component.register(ViewComponent);

      var WebApp = View.extend({
        el: 'main',

        start: function() {
          this.render();
          Router.history.start();
          return this;
        },

        stop: function() {
          this.$el.remove();
          return this;
        },

        afterRender: function() {
          Component.prototype.afterRender.call(this);
        }
      });

      WebApp.mixin({
        // Expose a version.
        VERSION: "0.1.0-wip",

        // Expose jQuery if it's included, also helps remain compatible with
        // Backbone.
        $: $,

        // Expose other libraries (if they are included).
        _: _,
        ScopedCss: ScopedCss,

        // Expose modules.
        Channel: Channel,
        Class: Class,
        Collection: Collection,
        Component: Component,
        Events: Events,
        History: History,
        Inheritance: Inheritance,
        Model: Model,
        Router: Router,
        View: View,

        // Testing.
        Resource: SyncResource,

        // Expose default transport.
        Transports: {
          Xhr: XhrTransport
        },

        // Backbone compatibility helper.
        noConflict: function() {
          window.Backbone = WebApp.Backbone;
          return WebApp;
        },

        // Expose the sync functionality.
        sync: Sync,

        // Mirror Backbone API by exposing an `ajax` method.
        ajax: function() {
          return WebApp.$.ajax.apply(WebApp.$, arguments);
        },

        // Create new history.
        history: new History()
      });

      // Share the history instance with the Router.
      Router.history = WebApp.history;

      module.exports = WebApp;
    })(null, module.exports, module);

    return module.exports;
  })();

  if (define.hadDefine) {
    window.define = define.originalDefine;
  }
  else {
    delete window.define;
  }

  return define.modules['lib/index'];
}));